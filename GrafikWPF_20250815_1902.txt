=== PROJECT: GrafikWPF
=== DATE:    2025-08-15 19:02:14 +01:00
=== ROOT:    C:\Users\adaml\OneDrive\Pulpit\GrafikWPF - projekt — GPT mods
=== FILES:   75

----- BEGIN FILE: ExportProject.ps1 -----
# ExportProject.ps1
# Tworzy jeden TXT ze zrzutem calego kodu (pliki tekstowe) z projektu/rozwiazania.
# Usuwa wczesniejsze logi zgodne ze wzorcem i tworzy nowy.
# Nazwa: <NazwaProjektu>_YYYYMMDD_HHMM.txt

[CmdletBinding()]
param(
    [string[]]$IncludeExtensions = @(
        '.sln','.cs','.xaml','.csproj','.props','.targets','.resx',
        '.config','.json','.xml','.yaml','.yml','.md','.txt',
        '.ps1','.bat','.cmd','.tt','.sql',
        '.cpp','.h','.hpp','.c','.cc',
        '.fs','.fsproj','.vb','.vbproj',
        '.razor','.cshtml'
    ),
    [string[]]$ExcludeDirs = @(
        '.git','.vs','bin','obj','packages','node_modules',
        'dist','out','Debug','Release','.idea','.vscode','.cache'
    )
)

Set-Location -LiteralPath $PSScriptRoot
$root = (Get-Item -LiteralPath $PSScriptRoot).FullName
if (-not $root.EndsWith('\')) { $root += '\' }

# Nazwa projektu wg .sln (pierwszy alfabetycznie) lub nazwa folderu
$sln = Get-ChildItem -LiteralPath $root -Filter *.sln | Sort-Object Name | Select-Object -First 1
$projectName = if ($sln) { [IO.Path]::GetFileNameWithoutExtension($sln.Name) } else { Split-Path -Leaf $root.TrimEnd('\') }

# Czas w formacie YYYYMMDD_HHMM (wymaganie: ..._data_hhmm.txt)
$timestamp = Get-Date -Format "yyyyMMdd_HHmm"
$logName   = "{0}_{1}.txt" -f $projectName, $timestamp
$logPath   = Join-Path -Path $root -ChildPath $logName

# Usun poprzednie logi tego projektu o nazwie <Projekt>_YYYYMMDD_HHMM.txt
Get-ChildItem -LiteralPath $root -Filter "$projectName*.txt" -File -ErrorAction SilentlyContinue |
    Where-Object { $_.Name -match "^$([regex]::Escape($projectName))_\d{8}_\d{4}\.txt$" } |
    Remove-Item -Force -ErrorAction SilentlyContinue

# Zbuduj wzorzec katalogow do pominiecia
$excludePattern = ($ExcludeDirs | ForEach-Object { [regex]::Escape($_) }) -join '|'

# Zbierz pliki do zrzutu
$files = Get-ChildItem -LiteralPath $root -Recurse -File -ErrorAction SilentlyContinue |
    Where-Object {
        $IncludeExtensions -contains $_.Extension.ToLower() -and
        ($_.FullName -notmatch "(\\|/)(?:$excludePattern)(\\|/)")
    } | Sort-Object FullName

# Piszemy jako UTF-8 (bez BOM) poprzez StreamWriter
$utf8NoBom = New-Object System.Text.UTF8Encoding($false)
$sw = New-Object System.IO.StreamWriter($logPath, $false, $utf8NoBom)

try {
    $sw.WriteLine("=== PROJECT: {0}" -f $projectName)
    $sw.WriteLine("=== DATE:    {0}" -f (Get-Date -Format "yyyy-MM-dd HH:mm:ss zzz"))
    $sw.WriteLine("=== ROOT:    {0}" -f $root.TrimEnd('\'))
    $sw.WriteLine("=== FILES:   {0}" -f $files.Count)
    $sw.WriteLine()

    foreach ($f in $files) {
        $rel = $f.FullName.Substring($root.Length)
        $sw.WriteLine("----- BEGIN FILE: {0} -----" -f $rel)
        try {
            $content = Get-Content -LiteralPath $f.FullName -Raw -ErrorAction Stop
            $sw.WriteLine($content)
        }
        catch {
            $sw.WriteLine("[WARNING] Could not read file: {0}" -f $_.Exception.Message)
        }
        $sw.WriteLine("----- END FILE: {0} -----" -f $rel)
        $sw.WriteLine()
    }
}
finally {
    $sw.Close()
}

Write-Host ("Saved file: {0}" -f $logName)

----- END FILE: ExportProject.ps1 -----

----- BEGIN FILE: GenerujPelnyKod.bat -----
@echo off
setlocal ENABLEDELAYEDEXPANSION

set "SCRIPT=%~dp0ExportProject.ps1"

if not exist "%SCRIPT%" (
  echo [BLAD] Nie znaleziono skryptu: "%SCRIPT%"
  pause
  exit /b 1
)

rem Preferuj PowerShell 7 (pwsh), ale w razie czego uzyj Windows PowerShell (powershell.exe)
where pwsh >nul 2>&1
if %ERRORLEVEL%==0 (
  pwsh -NoProfile -ExecutionPolicy Bypass -File "%SCRIPT%"
) else (
  powershell -NoProfile -ExecutionPolicy Bypass -File "%SCRIPT%"
)

if errorlevel 1 (
  echo.
  echo [BLAD] Wystapil problem podczas generowania pliku TXT.
  pause
) else (
  echo.
  echo Gotowe. Plik TXT z pelnym kodem zostal utworzony w katalogu projektu.
  timeout /t 2 >nul
)

----- END FILE: GenerujPelnyKod.bat -----

----- BEGIN FILE: GrafikWPF.sln -----

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36310.24 d17.14
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "GrafikWPF", "GrafikWPF\GrafikWPF.csproj", "{28E7585A-D177-4F0E-BFCC-08B79194AE7B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{28E7585A-D177-4F0E-BFCC-08B79194AE7B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{28E7585A-D177-4F0E-BFCC-08B79194AE7B}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{28E7585A-D177-4F0E-BFCC-08B79194AE7B}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{28E7585A-D177-4F0E-BFCC-08B79194AE7B}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {6A8BC7A0-3932-4344-B90E-A14529CE8721}
	EndGlobalSection
EndGlobal

----- END FILE: GrafikWPF.sln -----

----- BEGIN FILE: GrafikWPF\AlgorithmInfo.cs -----
namespace GrafikWPF
{
    public record AlgorithmInfo(
        string Nazwa,
        string TypAlgorytmu,
        string Powtarzalnosc,
        string Wielowatkowosc,
        string JakoscGwarancja,
        string CzasUzyskaniaWyniku,
        string UzyciePamieci
    );
}
----- END FILE: GrafikWPF\AlgorithmInfo.cs -----

----- BEGIN FILE: GrafikWPF\Algorithms\FlowUB.cs -----
namespace GrafikWPF.Algorithms
{
    public enum AvMask : byte { None = 0, BC = 1, Chce = 2, MogeLike = 4, Any = 7 }

    public static class FlowUB
    {
        // Buduje graf: S -> dni -> lekarze -> T
        // dayCap = 1 jeśli dana kategoria ruchu ma być liczona, inaczej 0.
        public static int UBCount(
            int days, int docs,
            Func<int, int, AvMask> avMask,           // (day,doc) -> AvMask
            Func<int, int> remCapPerDoc,            // doc -> limit - workload
            Func<int, bool> dayAllowed)             // day -> czy dopuszczamy 1 jednostkę
        {
            int N = 2 + days + docs;
            int S = days + docs, T = S + 1;
            var din = new MaxFlowDinic(N);

            for (int d = 0; d < days; d++)
            {
                if (!dayAllowed(d)) continue;
                din.AddEdge(S, d, 1);
            }
            for (int p = 0; p < docs; p++)
            {
                int cap = remCapPerDoc(p);
                if (cap > 0) din.AddEdge(days + p, T, cap);
            }
            for (int d = 0; d < days; d++)
            {
                if (!dayAllowed(d)) continue;
                for (int p = 0; p < docs; p++)
                {
                    var m = avMask(d, p);
                    if (m != AvMask.None) din.AddEdge(d, days + p, 1);
                }
            }
            return din.MaxFlow(S, T);
        }
    }
}

----- END FILE: GrafikWPF\Algorithms\FlowUB.cs -----

----- BEGIN FILE: GrafikWPF\Algorithms\MaxFlowDinic.cs -----
namespace GrafikWPF.Algorithms
{
    // Prosty Dinic (int capacity). Tablicowe struktury, bez LINQ.
    public sealed class MaxFlowDinic
    {
        private readonly int _n;
        private readonly List<Edge>[] _g;
        private int[] _level;
        private int[] _it;

        private sealed class Edge
        {
            public int To, Rev, Cap;
            public Edge(int to, int rev, int cap) { To = to; Rev = rev; Cap = cap; }
        }

        public MaxFlowDinic(int n)
        {
            _n = n;
            _g = new List<Edge>[n];
            for (int i = 0; i < n; i++) _g[i] = new List<Edge>(8);
            _level = new int[n];
            _it = new int[n];
        }

        public void AddEdge(int u, int v, int cap)
        {
            var a = new Edge(v, _g[v].Count, cap);
            var b = new Edge(u, _g[u].Count, 0);
            _g[u].Add(a); _g[v].Add(b);
        }

        private bool Bfs(int s, int t)
        {
            Array.Fill(_level, -1);
            var q = new Queue<int>();
            _level[s] = 0; q.Enqueue(s);
            while (q.Count > 0)
            {
                int v = q.Dequeue();
                foreach (var e in _g[v])
                {
                    if (e.Cap <= 0) continue;
                    if (_level[e.To] >= 0) continue;
                    _level[e.To] = _level[v] + 1;
                    if (e.To == t) return true;
                    q.Enqueue(e.To);
                }
            }
            return _level[t] >= 0;
        }

        private int Dfs(int v, int t, int f)
        {
            if (v == t) return f;
            for (int i = _it[v]; i < _g[v].Count; i++, _it[v] = i)
            {
                var e = _g[v][i];
                if (e.Cap <= 0 || _level[v] + 1 != _level[e.To]) continue;
                int d = Dfs(e.To, t, Math.Min(f, e.Cap));
                if (d <= 0) continue;
                e.Cap -= d;
                _g[e.To][e.Rev].Cap += d;
                return d;
            }
            return 0;
        }

        public int MaxFlow(int s, int t, int need = int.MaxValue)
        {
            int flow = 0;
            while (flow < need && Bfs(s, t))
            {
                Array.Fill(_it, 0);
                int f;
                while (flow < need && (f = Dfs(s, t, need - flow)) > 0) flow += f;
            }
            return flow;
        }
    }
}

----- END FILE: GrafikWPF\Algorithms\MaxFlowDinic.cs -----

----- BEGIN FILE: GrafikWPF\AntColonySolver.cs -----
using System.Collections.Concurrent;

namespace GrafikWPF
{
    public class AntColonySolver : IGrafikSolver
    {
        private readonly int _numAnts;
        private readonly int _maxGenerations;
        private const double EvaporationRate = 0.5;
        private const double Alpha = 1.0;
        private const double Beta = 5.0;
        private const double Q0 = 0.7;

        private readonly GrafikWejsciowy _daneWejsciowe;
        private readonly List<SolverPriority> _kolejnoscPriorytetow;
        private readonly IProgress<double>? _progressReporter;
        private readonly CancellationToken _cancellationToken;
        private readonly SolverUtility _utility;
        private readonly Random _random = new();
        private Dictionary<DateTime, Dictionary<string, double>> _pheromoneMatrix = new();

        public AntColonySolver(GrafikWejsciowy daneWejsciowe, List<SolverPriority> kolejnoscPriorytetow, IProgress<double>? progress = null, CancellationToken cancellationToken = default)
        {
            _daneWejsciowe = daneWejsciowe;
            _kolejnoscPriorytetow = kolejnoscPriorytetow;
            _progressReporter = progress;
            _cancellationToken = cancellationToken;
            _utility = new SolverUtility(daneWejsciowe);

            _numAnts = Math.Max(50, _daneWejsciowe.Lekarze.Count * 3);
            _maxGenerations = Math.Max(200, _daneWejsciowe.DniWMiesiacu.Count * 15);
        }

        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            InitializePheromones();
            var bestSolution = new Dictionary<DateTime, Lekarz?>();
            double bestFitness = double.MinValue;

            for (int i = 0; i < _maxGenerations; i++)
            {
                _cancellationToken.ThrowIfCancellationRequested();

                var solutions = new ConcurrentBag<Dictionary<DateTime, Lekarz?>>();

                Parallel.For(0, _numAnts, ant =>
                {
                    _cancellationToken.ThrowIfCancellationRequested();
                    var solution = BuildSolutionForAnt();
                    solutions.Add(solution);
                });

                var bestInGeneration = solutions.AsParallel().OrderByDescending(s =>
                {
                    var m = EvaluationAndScoringService.CalculateMetrics(s, _utility.ObliczOblozenie(s), _daneWejsciowe);
                    return EvaluationAndScoringService.CalculateScore(m, _kolejnoscPriorytetow, _daneWejsciowe);
                }).First();

                var bestMetrics = EvaluationAndScoringService.CalculateMetrics(bestInGeneration, _utility.ObliczOblozenie(bestInGeneration), _daneWejsciowe);
                var bestFitnessInGeneration = EvaluationAndScoringService.CalculateScore(bestMetrics, _kolejnoscPriorytetow, _daneWejsciowe);

                if (bestFitnessInGeneration > bestFitness)
                {
                    bestFitness = bestFitnessInGeneration;
                    bestSolution = bestInGeneration;
                }

                EvaporatePheromones();
                UpdatePheromones(bestSolution, bestFitness);

                _progressReporter?.Report((double)(i + 1) / _maxGenerations);
            }

            return EvaluationAndScoringService.CalculateMetrics(bestSolution, _utility.ObliczOblozenie(bestSolution), _daneWejsciowe);
        }

        private void InitializePheromones()
        {
            _pheromoneMatrix = new Dictionary<DateTime, Dictionary<string, double>>();
            foreach (var dzien in _daneWejsciowe.DniWMiesiacu)
            {
                _pheromoneMatrix[dzien] = new Dictionary<string, double>();
                foreach (var lekarz in _daneWejsciowe.Lekarze)
                {
                    _pheromoneMatrix[dzien][lekarz.Symbol] = 1.0;
                }
            }
        }

        private Dictionary<DateTime, Lekarz?> BuildSolutionForAnt()
        {
            var newSolution = new Dictionary<DateTime, Lekarz?>();
            var oblozenie = _daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            var wykorzystaneW = new HashSet<string>();

            foreach (var dzien in _daneWejsciowe.DniWMiesiacu)
            {
                var kandydaci = ConstraintValidationService.GetValidCandidatesForDay(dzien, _daneWejsciowe, newSolution, oblozenie, wykorzystaneW);
                if (!kandydaci.Any())
                {
                    newSolution[dzien] = null;
                    continue;
                }

                var attractiveness = kandydaci.ToDictionary(
                    kandydat => kandydat,
                    kandydat => Math.Pow(_pheromoneMatrix[dzien][kandydat.Symbol], Alpha) * Math.Pow(GetHeuristicValue(dzien, kandydat), Beta)
                );

                Lekarz? wybranyLekarz;
                if (_random.NextDouble() < Q0)
                {
                    wybranyLekarz = attractiveness.OrderByDescending(kvp => kvp.Value).First().Key;
                }
                else
                {
                    double totalAttractiveness = attractiveness.Values.Sum();
                    double randomValue = _random.NextDouble() * totalAttractiveness;
                    wybranyLekarz = null;

                    foreach (var choice in attractiveness)
                    {
                        randomValue -= choice.Value;
                        if (randomValue <= 0)
                        {
                            wybranyLekarz = choice.Key;
                            break;
                        }
                    }
                    wybranyLekarz ??= kandydaci.Last();
                }

                newSolution[dzien] = wybranyLekarz;
                oblozenie[wybranyLekarz.Symbol]++;
                if (_daneWejsciowe.Dostepnosc[dzien][wybranyLekarz.Symbol] == TypDostepnosci.MogeWarunkowo)
                {
                    wykorzystaneW.Add(wybranyLekarz.Symbol);
                }
            }
            return newSolution;
        }

        private double GetHeuristicValue(DateTime dzien, Lekarz lekarz)
        {
            return _daneWejsciowe.Dostepnosc[dzien][lekarz.Symbol] switch
            {
                TypDostepnosci.BardzoChce => 100.0,
                TypDostepnosci.Chce => 20.0,
                TypDostepnosci.Moge => 1.0,
                TypDostepnosci.MogeWarunkowo => 0.5,
                _ => 0.1
            };
        }

        private void EvaporatePheromones()
        {
            foreach (var dzien in _pheromoneMatrix.Keys)
            {
                foreach (var lekarzSymbol in _pheromoneMatrix[dzien].Keys.ToList())
                {
                    _pheromoneMatrix[dzien][lekarzSymbol] *= (1.0 - EvaporationRate);
                }
            }
        }

        private void UpdatePheromones(Dictionary<DateTime, Lekarz?> solution, double fitness)
        {
            if (fitness <= 0) return;
            // Skala fitnessu się zmieniła, więc depozyt feromonu wymaga dostosowania.
            // Używamy potęgi, aby wzmocnić różnice między dobrymi a bardzo dobrymi wynikami.
            double pheromoneDeposit = Math.Pow(fitness / 1_000_000_000_000, 2);

            foreach (var entry in solution)
            {
                if (entry.Value != null)
                {
                    _pheromoneMatrix[entry.Key][entry.Value.Symbol] += pheromoneDeposit;
                }
            }
        }
    }
}
----- END FILE: GrafikWPF\AntColonySolver.cs -----

----- BEGIN FILE: GrafikWPF\App.xaml -----
<Application x:Class="GrafikWPF.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:GrafikWPF"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>

----- END FILE: GrafikWPF\App.xaml -----

----- BEGIN FILE: GrafikWPF\App.xaml.cs -----
using System.Windows;

namespace GrafikWPF
{
    public partial class App : Application
    {
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            DataManager.LoadData();
        }
    }
}
----- END FILE: GrafikWPF\App.xaml.cs -----

----- BEGIN FILE: GrafikWPF\AssemblyInfo.cs -----
using System.Windows;

[assembly: ThemeInfo(
    ResourceDictionaryLocation.None,            //where theme specific resource dictionaries are located
                                                //(used if a resource is not found in the page,
                                                // or application resource dictionaries)
    ResourceDictionaryLocation.SourceAssembly   //where the generic resource dictionary is located
                                                //(used if a resource is not found in the page,
                                                // app, or any theme specific resource dictionaries)
)]

----- END FILE: GrafikWPF\AssemblyInfo.cs -----

----- BEGIN FILE: GrafikWPF\AStarSolver.cs -----
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using GrafikWPF.Heuristics;

namespace GrafikWPF
{
    public class AStarSolver : IGrafikSolver
    {
        private const int BOOTSTRAP_DEPTH = 8;
        private const int CLOSURE_EVERY = 1;
        private const int FLOW_EVERY_DEPTH = 6;

        private readonly GrafikWejsciowy _in;
        private readonly List<SolverPriority> _prio;
        private readonly IProgress<double>? _progress;
        private readonly CancellationToken _ct;
        private readonly SolverOptions _opt;

        private readonly int _days, _docs;
        private readonly List<Lekarz> _docsMap;
        private readonly int[,] _av;
        private readonly int[] _limit;
        private readonly bool[,] _nextOther;

        private static long[,] _z = new long[0, 0];
        private static long[] _zEmpty = Array.Empty<long>();
        private static bool _zInit;

        private readonly int[] _sufBC, _sufCh, _sufMg;
        private readonly int _totBC, _totCh, _totMg;

        private readonly List<int>[] _staticCands;
        private readonly long[] _caps;

        private readonly Dictionary<(int nextDay, long capHash), int> _flowCache = new(1 << 12);
        private readonly NodePool _pool = new();

        private struct Node
        {
            public int Parent, Day, LastDoc;
            public long Hash;
            public long[] G;
            public int[] Work;
            public bool[] UsedCond;
            public int BC, CH, MG, Pref, Obs;
        }

        public AStarSolver(GrafikWejsciowy data, List<SolverPriority> kolej, IProgress<double>? progress = null, CancellationToken ct = default, SolverOptions? opt = null)
        {
            _in = data; _prio = kolej; _progress = progress; _ct = ct; _opt = opt ?? new SolverOptions();

            _docsMap = _in.Lekarze.FindAll(l => l.IsAktywny);
            _days = _in.DniWMiesiacu.Count; _docs = _docsMap.Count;

            _av = new int[_days, _docs]; _limit = new int[_docs]; _nextOther = new bool[_days, _docs];

            for (int p = 0; p < _docs; p++)
            {
                var sym = _docsMap[p].Symbol;
                _limit[p] = _in.LimityDyzurow.TryGetValue(sym, out var lim) ? lim : _days;
            }

            bool[] anyBC = new bool[_days], anyCh = new bool[_days], anyMg = new bool[_days];
            for (int d = 0; d < _days; d++)
            {
                var day = _in.DniWMiesiacu[d];
                for (int p = 0; p < _docs; p++)
                {
                    var sym = _docsMap[p].Symbol;
                    var a = _in.Dostepnosc[day].GetValueOrDefault(sym, TypDostepnosci.Niedostepny);
                    _av[d, p] = (int)a;
                    var y = day.AddDays(-1); var t = day.AddDays(1);
                    if ((_in.Dostepnosc.ContainsKey(y) && _in.Dostepnosc[y][sym] == TypDostepnosci.DyzurInny) ||
                        (_in.Dostepnosc.ContainsKey(t) && _in.Dostepnosc[t][sym] == TypDostepnosci.DyzurInny))
                        _nextOther[d, p] = true;
                    if (a == TypDostepnosci.BardzoChce) anyBC[d] = true;
                    if (a == TypDostepnosci.Chce) anyCh[d] = true;
                    if (a == TypDostepnosci.Moge || a == TypDostepnosci.MogeWarunkowo) anyMg[d] = true;
                }
            }
            _sufBC = BuildSuffix(anyBC); _sufCh = BuildSuffix(anyCh); _sufMg = BuildSuffix(anyMg);
            _totBC = Count(anyBC); _totCh = Count(anyCh); _totMg = Count(anyMg);

            _staticCands = new List<int>[_days];
            for (int d = 0; d < _days; d++)
            {
                var v = new List<int>(Math.Max(2, _docs / 4));
                for (int p = 0; p < _docs; p++)
                {
                    var av = (TypDostepnosci)_av[d, p];
                    if (av is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny) continue;
                    v.Add(p);
                }
                _staticCands[d] = v;
            }

            _caps = new long[_prio.Count + 4];
            int i = 0;

            var prioPart = _prio.Select(p => (p == SolverPriority.SprawiedliwoscObciazenia || p == SolverPriority.RownomiernoscRozlozenia) ? 0L : _days).ToArray();
            Array.Copy(prioPart, _caps, prioPart.Length);
            i += prioPart.Length;

            _caps[i++] = long.MaxValue; // Rezerwacje nie mają limitu
            _caps[i++] = _totBC;
            _caps[i++] = _totCh;
            _caps[i++] = _totMg;

            InitZobrist();
        }

        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            int[] wlSeed;
            int[] seed = GreedySeed.Generate(_in, out wlSeed);
            if (_opt.UseLocalSearch) LocalSearch.Improve(seed, _in);

            if (!CheckSeedFeasible(seed))
                seed = BuildGreedyFeasibleSeed();

            var bestMetrics = ToMetrics(seed);
            long[] bestVec = EvaluationAndScoringService.ToIntVector(bestMetrics, _prio);
            int[] bestAssign = (int[])seed.Clone();

            var start = NewRootNode();
            var budgetAt = DateTime.UtcNow.AddSeconds(_opt.TimeBudgetSeconds);

            double startW = _opt.UseARAStar ? _opt.EpsilonSchedule[0] : (_opt.WeightedAStarW > 1.0 ? _opt.WeightedAStarW : 1.0);
            var epsSchedule = _opt.UseARAStar ? _opt.EpsilonSchedule : new[] { startW };

            long steps = 0;

            foreach (var eps in epsSchedule)
            {
                var open = new PriorityQueue<Node, (long, long, long, long, long, long, long, long, long)>();
                var closed = new Dictionary<(int, long), long[]>(1 << 18);
                Enqueue(open, start, eps);

                while (open.Count > 0)
                {
                    _ct.ThrowIfCancellationRequested();
                    if (DateTime.UtcNow > budgetAt) goto RETURN;

                    var cur = open.Dequeue();

                    var curF = AddWithCaps(cur.G, Heur(cur, eps));
                    var key = (cur.Day, cur.Hash);
                    if (closed.TryGetValue(key, out var bestF) && Less(bestF, curF)) continue;
                    closed[key] = curF;

                    steps++;
                    if ((_opt.ProgressReportModulo > 0) && ((steps & _opt.ProgressReportModulo) == 0))
                        _progress?.Report((double)(cur.Day + 1) / Math.Max(1, _days));

                    if ((steps % CLOSURE_EVERY) == 0)
                    {
                        var (cand, vec) = GreedyClosure(cur);
                        if (Less(vec, bestVec)) { bestVec = vec; bestAssign = cand; }
                    }

                    if (cur.Day == _days - 1)
                    {
                        var a = Reconstruct(cur);
                        var m = ToMetrics(a);
                        var v = EvaluationAndScoringService.ToIntVector(m, _prio);
                        if (Less(v, bestVec)) { bestVec = v; bestAssign = a; }
                        continue;
                    }

                    int nextDay = cur.Day + 1;

                    var baseList = _staticCands[nextDay];
                    var legal = new List<int>(baseList.Count);
                    for (int i = 0; i < baseList.Count; i++)
                    {
                        int p = baseList[i];
                        if (IsValidDynamic(nextDay, p, cur)) legal.Add(p);
                    }

                    legal.Sort((a, b) => CompareDelta(cur, nextDay, a, b));

                    bool anyEnqueued = false;
                    for (int k = 0; k < legal.Count; k++)
                    {
                        int p = legal[k];
                        var nxt = Make(cur, nextDay, p);
                        var fVec = AddWithCaps(nxt.G, Heur(nxt, eps));
                        if (nextDay >= BOOTSTRAP_DEPTH)
                        {
                            if (!Less(fVec, bestVec) && !Equal(fVec, bestVec)) continue;
                        }
                        Enqueue(open, nxt, eps, fVec);
                        anyEnqueued = true;
                    }

                    if (legal.Count == 0)
                    {
                        var nxt = Make(cur, nextDay, -1);
                        var fVec = AddWithCaps(nxt.G, Heur(nxt, eps));
                        if (nextDay < BOOTSTRAP_DEPTH || Less(fVec, bestVec) || Equal(fVec, bestVec))
                        {
                            Enqueue(open, nxt, eps, fVec);
                            anyEnqueued = true;
                        }
                    }

                    if (!anyEnqueued && legal.Count > 0)
                    {
                        int p = legal[0];
                        var nxt = Make(cur, nextDay, p);
                        var fVec = AddWithCaps(nxt.G, Heur(nxt, eps));
                        Enqueue(open, nxt, eps, fVec);
                    }
                }
            }

        RETURN:
            return ToMetrics(bestAssign);
        }

        private void InitZobrist()
        {
            if (_zInit && _z.GetLength(0) >= _days && _z.GetLength(1) >= _docs) return;
            _z = new long[_days, _docs]; _zEmpty = new long[_days];
            var rnd = new Random(12345);
            for (int d = 0; d < _days; d++) { _zEmpty[d] = rnd.NextInt64(); for (int p = 0; p < _docs; p++) _z[d, p] = rnd.NextInt64(); }
            _zInit = true;
        }

        private Node NewRootNode()
        {
            return new Node
            {
                Parent = -1,
                Day = -1,
                LastDoc = -2,
                Hash = 0,
                G = new long[_prio.Count + 4],
                Work = new int[_docs],
                UsedCond = new bool[_docs],
                BC = 0,
                CH = 0,
                MG = 0,
                Pref = 0,
                Obs = 0
            };
        }

        private void Enqueue(PriorityQueue<Node, (long, long, long, long, long, long, long, long, long)> pq, Node n, double eps, long[]? fOverrideVec = null)
        {
            var F = fOverrideVec ?? AddWithCaps(n.G, Heur(n, eps));
            var key = ToKeyForMinHeap(F, n);
            pq.Enqueue(n, key);
        }

        private (long, long, long, long, long, long, long, long, long) ToKeyForMinHeap(long[] F, Node n)
        {
            long tieA = -n.Pref;
            long tieB = (n.LastDoc == -1 ? 1L : 0L);
            long tie = (tieA << 32) ^ (tieB & 0xFFFFFFFFL);

            var fValues = new long[8];
            Array.Copy(F, fValues, F.Length);

            return (-fValues[0], -fValues[1], -fValues[2], -fValues[3], -fValues[4], -fValues[5], -fValues[6], -fValues[7], tie);
        }

        private long[] Heur(Node n, double eps)
        {
            int next = n.Day + 1;
            int rem = _days - (n.Day + 1);
            if (rem <= 0) return new long[_prio.Count + 4];

            int remCap = 0; for (int p = 0; p < _docs; p++) remCap += Math.Max(0, _limit[p] - n.Work[p]);
            int ubObs = Math.Min(rem, remCap);

            if ((next % FLOW_EVERY_DEPTH) == 0)
            {
                int matchUB = MatchingUB(next, n.Work);
                if (matchUB < ubObs) ubObs = matchUB;
            }

            int ubPref = (n.Pref == next ? rem : 0);

            var h = new long[_prio.Count + 4];
            int i = 0;

            var prioHeuristics = new Dictionary<SolverPriority, int>
            {
                { SolverPriority.LacznaLiczbaObsadzonychDni, ubObs },
                { SolverPriority.CiagloscPoczatkowa, ubPref },
                { SolverPriority.SprawiedliwoscObciazenia, 0 },
                { SolverPriority.RownomiernoscRozlozenia, 0 }
            };

            foreach (var p in _prio) h[i++] = prioHeuristics[p];

            h[i++] = 0; // Rezerwacje
            h[i++] = _sufBC[next];
            h[i++] = _sufCh[next];
            h[i++] = _sufMg[next];

            if (eps != 1.0) for (int k = 0; k < h.Length; k++) h[k] = (long)Math.Ceiling(h[k] * eps);
            for (int k = 0; k < h.Length; k++) if (_caps[k] > 0 && h[k] > _caps[k]) h[k] = _caps[k];
            return h;
        }

        private long[] AddWithCaps(long[] g, long[] h)
        {
            var r = new long[g.Length];
            for (int i = 0; i < g.Length; i++)
            {
                long s = g[i] + h[i];
                long c = _caps[i];
                r[i] = (c > 0 && s > c) ? c : s;
            }
            return r;
        }

        private static bool Less(long[] a, long[] b)
        {
            for (int i = 0; i < a.Length; i++) { if (a[i] == b[i]) continue; return a[i] > b[i]; }
            return false;
        }
        private static bool Equal(long[] a, long[] b) { for (int i = 0; i < a.Length; i++) if (a[i] != b[i]) return false; return true; }

        private Node Make(Node cur, int day, int doc)
        {
            var n = new Node
            {
                Parent = _pool.Add(cur),
                Day = day,
                LastDoc = doc,
                Hash = cur.Hash,
                G = (long[])cur.G.Clone(),
                Work = (int[])cur.Work.Clone(),
                UsedCond = (bool[])cur.UsedCond.Clone(),
                BC = cur.BC,
                CH = cur.CH,
                MG = cur.MG,
                Pref = cur.Pref,
                Obs = cur.Obs
            };
            if (doc != -1)
            {
                n.Obs++; n.Work[doc]++;
                var av = (TypDostepnosci)_av[day, doc];
                if (av == TypDostepnosci.BardzoChce) n.BC++;
                else if (av == TypDostepnosci.Chce) n.CH++;
                else n.MG++;
                if (av == TypDostepnosci.MogeWarunkowo && !n.UsedCond[doc]) n.UsedCond[doc] = true;
                n.Hash ^= _z[day, doc];
            }
            else n.Hash ^= _zEmpty[day];

            if (n.Pref == day) n.Pref = (doc == -1) ? n.Pref : n.Pref + 1;

            int i = 0;
            var currentMetrics = new Dictionary<SolverPriority, int>
            {
                { SolverPriority.LacznaLiczbaObsadzonychDni, n.Obs },
                { SolverPriority.CiagloscPoczatkowa, n.Pref },
                { SolverPriority.SprawiedliwoscObciazenia, 0 },
                { SolverPriority.RownomiernoscRozlozenia, 0 }
            };

            foreach (var p in _prio) n.G[i++] = currentMetrics[p];

            n.G[i++] = 0; // Rezerwacje
            n.G[i++] = n.BC;
            n.G[i++] = n.CH;
            n.G[i++] = n.MG;
            return n;
        }

        private bool IsValidDynamic(int day, int p, Node n)
        {
            if (p < 0) return true;
            if (n.Work[p] >= _limit[p]) return false;
            var av = (TypDostepnosci)_av[day, p];
            bool bc = av == TypDostepnosci.BardzoChce;

            if (!bc && day > 0 && AssignedAtDay(n, day - 1) == p) return false;
            if (!bc && _nextOther[day, p]) return false;
            if (av == TypDostepnosci.MogeWarunkowo && n.UsedCond[p]) return false;
            return true;
        }

        private int AssignedAtDay(Node n, int day)
        {
            while (n.Parent >= 0)
            {
                if (n.Day == day) return n.LastDoc;
                n = _pool.Get(n.Parent);
            }
            return -3;
        }

        private int CompareDelta(Node cur, int day, int pa, int pb)
        {
            if (pa == pb) return 0;
            var da = BuildDelta(cur, day, pa);
            var db = BuildDelta(cur, day, pb);
            for (int i = 0; i < da.Length; i++)
            {
                if (da[i] == db[i]) continue;
                return da[i] > db[i] ? -1 : 1;
            }
            int wla = cur.Work[pa], wlb = cur.Work[pb];
            if (wla != wlb) return wla < wlb ? -1 : 1;
            return pa.CompareTo(pb);
        }

        private long[] BuildDelta(Node cur, int day, int p)
        {
            var res = new long[_prio.Count + 4];
            int k = 0;

            var deltaMetrics = new Dictionary<SolverPriority, long>();
            deltaMetrics[SolverPriority.LacznaLiczbaObsadzonychDni] = 1;
            deltaMetrics[SolverPriority.CiagloscPoczatkowa] = (cur.Pref == day ? 1 : 0);

            int max = 0, min = int.MaxValue;
            for (int d = 0; d < _docs; d++) { int w = cur.Work[d]; if (w > max) max = w; if (w < min) min = w; }
            int nb = cur.Work[p] + 1;
            int nmax = Math.Max(max, nb);
            int nmin = Math.Min(min, (p == IndexOfMin(cur.Work, min) ? nb : min));
            deltaMetrics[SolverPriority.SprawiedliwoscObciazenia] = (max - min) - (nmax - nmin);

            int last = LastDayForDoc(cur, p);
            deltaMetrics[SolverPriority.RownomiernoscRozlozenia] = (last < 0) ? 100 : (day - last - 1);

            foreach (var pr in _prio)
            {
                res[k++] = deltaMetrics[pr];
            }

            var av = (TypDostepnosci)_av[day, p];
            res[k++] = 0; // Rezerwacje
            res[k++] = av == TypDostepnosci.BardzoChce ? 1 : 0;
            res[k++] = av == TypDostepnosci.Chce ? 1 : 0;
            res[k++] = (av == TypDostepnosci.Moge || av == TypDostepnosci.MogeWarunkowo) ? 1 : 0;
            return res;
        }

        private int IndexOfMin(int[] arr, int currentMin)
        {
            for (int i = 0; i < arr.Length; i++) if (arr[i] == currentMin) return i;
            return -1;
        }

        private int LastDayForDoc(Node n, int doc)
        {
            if (n.Parent < 0) return -1;
            while (n.Parent >= 0)
            {
                if (n.LastDoc == doc) return n.Day;
                n = _pool.Get(n.Parent);
            }
            return -1;
        }

        private int[] Reconstruct(Node leaf)
        {
            var res = new int[_days]; Array.Fill(res, -1);
            var n = leaf;
            while (n.Parent >= 0) { res[n.Day] = n.LastDoc; n = _pool.Get(n.Parent); }
            return res;
        }

        private RozwiazanyGrafik ToMetrics(int[] a)
        {
            var map = new Dictionary<DateTime, Lekarz?>(a.Length);
            var ob = new Dictionary<string, int>(_docs);
            for (int p = 0; p < _docs; p++) ob[_docsMap[p].Symbol] = 0;
            for (int d = 0; d < _days; d++)
            {
                var day = _in.DniWMiesiacu[d];
                int p = a[d];
                if (p >= 0) { var L = _docsMap[p]; map[day] = L; ob[L.Symbol]++; } else map[day] = null;
            }
            return EvaluationAndScoringService.CalculateMetrics(map, ob, _in);
        }

        private static int[] BuildSuffix(bool[] any) { int n = any.Length; var s = new int[n + 1]; for (int i = n - 1; i >= 0; i--) s[i] = s[i + 1] + (any[i] ? 1 : 0); return s; }
        private static int Count(bool[] a) { int c = 0; for (int i = 0; i < a.Length; i++) if (a[i]) c++; return c; }

        private bool CheckSeedFeasible(int[] a)
        {
            var wl = new int[_docs];
            var usedCond = new bool[_docs];
            for (int d = 0; d < _days; d++)
            {
                int p = a[d];
                if (p < 0) continue;
                wl[p]++;
                if (wl[p] > _limit[p]) return false;
                var av = (TypDostepnosci)_av[d, p];
                if (av != TypDostepnosci.BardzoChce && d > 0 && a[d - 1] == p) return false;
                if (av != TypDostepnosci.BardzoChce && _nextOther[d, p]) return false;
                if (av == TypDostepnosci.MogeWarunkowo)
                {
                    if (usedCond[p]) return false;
                    usedCond[p] = true;
                }
            }
            return true;
        }

        private int[] BuildGreedyFeasibleSeed()
        {
            var assign = new int[_days]; Array.Fill(assign, -1);
            var work = new int[_docs];
            var used = new bool[_docs];

            for (int d = 0; d < _days; d++)
            {
                int best = -1;
                long[] bestDelta = null!;

                var lst = _staticCands[d];
                for (int i = 0; i < lst.Count; i++)
                {
                    int p = lst[i];
                    if (work[p] >= _limit[p]) continue;
                    var av = (TypDostepnosci)_av[d, p];
                    bool bc = av == TypDostepnosci.BardzoChce;
                    if (!bc && (d > 0 && assign[d - 1] == p)) continue;
                    if (!bc && _nextOther[d, p]) continue;
                    if (av == TypDostepnosci.MogeWarunkowo && used[p]) continue;

                    var fake = new Node { Parent = -1, Work = work, UsedCond = used, Pref = LongestPrefix(assign, d, p) };
                    var delta = BuildDelta(fake, d, p);

                    if (best == -1 || LexGreater(delta, bestDelta))
                    {
                        best = p; bestDelta = delta;
                    }
                }
                if (best != -1)
                {
                    assign[d] = best;
                    work[best]++;
                    var av = (TypDostepnosci)_av[d, best];
                    if (av == TypDostepnosci.MogeWarunkowo && !used[best]) used[best] = true;
                }
            }
            return assign;
        }

        private (int[] assign, long[] vec) GreedyClosure(Node baseNode)
        {
            var assign = Reconstruct(baseNode);
            var work = (int[])baseNode.Work.Clone();
            var used = (bool[])baseNode.UsedCond.Clone();

            for (int d = baseNode.Day + 1; d < _days; d++)
            {
                int best = -1;
                long[] bestDelta = null!;

                var lst = _staticCands[d];
                for (int i = 0; i < lst.Count; i++)
                {
                    int p = lst[i];
                    if (work[p] >= _limit[p]) continue;
                    var av = (TypDostepnosci)_av[d, p];
                    bool bc = av == TypDostepnosci.BardzoChce;
                    if (!bc && (d > 0 && assign[d - 1] == p)) continue;
                    if (!bc && _nextOther[d, p]) continue;
                    if (av == TypDostepnosci.MogeWarunkowo && used[p]) continue;

                    var fake = new Node { Parent = -1, Work = work, UsedCond = used, Pref = LongestPrefix(assign, d, p) };
                    var delta = BuildDelta(fake, d, p);

                    if (best == -1 || LexGreater(delta, bestDelta))
                    {
                        best = p; bestDelta = delta;
                    }
                }
                if (best != -1)
                {
                    assign[d] = best;
                    work[best]++;
                    var av = (TypDostepnosci)_av[d, best];
                    if (av == TypDostepnosci.MogeWarunkowo && !used[best]) used[best] = true;
                }
                else assign[d] = -1;
            }

            var m = ToMetrics(assign);
            return (assign, EvaluationAndScoringService.ToIntVector(m, _prio));
        }

        private static bool LexGreater(long[] a, long[] b)
        {
            if (b == null) return true;
            for (int i = 0; i < a.Length; i++) { if (a[i] == b[i]) continue; return a[i] > b[i]; }
            return false;
        }

        private static int LongestPrefix(int[] assign, int day, int candidate)
        {
            int k = 0;
            while (k < day)
            {
                int a = assign[k];
                if (a < 0) break;
                k++;
            }
            if (k == day && candidate != -1) k++;
            return k;
        }

        private int MatchingUB(int nextDay, int[] workNow)
        {
            long h = 1469598103934665603L;
            for (int p = 0; p < _docs; p++)
            {
                int cap = Math.Max(0, _limit[p] - workNow[p]);
                unchecked { h ^= (uint)cap; h *= 1099511628211L; }
            }
            var key = (nextDay, h);
            if (_flowCache.TryGetValue(key, out var cached)) return cached;

            var rightIndex = new List<(int doc, int slot)>();
            var docStart = new int[_docs];
            int R = 0;
            for (int p = 0; p < _docs; p++)
            {
                docStart[p] = R;
                int cap = Math.Max(0, _limit[p] - workNow[p]);
                for (int s = 0; s < cap; s++) { rightIndex.Add((p, s)); R++; }
            }
            if (R == 0) { _flowCache[key] = 0; return 0; }

            int L = _days - nextDay;
            var adj = new List<int>[L];
            for (int li = 0; li < L; li++)
            {
                int day = nextDay + li;
                var edges = new List<int>();
                for (int p = 0; p < _docs; p++)
                {
                    var av = (TypDostepnosci)_av[day, p];
                    if (av is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny) continue;
                    int cap = Math.Max(0, _limit[p] - workNow[p]);
                    for (int s = 0; s < cap; s++) edges.Add(docStart[p] + s);
                }
                adj[li] = edges;
            }

            int match = HopcroftKarp(L, R, adj);
            _flowCache[key] = match;
            return match;
        }

        private static int HopcroftKarp(int L, int R, List<int>[] adj)
        {
            var pairU = new int[L]; Array.Fill(pairU, -1);
            var pairV = new int[R]; Array.Fill(pairV, -1);
            var dist = new int[L];

            bool BFS()
            {
                var q = new Queue<int>();
                for (int u = 0; u < L; u++)
                {
                    if (pairU[u] == -1) { dist[u] = 0; q.Enqueue(u); }
                    else dist[u] = int.MaxValue;
                }
                bool reachableFree = false;
                while (q.Count > 0)
                {
                    int u = q.Dequeue();
                    foreach (var v in adj[u])
                    {
                        int u2 = pairV[v];
                        if (u2 != -1 && dist[u2] == int.MaxValue)
                        {
                            dist[u2] = dist[u] + 1;
                            q.Enqueue(u2);
                        }
                        if (u2 == -1) reachableFree = true;
                    }
                }
                return reachableFree;
            }

            bool DFS(int u)
            {
                foreach (var v in adj[u])
                {
                    int u2 = pairV[v];
                    if (u2 == -1 || (dist[u2] == dist[u] + 1 && DFS(u2)))
                    {
                        pairU[u] = v; pairV[v] = u; return true;
                    }
                }
                dist[u] = int.MaxValue;
                return false;
            }

            int result = 0;
            while (BFS())
                for (int u = 0; u < L; u++)
                    if (pairU[u] == -1 && DFS(u)) result++;
            return result;
        }

        private sealed class NodePool
        {
            private readonly List<Node> _buf = new(1 << 20);
            public int Add(Node n) { _buf.Add(n); return _buf.Count - 1; }
            public Node Get(int i) => _buf[i];
        }
    }
}
----- END FILE: GrafikWPF\AStarSolver.cs -----

----- BEGIN FILE: GrafikWPF\BacktrackingSolver.cs -----
using System.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading;

namespace GrafikWPF
{
    /// <summary>
    /// "BTSolver Adam" â€“ dwuetapowy backtracking
    /// Etap F1: maksymalizacja ciÄ…gÅ‚oÅ›ci od poczÄ…tku miesiÄ…ca (jeÅ›li taki priorytet jest #1).
    ///          Przeszukiwanie gaÅ‚Ä™ziami dzieÅ„ po dniu: BC > CH > MG > MW, twarde zasady (RZ, limity).
    ///          Gdy brak obsady danego dnia â€“ backtrack. Najlepszy znaleziony prefiks zapamiÄ™tywany.
    /// Etap F2: maksymalizacja Å‚Ä…cznej obsady pozostaÅ‚ych dni (tie-break wg pozostaÅ‚ych priorytetÃ³w).
    ///          Preferencje: BC > CH > MG > MW. MW â‰¤ 1/osoba.
    /// ÅšwiÄ™toÅ›ci: RZ zawsze przydzielane; limitÃ³w nie przekraczamy.
    /// Zasady sÄ…siedztwa: BC moÅ¼e Å‚amaÄ‡ â€ždzieÅ„ po dniuâ€ i â€žInny dyÅ¼ur Â±1â€. MG/CH/MW â€“ nie.
    /// Logowanie zgodne z SolverDiagnostics.
    /// </summary>
    public sealed class BacktrackingSolver : IGrafikSolver
    {
        // Preferencje / kody
        private const byte PREF_NONE = 0; // brak / niedostÄ™pny
        private const byte PREF_MW = 1; // MogÄ™ warunkowo (max 1 w miesiÄ…cu)
        private const byte PREF_MG = 2; // MogÄ™
        private const byte PREF_CH = 3; // ChcÄ™
        private const byte PREF_BC = 4; // Bardzo chcÄ™
        private const byte PREF_RZ = 5; // Rezerwacja (musi byÄ‡)
        private const byte PREF_OD = 6; // DyÅ¼ur (inny) â€“ dzieÅ„ +/-1 (blok sÄ…siedztwa dla MG/CH/MW)

        // Stany przypisaÅ„
        private const int UNASSIGNED = int.MinValue;
        private const int EMPTY = -1;

        private readonly GrafikWejsciowy _input;
        private readonly IReadOnlyList<SolverPriority> _priorities;
        private readonly IProgress<double>? _progress;
        private readonly CancellationToken _token;

        private readonly List<DateTime> _days;
        private readonly List<Lekarz> _docs;
        private readonly Dictionary<string, int> _docIdxBySymbol;
        private readonly Dictionary<DateTime, Dictionary<string, TypDostepnosci>> _av;
        private readonly int[] _limitsByDoc;

        private readonly byte[,] _pref; // [day, doc] -> PREF_*

        // BieÅ¼Ä…cy stan
        private readonly int[] _assign; // day -> doc idx; EMPTY/UNASSIGNED
        private readonly int[] _workPerDoc; // przydzielone
        private readonly int[] _mwUsed; // wykorzystane MW
        private int _filled;

        // Najlepszy wynik / scoring
        private RozwiazanyGrafik? _best;
        private long[]? _bestScore;

        // F1 â€“ prefiks
        private int _bestPrefixLen;
        private int[]? _bestPrefixAssign; // snapshot assign dla najlepszego prefiksu

        // Polityki (na teraz: CHProtect OFF, BC moÅ¼e Å‚amaÄ‡ sÄ…siedztwo, MW<=1)
        private readonly bool _chProtectEnabled = false;
        private readonly bool _bcBreaksAdjacent = true;
        private readonly int _mwMax = 1;

        public BacktrackingSolver(GrafikWejsciowy input,
                                  IReadOnlyList<SolverPriority> priorities,
                                  IProgress<double>? progress,
                                  CancellationToken token)
        {
            _input = input;
            _priorities = priorities ?? Array.Empty<SolverPriority>();
            _progress = progress;
            _token = token;

            _days = _input.Dostepnosc.Keys.OrderBy(d => d).ToList();
            _docs = _input.Lekarze.OrderBy(l => l.Nazwisko).ThenBy(l => l.Imie).ToList();

            _docIdxBySymbol = new Dictionary<string, int>(_docs.Count);
            for (int i = 0; i < _docs.Count; i++) _docIdxBySymbol[_docs[i].Symbol] = i;

            _av = _input.Dostepnosc;
            _limitsByDoc = new int[_docs.Count];
            for (int i = 0; i < _docs.Count; i++)
            {
                var sym = _docs[i].Symbol;
                _limitsByDoc[i] = _input.LimityDyzurow.TryGetValue(sym, out var lim) ? lim : _days.Count;
            }

            _pref = new byte[_days.Count, _docs.Count];
            PrecomputeAvailability();

            _assign = Enumerable.Repeat(UNASSIGNED, _days.Count).ToArray();
            _workPerDoc = new int[_docs.Count];
            _mwUsed = new int[_docs.Count];
            _filled = 0;

            _bestPrefixLen = 0;
        }

        // ===================== API =====================
        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            if (!SolverDiagnostics.IsActive)
            {
                SolverDiagnostics.Enabled = true;
                SolverDiagnostics.Start();
            }
                // NagÅ‚Ã³wek diagnostyki / polityk
                try
                {
                    var pri = _priorities ?? DataManager.AppData.KolejnoscPriorytetowSolvera;
                    SolverPolicyStatus.LogStartupHeader(
                        solverName: "Backtracking",
                        priorities: pri,
                        chProtectEnabled: _chProtectEnabled,
                        bcBreaksAdjacent: _bcBreaksAdjacent,
                        mwMax: _mwMax,
                        rhK: (2, 2),     // Rolling Horizon: min=2, max=2 (w tym solverze RH nie uÅ¼ywamy)
                        lrBack: (0, 0),  // LocalRepair back: wyÅ‚Ä…czone
                        lrFwd: (0, 0)    // LocalRepair fwd: wyÅ‚Ä…czone
                    );
                }
                catch (Exception ex)
                {
                    SolverDiagnostics.Log("[Policy] Header logging failed: " + ex.Message);
                }

                SolverDiagnostics.Log("=== Start BacktrackingSolver (Adam) ===");
                SolverDiagnostics.Log($"Dni: {_days.Count}, lekarze: {_docs.Count}");
                SolverDiagnostics.Log($"Priorytety: {string.Join(", ", _priorities)}");
                LogLimits();
                LogLegendAndAvailability();

                // Faza 1: Maksymalizacja prefiksu (jeÅ›li priorytet #1 to CiÄ…gÅ‚oÅ›Ä‡; w przeciwnym razie â€“ pusta F1)
                bool continuityFirst = _priorities.Count > 0 && _priorities[0] == SolverPriority.CiagloscPoczatkowa;
                if (continuityFirst)
                {
                    SolverDiagnostics.Log("[F1] Start â€“ maksymalizacja ciÄ…gÅ‚oÅ›ci od poczÄ…tku");
                    F1_MaximizePrefix();
                    SolverDiagnostics.Log($"[F1] Stop â€“ najlepszy prefiks = {_bestPrefixLen}");
                }
                else
                {
                    SolverDiagnostics.Log("[F1] PominiÄ™to â€“ priorytet #1 â‰  CiÄ…gÅ‚oÅ›Ä‡");
                    _bestPrefixLen = 0;
                }

                // Zastosuj najlepszy prefiks do stanu gÅ‚Ã³wnego
                if (_bestPrefixAssign != null && _bestPrefixLen > 0)
                {
                    ApplyPrefixSnapshot(_bestPrefixAssign, _bestPrefixLen);
                }

                // Faza 2: Maksymalizacja obsady reszty
                SolverDiagnostics.Log("[F2] Start â€“ maksymalizacja Å‚Ä…cznej obsady pozostaÅ‚ych dni");
                F2_MaximizeCoverageFrom(_bestPrefixLen);
                SolverDiagnostics.Log("[F2] Stop");

                // Finalizacja: scoring po zadanej kolejnoÅ›ci priorytetÃ³w
                var sol = SnapshotToSolution();
                var score = EvaluateSolution(sol);
                _best = sol;
                _bestScore = score;
                SolverDiagnostics.Log($"[BEST] vec={FormatScore(score)}");

                return _best;
                SolverDiagnostics.Stop();
            }
        
        // ===================== Prekomputacja =====================
        private void PrecomputeAvailability()
        {
            for (int d = 0; d < _days.Count; d++)
            {
                var date = _days[d];
                for (int j = 0; j < _docs.Count; j++)
                {
                    var sym = _docs[j].Symbol;
                    var td = (_av.TryGetValue(date, out var map) && map.TryGetValue(sym, out var t))
                        ? t : TypDostepnosci.Niedostepny;
                    _pref[d, j] = td switch
                    {
                        TypDostepnosci.MogeWarunkowo => PREF_MW,
                        TypDostepnosci.Moge => PREF_MG,
                        TypDostepnosci.Chce => PREF_CH,
                        TypDostepnosci.BardzoChce => PREF_BC,
                        TypDostepnosci.Rezerwacja => PREF_RZ,
                        TypDostepnosci.DyzurInny => PREF_OD,
                        _ => PREF_NONE
                    };
                }
            }
        }

        // ===================== F1: Maksymalizacja prefiksu =====================
        private void F1_MaximizePrefix()
        {
            var curAssign = new int[_days.Count];
            Array.Fill(curAssign, UNASSIGNED);
            var curWork = new int[_docs.Count];
            var curMW = new int[_docs.Count];
            int prefixLen = 0;

            void DFS(int day)
            {
                _token.ThrowIfCancellationRequested();
                _progress?.Report(day / (double)_days.Count);

                // Aktualizacja najlepszego prefiksu
                if (day > _bestPrefixLen)
                {
                    _bestPrefixLen = day;
                    _bestPrefixAssign = (int[])curAssign.Clone();
                    SolverDiagnostics.Log($"[F1] Nowy najlepszy prefiks: {_bestPrefixLen} ({FormatDay(_bestPrefixLen - 1)})");
                }
                if (day >= _days.Count) return;

                // Kandydaci na ten dzieÅ„
                var cands = F1_OrderCandidates(day, curAssign, curWork, curMW);
                LogCandidates(day, cands, curAssign, curWork);

                if (cands.Count == 0)
                {
                    // brak obsady => zatrzymujemy siÄ™ (koniec gaÅ‚Ä™zi)
                    return;
                }

                foreach (var doc in cands)
                {
                    byte code = _pref[day, doc];
                    // twarde zasady
                    if (!F1_IsFeasible(day, doc, curAssign, curWork, curMW)) continue;

                    // pick
                    curAssign[day] = doc;
                    curWork[doc]++;
                    if (code == PREF_MW) curMW[doc]++;

                    SolverDiagnostics.Log($"[F1] Pick: {FormatDay(day)} â† {_docs[doc].Symbol} [{PrefToString(code)}]");
                    DFS(day + 1);

                    // backtrack
                    if (code == PREF_MW) curMW[doc]--;
                    curWork[doc]--;
                    curAssign[day] = UNASSIGNED;
                    SolverDiagnostics.Log($"[F1][Backtrack] â† {FormatDay(day)}");
                }
            }

            DFS(0);
        }

        private List<int> F1_OrderCandidates(int day, int[] curAssign, int[] curWork, int[] curMW)
        {
            // JeÅ›li sÄ… RZ â€“ musimy wybraÄ‡ jednego z nich
            var RZ = new List<int>();
            for (int p = 0; p < _docs.Count; p++)
            {
                if (_pref[day, p] == PREF_RZ && F1_IsFeasible(day, p, curAssign, curWork, curMW))
                    RZ.Add(p);
            }
            if (RZ.Count > 0)
            {
                RZ.Sort((a, b) => TieBreakF1(day, a, b, curAssign, curWork));
                SolverDiagnostics.Log($"[F1] RZ wymuszone â€“ kandydaci: {string.Join(", ", RZ.Select(i => _docs[i].Symbol))}");
                return RZ;
            }

            var list = new List<int>(_docs.Count);
            for (int p = 0; p < _docs.Count; p++)
                if (_pref[day, p] != PREF_NONE && _pref[day, p] != PREF_OD && F1_IsFeasible(day, p, curAssign, curWork, curMW))
                    list.Add(p);

            // BC > CH > MG > MW, a przy remisie: preferuj takiego, ktÃ³ry nie zabije d+1 (krÃ³tki lookahead)
            list.Sort((a, b) =>
            {
                int pa = PrefRank(_pref[day, a]);
                int pb = PrefRank(_pref[day, b]);
                if (pa != pb) return pb.CompareTo(pa);

                bool ka = KeepsNextFeasible(day, a, curAssign, curWork, curMW);
                bool kb = KeepsNextFeasible(day, b, curAssign, curWork, curMW);
                int cmp = kb.CompareTo(ka);
                if (cmp != 0) return cmp;

                return TieBreakF1(day, a, b, curAssign, curWork);
            });

            return list;
        }

        private int TieBreakF1(int day, int a, int b, int[] curAssign, int[] curWork)
        {
            // mniejszy wskaÅºnik obciÄ…Å¼enia (proporcja do limitu)
            double ra = RatioAfter(curWork[a], _limitsByDoc[a]);
            double rb = RatioAfter(curWork[b], _limitsByDoc[b]);
            int cmp = ra.CompareTo(rb);
            if (cmp != 0) return cmp;

            // wiÄ™kszy dystans od istniejÄ…cych dyÅ¼urÃ³w (rÃ³wnomiernoÅ›Ä‡)
            int da = NearestAssignedDistance(day, a, curAssign);
            int db = NearestAssignedDistance(day, b, curAssign);
            cmp = db.CompareTo(da);
            if (cmp != 0) return cmp;

            return a.CompareTo(b);
        }

        private bool F1_IsFeasible(int day, int doc, int[] curAssign, int[] curWork, int[] curMW)
        {
            if (curWork[doc] >= _limitsByDoc[doc]) return false;

            byte av = _pref[day, doc];
            if (av == PREF_NONE || av == PREF_OD) return false;

            bool isBC = (av == PREF_BC);

            // dzieÅ„-po-dniu: BC moÅ¼e Å‚amaÄ‡
            if (!_bcBreaksAdjacent || !isBC)
            {
                if (day > 0 && curAssign[day - 1] == doc) return false;
                if (day + 1 < _days.Count && curAssign[day + 1] == doc) return false;
            }

            // inny dyÅ¼ur Â±1: BC moÅ¼e Å‚amaÄ‡
            if (!_bcBreaksAdjacent || !isBC)
            {
                if (day > 0 && _pref[day - 1, doc] == PREF_OD) return false;
                if (day + 1 < _days.Count && _pref[day + 1, doc] == PREF_OD) return false;
            }

            if (av == PREF_MW && (curMW[doc] >= _mwMax)) return false;

            return true;
        }

        private bool KeepsNextFeasible(int day, int doc, int[] curAssign, int[] curWork, int[] curMW)
        {
            int dNext = day + 1;
            if (dNext >= _days.Count) return true;

            // Testuj czy istnieje jakikolwiek kandydat na d+1 po hipotetycznym wyborze (day, doc)
            byte code = _pref[day, doc];
            curAssign[day] = doc;
            curWork[doc]++;
            if (code == PREF_MW) curMW[doc]++;

            bool ok = false;
            for (int q = 0; q < _docs.Count; q++)
            {
                if (F1_IsFeasible(dNext, q, curAssign, curWork, curMW)) { ok = true; break; }
            }

            if (code == PREF_MW) curMW[doc]--;
            curWork[doc]--;
            curAssign[day] = UNASSIGNED;
            return ok;
        }

        // ===================== F2: Maksymalizacja obsady =====================
        private void F2_MaximizeCoverageFrom(int startDay)
        {
            // Zainicjalizuj stan (na podstawie _assign â€“ po F1 moÅ¼e zawieraÄ‡ przydziaÅ‚y 0..start-1)
            _filled = 0;
            Array.Fill(_workPerDoc, 0);
            Array.Fill(_mwUsed, 0);
            for (int d = 0; d < _days.Count; d++)
            {
                if (_assign[d] >= 0)
                {
                    _workPerDoc[_assign[d]]++;
                    if (_pref[d, _assign[d]] == PREF_MW) _mwUsed[_assign[d]]++;
                    _filled++;
                }
                else if (_assign[d] == EMPTY)
                {
                    // nic
                }
            }

            // 1) WymuÅ› rezerwacje w caÅ‚ym koÅ„cu (Å›wiÄ™toÅ›Ä‡)
            for (int d = startDay; d < _days.Count; d++)
            {
                if (_assign[d] != UNASSIGNED) continue;
                var rz = Enumerable.Range(0, _docs.Count)
                                   .Where(p => _pref[d, p] == PREF_RZ && IsHardFeasibleGlobal(d, p))
                                   .ToList();
                if (rz.Count > 0)
                {
                    int sel = SelectByTieBreakF2(d, rz);
                    PlaceGlobal(d, sel);
                    SolverDiagnostics.Log($"[F2] RZ: {FormatDay(d)} â† {_docs[sel].Symbol}");
                }
            }

            // 2) PÄ™tle heurystyczne: najpierw dni z unikalnym CH/BC, potem ogÃ³lnie CH/BC, potem MG, potem MW
            //    â€“ kaÅ¼dÄ… kategoriÄ™ przechodzimy kilkoma przebiegami, aÅ¼ brak postÄ™pu.
            bool progress;
            do
            {
                progress = false;

                // Unikalny CH/BC
                progress |= AssignUniqueCHBC(startDay);

                // PozostaÅ‚e CH/BC
                progress |= AssignAnyCHBC(startDay);

                // MG
                progress |= AssignByPref(startDay, PREF_MG);

                // MW (pilnujÄ…c MW<=1)
                progress |= AssignByPref(startDay, PREF_MW);
            }
            while (progress);

            // Nie wymuszamy peÅ‚nej kompletnoÅ›ci: to backtracking F1 byÅ‚ najwaÅ¼niejszy
        }

        private bool AssignUniqueCHBC(int startDay)
        {
            bool any = false;
            for (int d = startDay; d < _days.Count; d++)
            {
                if (_assign[d] != UNASSIGNED) continue;
                var chbc = Enumerable.Range(0, _docs.Count)
                                     .Where(p => (_pref[d, p] == PREF_CH || _pref[d, p] == PREF_BC) && IsHardFeasibleGlobal(d, p))
                                     .ToList();
                if (chbc.Count == 1)
                {
                    int sel = chbc[0];
                    PlaceGlobal(d, sel);
                    SolverDiagnostics.Log($"[F2] Unique CH/BC: {FormatDay(d)} â† {_docs[sel].Symbol} [{PrefToString(_pref[d, sel])}]");
                    any = true;
                }
            }
            return any;
        }

        private bool AssignAnyCHBC(int startDay)
        {
            bool any = false;
            for (int d = startDay; d < _days.Count; d++)
            {
                if (_assign[d] != UNASSIGNED) continue;
                var chbc = Enumerable.Range(0, _docs.Count)
                                     .Where(p => (_pref[d, p] == PREF_CH || _pref[d, p] == PREF_BC) && IsHardFeasibleGlobal(d, p))
                                     .ToList();
                if (chbc.Count > 0)
                {
                    int sel = SelectByTieBreakF2(d, chbc);
                    PlaceGlobal(d, sel);
                    SolverDiagnostics.Log($"[F2] CH/BC: {FormatDay(d)} â† {_docs[sel].Symbol} [{PrefToString(_pref[d, sel])}]");
                    any = true;
                }
            }
            return any;
        }

        private bool AssignByPref(int startDay, byte prefCode)
        {
            bool any = false;
            for (int d = startDay; d < _days.Count; d++)
            {
                if (_assign[d] != UNASSIGNED) continue;
                var list = Enumerable.Range(0, _docs.Count)
                                     .Where(p => _pref[d, p] == prefCode && IsHardFeasibleGlobal(d, p))
                                     .ToList();
                if (list.Count > 0)
                {
                    int sel = SelectByTieBreakF2(d, list);
                    PlaceGlobal(d, sel);
                    SolverDiagnostics.Log($"[F2] {PrefToString(prefCode)}: {FormatDay(d)} â† {_docs[sel].Symbol}");
                    any = true;
                }
            }
            return any;
        }

        private int SelectByTieBreakF2(int day, List<int> candidates)
        {
            candidates.Sort((a, b) =>
            {
                // Priorytety uÅ¼ytkownika jako sekwencja tie-breakerÃ³w (poza tym, Å¼e cel gÅ‚Ã³wny F2 to maks. obsada)
                foreach (var pr in _priorities.Skip(1)) // #2, #3, #4
                {
                    int cmp = 0;
                    switch (pr)
                    {
                        case SolverPriority.SprawiedliwoscObciazenia:
                            {
                                double ra = RatioAfter(_workPerDoc[a], _limitsByDoc[a]);
                                double rb = RatioAfter(_workPerDoc[b], _limitsByDoc[b]);
                                cmp = ra.CompareTo(rb);
                                if (cmp != 0) return cmp;
                                break;
                            }
                        case SolverPriority.RownomiernoscRozlozenia:
                            {
                                int da = NearestAssignedDistanceGlobal(day, a);
                                int db = NearestAssignedDistanceGlobal(day, b);
                                cmp = db.CompareTo(da);
                                if (cmp != 0) return cmp;
                                break;
                            }
                        case SolverPriority.CiagloscPoczatkowa:
                            // W F2 nie rozbijamy juÅ¼ prefiksu â€“ ten priorytet ma mniejsze znaczenie; pomijamy.
                            break;
                        case SolverPriority.LacznaLiczbaObsadzonychDni:
                            // To juÅ¼ jest cel F2, nie stanowi tie-breakera.
                            break;
                    }
                }

                // Ostateczny tie-break: mniej przydzielony wzglÄ™dem limitu, potem indeks
                int wcmp = _workPerDoc[a].CompareTo(_workPerDoc[b]);
                if (wcmp != 0) return wcmp;
                int remA = _limitsByDoc[a] - _workPerDoc[a];
                int remB = _limitsByDoc[b] - _workPerDoc[b];
                int rc = remB.CompareTo(remA);
                if (rc != 0) return rc;
                return a.CompareTo(b);
            });
            return candidates[0];
        }

        private bool IsHardFeasibleGlobal(int day, int doc)
        {
            if (_workPerDoc[doc] >= _limitsByDoc[doc]) return false;

            byte av = _pref[day, doc];
            if (av == PREF_NONE || av == PREF_OD) return false;

            bool isBC = (av == PREF_BC);

            // dzieÅ„-po-dniu: BC moÅ¼e Å‚amaÄ‡
            if (!_bcBreaksAdjacent || !isBC)
            {
                if (day > 0 && _assign[day - 1] == doc) return false;
                if (day + 1 < _days.Count && _assign[day + 1] == doc) return false;
            }

            // inny dyÅ¼ur Â±1: BC moÅ¼e Å‚amaÄ‡
            if (!_bcBreaksAdjacent || !isBC)
            {
                if (day > 0 && _pref[day - 1, doc] == PREF_OD) return false;
                if (day + 1 < _days.Count && _pref[day + 1, doc] == PREF_OD) return false;
            }

            if (av == PREF_MW && (_mwUsed[doc] >= _mwMax)) return false;

            return true;
        }

        private void PlaceGlobal(int day, int doc)
        {
            byte code = _pref[day, doc];
            _assign[day] = doc;
            _workPerDoc[doc]++;
            if (code == PREF_MW) _mwUsed[doc]++;
            _filled++;
        }

        // ===================== Scoring / wynik =====================
        private RozwiazanyGrafik SnapshotToSolution()
        {
            var sol = new RozwiazanyGrafik { Przypisania = new Dictionary<DateTime, Lekarz?>() };
            for (int d = 0; d < _days.Count; d++)
                sol.Przypisania[_days[d]] = _assign[d] >= 0 ? _docs[_assign[d]] : null;
            return sol;
        }

        private long[] EvaluateSolution(RozwiazanyGrafik sol)
        {
            long sObs = 0, sCont = 0, sFair = 0, sEven = 0;

            var perDoc = new int[_docs.Count];
            for (int d = 0; d < _days.Count; d++)
            {
                if (sol.Przypisania.TryGetValue(_days[d], out var l) && l is not null)
                {
                    sObs++;
                    if (_docIdxBySymbol.TryGetValue(l.Symbol, out var idx))
                        perDoc[idx]++;
                }
            }
            for (int d = 0; d < _days.Count; d++)
            {
                if (!sol.Przypisania.TryGetValue(_days[d], out var l) || l is null) break;
                sCont++;
            }

            long sumLimits = 0;
            var lims = new long[_docs.Count];
            for (int i = 0; i < _docs.Count; i++)
            {
                long L = Math.Max(0, _limitsByDoc[i]);
                lims[i] = L;
                sumLimits += L;
            }
            if (sObs > 0 && sumLimits > 0)
            {
                double sumAbs = 0.0;
                for (int i = 0; i < _docs.Count; i++)
                {
                    double expected = sObs * (lims[i] / (double)sumLimits);
                    sumAbs += Math.Abs(perDoc[i] - expected);
                }
                sFair = -(long)Math.Round(sumAbs * 1000.0);
            }

            // prosty karny miernik rÃ³wnomiernoÅ›ci (sÄ…siedztwo tego samego lekarza)
            int penalty = 0;
            int lastDoc = -1;
            for (int d = 0; d < _days.Count; d++)
            {
                int cur = -1;
                if (sol.Przypisania.TryGetValue(_days[d], out var l) && l is not null &&
                    _docIdxBySymbol.TryGetValue(l.Symbol, out var idx)) cur = idx;
                if (cur >= 0 && lastDoc == cur) penalty++;
                if (cur >= 0) lastDoc = cur;
                else lastDoc = -1;
            }
            sEven = -penalty;

            var map = new Dictionary<SolverPriority, long>
            {
                { SolverPriority.LacznaLiczbaObsadzonychDni, sObs },
                { SolverPriority.CiagloscPoczatkowa, sCont },
                { SolverPriority.SprawiedliwoscObciazenia, sFair },
                { SolverPriority.RownomiernoscRozlozenia, sEven }
            };
            var vec = new long[_priorities.Count];
            for (int i = 0; i < _priorities.Count; i++)
            {
                var pr = _priorities[i];
                vec[i] = map.TryGetValue(pr, out var v) ? v : 0;
            }
            return vec;
        }

        private static string FormatScore(long[] v) => $"[{string.Join(", ", v)}]";

        // ===================== Utils =====================
        private double RatioAfter(int work, int limit)
        {
            double lim = Math.Max(1, limit);
            return (work + 1) / lim;
        }

        private int NearestAssignedDistance(int day, int doc, int[] curAssign)
        {
            int best = int.MaxValue;
            for (int d = day - 1; d >= 0; d--)
                if (curAssign[d] == doc) { best = Math.Min(best, day - d); break; }
            for (int d = day + 1; d < _days.Count; d++)
                if (curAssign[d] == doc) { best = Math.Min(best, d - day); break; }
            return best == int.MaxValue ? 9999 : best;
        }

        private int NearestAssignedDistanceGlobal(int day, int doc)
        {
            int best = int.MaxValue;
            for (int d = day - 1; d >= 0; d--)
                if (_assign[d] == doc) { best = Math.Min(best, day - d); break; }
            for (int d = day + 1; d < _days.Count; d++)
                if (_assign[d] == doc) { best = Math.Min(best, d - day); break; }
            return best == int.MaxValue ? 9999 : best;
        }

        private static int PrefRank(byte code) => code switch
        {
            PREF_RZ => 5,
            PREF_BC => 4,
            PREF_CH => 3,
            PREF_MG => 2,
            PREF_MW => 1,
            _ => 0
        };

        private string PrefToString(byte code) => code switch
        {
            PREF_BC => "BC",
            PREF_CH => "CH",
            PREF_MG => "MG",
            PREF_MW => "MW",
            PREF_RZ => "RZ",
            PREF_OD => "OD",
            _ => "--"
        };

        private void ApplyPrefixSnapshot(int[] snap, int len)
        {
            for (int d = 0; d < _days.Count; d++) _assign[d] = UNASSIGNED;
            Array.Fill(_workPerDoc, 0);
            Array.Fill(_mwUsed, 0);
            _filled = 0;

            for (int d = 0; d < len; d++)
            {
                int doc = snap[d];
                if (doc >= 0)
                {
                    _assign[d] = doc;
                    _workPerDoc[doc]++;
                    if (_pref[d, doc] == PREF_MW) _mwUsed[doc]++;
                    _filled++;
                }
                else if (doc == EMPTY)
                {
                    _assign[d] = EMPTY;
                }
            }
        }

        private string FormatDay(int dayIndex) => $"{_days[dayIndex]:yyyy-MM-dd}";

        // ===================== Logging helpers =====================
        private void LogLimits()
        {
            SolverDiagnostics.Log("--- Limity lekarzy ---");
            for (int i = 0; i < _docs.Count; i++)
                SolverDiagnostics.Log($"{_docs[i].Symbol}: limit={_limitsByDoc[i]}");
            SolverDiagnostics.Log("--- /Limity lekarzy ---");
        }

        private void LogLegendAndAvailability()
        {
            SolverDiagnostics.Log("Legenda: BC=BardzoChce, CH=Chce, MG=Moge, MW=MogeWarunkowo, RZ=Rezerwacja, OD=DyÅ¼ur(inny), --=brak");
            SolverDiagnostics.Log("--- Deklaracje (dzieÅ„ â†’ lekarz:deklaracja) ---");
            for (int d = 0; d < _days.Count; d++)
            {
                var date = _days[d];
                var parts = new List<string>(_docs.Count);
                for (int i = 0; i < _docs.Count; i++)
                    parts.Add($"{_docs[i].Symbol}:{PrefToString(_pref[d, i])}");
                SolverDiagnostics.Log($"{date:yyyy-MM-dd} | {string.Join(", ", parts)}");
            }
            SolverDiagnostics.Log("--- /Deklaracje (dzieÅ„ â†’ lekarz:deklaracja) ---");
        }

        private void LogCandidates(int day, List<int> cand, int[] curAssign, int[] curWork)
        {
            var prefix = day; // bo w F1 ukÅ‚adamy 0..day-1
            SolverDiagnostics.Log($"--- [F1] Kandydaci dnia {FormatDay(day)} ---");
            SolverDiagnostics.Log($"DzieÅ„ {FormatDay(day)} (prefiks={prefix}) â€“ kandydaci:");
            foreach (var p in cand)
                SolverDiagnostics.Log($"  âœ“ {_docs[p].Symbol} [{PrefToString(_pref[day, p])}]  (pracuje={curWork[p]}, limit={_limitsByDoc[p]})");
            SolverDiagnostics.Log($"--- /[F1] Kandydaci dnia {FormatDay(day)} ---");
        }
    }
}
----- END FILE: GrafikWPF\BacktrackingSolver.cs -----

----- BEGIN FILE: GrafikWPF\BenchmarkDataFactory.cs -----
namespace GrafikWPF
{
    public static class BenchmarkDataFactory
    {
        private const int RandomSeed = 12345; // Stałe ziarno dla 100% powtarzalności testów

        public static GrafikWejsciowy CreateTestCase(int doctorCount)
        {
            var random = new Random(RandomSeed + doctorCount); // Inne ziarno dla każdego scenariusza
            var lekarze = new List<Lekarz>();
            for (int i = 0; i < doctorCount; i++)
            {
                lekarze.Add(new Lekarz($"L{i + 1:D2}", $"Imie{i + 1}", $"Nazwisko{i + 1}", true));
            }

            var limity = lekarze.ToDictionary(
                l => l.Symbol,
                l => random.Next(1, doctorCount <= 10 ? 6 : 11)
            );

            var dostepnosc = new Dictionary<DateTime, Dictionary<string, TypDostepnosci>>();
            var rok = DateTime.Now.Year;
            var miesiac = 1;
            int dniWMiesiacu = DateTime.DaysInMonth(rok, miesiac);
            var wszystkieDni = Enumerable.Range(1, dniWMiesiacu).Select(d => new DateTime(rok, miesiac, d)).ToList();

            foreach (var dzien in wszystkieDni)
            {
                dostepnosc[dzien] = new Dictionary<string, TypDostepnosci>();
            }

            foreach (var lekarz in lekarze)
            {
                var dostepneDni = new HashSet<DateTime>(wszystkieDni);

                // Krok 1: Urlopy w blokach
                if (random.NextDouble() < 0.3) // 30% szans na urlop
                {
                    var dlugoscUrlopu = new[] { 4, 7, 14 }[random.Next(3)];
                    if (dniWMiesiacu > dlugoscUrlopu)
                    {
                        var startUrlopu = random.Next(1, dniWMiesiacu - dlugoscUrlopu);
                        for (int i = 0; i < dlugoscUrlopu; i++)
                        {
                            var dzienUrlopu = new DateTime(rok, miesiac, startUrlopu + i);
                            dostepnosc[dzienUrlopu][lekarz.Symbol] = TypDostepnosci.Urlop;
                            dostepneDni.Remove(dzienUrlopu);
                        }
                    }
                }

                // Krok 2: Określenie "chętnych dni"
                var iloscCheci = random.Next(2, 21);
                var chetneDni = dostepneDni.OrderBy(d => random.Next()).Take(iloscCheci).ToList();

                // Krok 3: Przypisanie pozytywnych deklaracji
                foreach (var dzien in chetneDni)
                {
                    double roll = random.NextDouble();
                    if (roll < 0.05) dostepnosc[dzien][lekarz.Symbol] = TypDostepnosci.BardzoChce;
                    else if (roll < 0.25) dostepnosc[dzien][lekarz.Symbol] = TypDostepnosci.Chce;
                    else if (roll < 0.95) dostepnosc[dzien][lekarz.Symbol] = TypDostepnosci.Moge;
                    else dostepnosc[dzien][lekarz.Symbol] = TypDostepnosci.MogeWarunkowo;
                    dostepneDni.Remove(dzien);
                }

                // Krok 4: Uzupełnienie deklaracjami negatywnymi
                foreach (var dzien in dostepneDni) // Pozostałe dni
                {
                    if (random.NextDouble() < 0.05) // 5% szans na "Inny Dyżur"
                    {
                        dostepnosc[dzien][lekarz.Symbol] = TypDostepnosci.DyzurInny;
                    }
                    else
                    {
                        dostepnosc[dzien][lekarz.Symbol] = TypDostepnosci.Niedostepny;
                    }
                }
            }

            return new GrafikWejsciowy
            {
                Lekarze = lekarze,
                LimityDyzurow = limity,
                Dostepnosc = dostepnosc
            };
        }
    }
}
----- END FILE: GrafikWPF\BenchmarkDataFactory.cs -----

----- BEGIN FILE: GrafikWPF\BenchmarkResult.cs -----
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace GrafikWPF
{
    public class BenchmarkResult : INotifyPropertyChanged
    {
        public string EngineName { get; set; } = "";
        public string TestCaseName { get; set; } = "";

        private double _progress;
        public double Progress
        {
            get => _progress;
            set { _progress = value; OnPropertyChanged(); }
        }

        private string _executionTime = "-";
        public string ExecutionTime
        {
            get => _executionTime;
            set { _executionTime = value; OnPropertyChanged(); }
        }

        private string _status = "Oczekuje";
        public string Status
        {
            get => _status;
            set { _status = value; OnPropertyChanged(); }
        }

        private string _timeRemaining = "";
        public string TimeRemaining
        {
            get => _timeRemaining;
            set { _timeRemaining = value; OnPropertyChanged(); }
        }

        private string _qualityScore = "-";
        public string QualityScore
        {
            get => _qualityScore;
            set { _qualityScore = value; OnPropertyChanged(); }
        }

        // NOWA WŁAŚCIWOŚĆ
        private string _qualityScoreDetails = "";
        public string QualityScoreDetails
        {
            get => _qualityScoreDetails;
            set { _qualityScoreDetails = value; OnPropertyChanged(); }
        }

        public SolverType SolverType { get; set; }
        public int DoctorCount { get; set; }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? name = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}

----- END FILE: GrafikWPF\BenchmarkResult.cs -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_large_continuity_coverage_fairness_spacing.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L16",
      "Imie": "Imie16",
      "Nazwisko": "Nazwisko16",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L15",
      "Imie": "Imie15",
      "Nazwisko": "Nazwisko15",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L17",
      "Imie": "Imie17",
      "Nazwisko": "Nazwisko17",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L18",
      "Imie": "Imie18",
      "Nazwisko": "Nazwisko18",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L19",
      "Imie": "Imie19",
      "Nazwisko": "Nazwisko19",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L20",
      "Imie": "Imie20",
      "Nazwisko": "Nazwisko20",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 11.60437085336828,
  "WskaznikRozlozeniaDyzurow": 0.0,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 2,
    "L03": 2,
    "L04": 2,
    "L05": 2,
    "L06": 1,
    "L07": 2,
    "L08": 2,
    "L09": 1,
    "L10": 2,
    "L11": 2,
    "L12": 1,
    "L13": 2,
    "L14": 2,
    "L15": 1,
    "L16": 1,
    "L17": 1,
    "L18": 1,
    "L19": 1,
    "L20": 1
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_large_continuity_coverage_fairness_spacing.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_large_coverage_fairness_spacing_continuity.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L16",
      "Imie": "Imie16",
      "Nazwisko": "Nazwisko16",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L15",
      "Imie": "Imie15",
      "Nazwisko": "Nazwisko15",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L17",
      "Imie": "Imie17",
      "Nazwisko": "Nazwisko17",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L18",
      "Imie": "Imie18",
      "Nazwisko": "Nazwisko18",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L19",
      "Imie": "Imie19",
      "Nazwisko": "Nazwisko19",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L20",
      "Imie": "Imie20",
      "Nazwisko": "Nazwisko20",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 11.60437085336828,
  "WskaznikRozlozeniaDyzurow": 0.0,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 2,
    "L03": 2,
    "L04": 2,
    "L05": 2,
    "L06": 1,
    "L07": 2,
    "L08": 2,
    "L09": 1,
    "L10": 2,
    "L11": 2,
    "L12": 1,
    "L13": 2,
    "L14": 2,
    "L15": 1,
    "L16": 1,
    "L17": 1,
    "L18": 1,
    "L19": 1,
    "L20": 1
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_large_coverage_fairness_spacing_continuity.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_large_fairness_spacing_continuity_coverage.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L16",
      "Imie": "Imie16",
      "Nazwisko": "Nazwisko16",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L15",
      "Imie": "Imie15",
      "Nazwisko": "Nazwisko15",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L17",
      "Imie": "Imie17",
      "Nazwisko": "Nazwisko17",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L18",
      "Imie": "Imie18",
      "Nazwisko": "Nazwisko18",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L19",
      "Imie": "Imie19",
      "Nazwisko": "Nazwisko19",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L20",
      "Imie": "Imie20",
      "Nazwisko": "Nazwisko20",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 11.60437085336828,
  "WskaznikRozlozeniaDyzurow": 0.0,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 2,
    "L03": 2,
    "L04": 2,
    "L05": 2,
    "L06": 1,
    "L07": 2,
    "L08": 2,
    "L09": 1,
    "L10": 2,
    "L11": 2,
    "L12": 1,
    "L13": 2,
    "L14": 2,
    "L15": 1,
    "L16": 1,
    "L17": 1,
    "L18": 1,
    "L19": 1,
    "L20": 1
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_large_fairness_spacing_continuity_coverage.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_large_spacing_continuity_coverage_fairness.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L16",
      "Imie": "Imie16",
      "Nazwisko": "Nazwisko16",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L15",
      "Imie": "Imie15",
      "Nazwisko": "Nazwisko15",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L17",
      "Imie": "Imie17",
      "Nazwisko": "Nazwisko17",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L18",
      "Imie": "Imie18",
      "Nazwisko": "Nazwisko18",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L19",
      "Imie": "Imie19",
      "Nazwisko": "Nazwisko19",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L20",
      "Imie": "Imie20",
      "Nazwisko": "Nazwisko20",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L13",
      "Imie": "Imie13",
      "Nazwisko": "Nazwisko13",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L14",
      "Imie": "Imie14",
      "Nazwisko": "Nazwisko14",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 11.60437085336828,
  "WskaznikRozlozeniaDyzurow": 0.0,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 2,
    "L03": 2,
    "L04": 2,
    "L05": 2,
    "L06": 1,
    "L07": 2,
    "L08": 2,
    "L09": 1,
    "L10": 2,
    "L11": 2,
    "L12": 1,
    "L13": 2,
    "L14": 2,
    "L15": 1,
    "L16": 1,
    "L17": 1,
    "L18": 1,
    "L19": 1,
    "L20": 1
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_large_spacing_continuity_coverage_fairness.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_medium_continuity_coverage_fairness_spacing.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 19.21290718420418,
  "WskaznikRozlozeniaDyzurow": 2.890383996412151,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 3,
    "L03": 3,
    "L04": 4,
    "L05": 3,
    "L06": 2,
    "L07": 2,
    "L08": 2,
    "L09": 4,
    "L10": 1,
    "L11": 2,
    "L12": 3
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_medium_continuity_coverage_fairness_spacing.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_medium_coverage_fairness_spacing_continuity.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 19.21290718420418,
  "WskaznikRozlozeniaDyzurow": 2.890383996412151,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 3,
    "L03": 3,
    "L04": 4,
    "L05": 3,
    "L06": 2,
    "L07": 2,
    "L08": 2,
    "L09": 4,
    "L10": 1,
    "L11": 2,
    "L12": 3
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_medium_coverage_fairness_spacing_continuity.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_medium_fairness_spacing_continuity_coverage.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 19.21290718420418,
  "WskaznikRozlozeniaDyzurow": 2.890383996412151,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 3,
    "L03": 3,
    "L04": 4,
    "L05": 3,
    "L06": 2,
    "L07": 2,
    "L08": 2,
    "L09": 4,
    "L10": 1,
    "L11": 2,
    "L12": 3
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_medium_fairness_spacing_continuity_coverage.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_medium_spacing_continuity_coverage_fairness.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L10",
      "Imie": "Imie10",
      "Nazwisko": "Nazwisko10",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L08",
      "Imie": "Imie8",
      "Nazwisko": "Nazwisko8",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": {
      "Symbol": "L11",
      "Imie": "Imie11",
      "Nazwisko": "Nazwisko11",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-27T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-28T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L12",
      "Imie": "Imie12",
      "Nazwisko": "Nazwisko12",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L09",
      "Imie": "Imie9",
      "Nazwisko": "Nazwisko9",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 31,
  "WskaznikRownomiernosci": 19.21290718420418,
  "WskaznikRozlozeniaDyzurow": 2.890383996412151,
  "FinalneOblozenieLekarzy": {
    "L01": 2,
    "L02": 3,
    "L03": 3,
    "L04": 4,
    "L05": 3,
    "L06": 2,
    "L07": 2,
    "L08": 2,
    "L09": 4,
    "L10": 1,
    "L11": 2,
    "L12": 3
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_medium_spacing_continuity_coverage_fairness.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_small_continuity_coverage_fairness_spacing.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-15T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": null,
    "2025-01-17T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": null,
    "2025-01-24T00:00:00": null,
    "2025-01-25T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": null,
    "2025-01-27T00:00:00": null,
    "2025-01-28T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": null,
    "2025-01-31T00:00:00": null
  },
  "DlugoscCiaguPoczatkowego": 15,
  "WskaznikRownomiernosci": 6.998542122158428,
  "WskaznikRozlozeniaDyzurow": 2.5560543153922333,
  "FinalneOblozenieLekarzy": {
    "L01": 5,
    "L02": 4,
    "L03": 2,
    "L04": 1,
    "L05": 5,
    "L06": 3,
    "L07": 4
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_small_continuity_coverage_fairness_spacing.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_small_coverage_fairness_spacing_continuity.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-06T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-10T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-12T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": null,
    "2025-01-15T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-16T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-23T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": null,
    "2025-01-25T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": null,
    "2025-01-27T00:00:00": null,
    "2025-01-28T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": null,
    "2025-01-30T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": null
  },
  "DlugoscCiaguPoczatkowego": 13,
  "WskaznikRownomiernosci": 31.81223114942691,
  "WskaznikRozlozeniaDyzurow": 3.73193498357245,
  "FinalneOblozenieLekarzy": {
    "L01": 5,
    "L02": 4,
    "L03": 2,
    "L04": 1,
    "L05": 5,
    "L06": 3,
    "L07": 4
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_small_coverage_fairness_spacing_continuity.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_small_fairness_spacing_continuity_coverage.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": null,
    "2025-01-06T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": null,
    "2025-01-10T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": null,
    "2025-01-12T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": null,
    "2025-01-15T00:00:00": null,
    "2025-01-16T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": null,
    "2025-01-23T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": null,
    "2025-01-27T00:00:00": null,
    "2025-01-28T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 4,
  "WskaznikRownomiernosci": 21.428571428571427,
  "WskaznikRozlozeniaDyzurow": 4.19325798952863,
  "FinalneOblozenieLekarzy": {
    "L01": 5,
    "L02": 4,
    "L03": 2,
    "L04": 1,
    "L05": 4,
    "L06": 3,
    "L07": 4
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_small_fairness_spacing_continuity_coverage.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkStandards\optimal_small_spacing_continuity_coverage_fairness.json -----
{
  "Przypisania": {
    "2025-01-01T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-02T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-03T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-04T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-05T00:00:00": null,
    "2025-01-06T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-07T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-08T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-09T00:00:00": null,
    "2025-01-10T00:00:00": {
      "Symbol": "L04",
      "Imie": "Imie4",
      "Nazwisko": "Nazwisko4",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-11T00:00:00": null,
    "2025-01-12T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-13T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-14T00:00:00": null,
    "2025-01-15T00:00:00": null,
    "2025-01-16T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-17T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-18T00:00:00": {
      "Symbol": "L03",
      "Imie": "Imie3",
      "Nazwisko": "Nazwisko3",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-19T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-20T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-21T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-22T00:00:00": null,
    "2025-01-23T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-24T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-25T00:00:00": {
      "Symbol": "L02",
      "Imie": "Imie2",
      "Nazwisko": "Nazwisko2",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-26T00:00:00": null,
    "2025-01-27T00:00:00": null,
    "2025-01-28T00:00:00": {
      "Symbol": "L01",
      "Imie": "Imie1",
      "Nazwisko": "Nazwisko1",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-29T00:00:00": {
      "Symbol": "L05",
      "Imie": "Imie5",
      "Nazwisko": "Nazwisko5",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-30T00:00:00": {
      "Symbol": "L06",
      "Imie": "Imie6",
      "Nazwisko": "Nazwisko6",
      "IsAktywny": true,
      "IsUkryty": false
    },
    "2025-01-31T00:00:00": {
      "Symbol": "L07",
      "Imie": "Imie7",
      "Nazwisko": "Nazwisko7",
      "IsAktywny": true,
      "IsUkryty": false
    }
  },
  "DlugoscCiaguPoczatkowego": 4,
  "WskaznikRownomiernosci": 21.428571428571427,
  "WskaznikRozlozeniaDyzurow": 4.19325798952863,
  "FinalneOblozenieLekarzy": {
    "L01": 5,
    "L02": 4,
    "L03": 2,
    "L04": 1,
    "L05": 4,
    "L06": 3,
    "L07": 4
  }
}
----- END FILE: GrafikWPF\BenchmarkStandards\optimal_small_spacing_continuity_coverage_fairness.json -----

----- BEGIN FILE: GrafikWPF\BenchmarkWindow.xaml -----
<Window x:Class="GrafikWPF.BenchmarkWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Porównanie czasu wykonania i zgodności generowanych grafików testowych z grafikami wzorcowymi dla różnych silników i scenariuszy"
        Height="640" Width="1150"
        MinWidth="980" MinHeight="520"
        WindowStartupLocation="CenterOwner"
        Background="LightGray"
        UseLayoutRounding="True"
        SnapsToDevicePixels="True">

    <Window.Resources>
        <SolidColorBrush x:Key="HdrBg" Color="#4F4F4F"/>
        <SolidColorBrush x:Key="HdrFg" Color="#FFFFFF"/>
        <SolidColorBrush x:Key="GridLine" Color="#B0B0B0"/>
        <SolidColorBrush x:Key="Row0" Color="#FFFFFFFF"/>
        <SolidColorBrush x:Key="Row1" Color="#F2F2F2"/>
        <Style x:Key="HeaderTitle" TargetType="TextBlock">
            <Setter Property="FontSize" Value="20"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="HorizontalAlignment" Value="Center"/>
            <Setter Property="Margin" Value="0,0,0,6"/>
        </Style>
        <Style x:Key="CellBorder" TargetType="Border">
            <Setter Property="BorderBrush" Value="{StaticResource GridLine}"/>
            <Setter Property="BorderThickness" Value="0,0,1,1"/>
            <Setter Property="Padding" Value="6,4"/>
        </Style>
        <Style x:Key="CellTextLeft" TargetType="TextBlock">
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="TextTrimming" Value="CharacterEllipsis"/>
        </Style>
        <Style x:Key="CellTextCenter" TargetType="TextBlock" BasedOn="{StaticResource CellTextLeft}">
            <Setter Property="TextAlignment" Value="Center"/>
        </Style>
    </Window.Resources>

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Benchmark wydajności i jakości silników" Style="{StaticResource HeaderTitle}"/>
        <TextBlock Grid.Row="1" Text="Porównanie czasu wykonania i jakości wyników dla różnych silników i scenariuszy." TextWrapping="Wrap" Margin="0,0,0,10" HorizontalAlignment="Center" />
        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,0,0,15">
            <TextBlock Text="Profil optymalizacji:" FontWeight="Bold" VerticalAlignment="Center" Margin="0,0,10,0"/>
            <ComboBox x:Name="PriorityProfileComboBox" Width="340" ItemsSource="{Binding PriorityProfiles}" SelectedValue="{Binding SelectedPriorityProfile}" DisplayMemberPath="Name"/>
        </StackPanel>

        <Grid Grid.Row="3">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
            </Grid.RowDefinitions>

            <Border Grid.Row="0" BorderBrush="{StaticResource GridLine}" BorderThickness="1,1,1,0">
                <Grid Background="{StaticResource HdrBg}" SnapsToDevicePixels="True">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="17"/>
                    </Grid.ColumnDefinitions>
                    <Grid Grid.Column="0" Background="{StaticResource HdrBg}" MinHeight="36">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="1.6*"/>
                            <ColumnDefinition Width="1.6*"/>
                            <ColumnDefinition Width="3.0*"/>
                            <ColumnDefinition Width="1.6*"/>
                            <ColumnDefinition Width="1.3*"/>
                            <ColumnDefinition Width="1.8*"/>
                        </Grid.ColumnDefinitions>

                        <Border Grid.Column="0" BorderBrush="{StaticResource GridLine}" BorderThickness="0,0,1,1">
                            <TextBlock Text="Silnik" Foreground="{StaticResource HdrFg}" FontWeight="Bold" VerticalAlignment="Center" Margin="8,0"/>
                        </Border>
                        <Border Grid.Column="1" BorderBrush="{StaticResource GridLine}" BorderThickness="0,0,1,1">
                            <TextBlock Text="Scenariusz" Foreground="{StaticResource HdrFg}" FontWeight="Bold" VerticalAlignment="Center" TextAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="2" BorderBrush="{StaticResource GridLine}" BorderThickness="0,0,1,1">
                            <TextBlock Text="Postęp" Foreground="{StaticResource HdrFg}" FontWeight="Bold" VerticalAlignment="Center" TextAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="3" BorderBrush="{StaticResource GridLine}" BorderThickness="0,0,1,1">
                            <TextBlock Text="Status" Foreground="{StaticResource HdrFg}" FontWeight="Bold" VerticalAlignment="Center" TextAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="4" BorderBrush="{StaticResource GridLine}" BorderThickness="0,0,1,1">
                            <TextBlock Text="Czas generowania grafiku (ms)" TextWrapping="Wrap" Foreground="{StaticResource HdrFg}" FontWeight="Bold" VerticalAlignment="Center" TextAlignment="Center" Margin="4,0" LineHeight="14"/>
                        </Border>
                        <Border Grid.Column="5" BorderBrush="{StaticResource GridLine}" BorderThickness="0,0,0,1">
                            <TextBlock Text="Zgodność z grafikiem wzorcowym (%)" TextWrapping="Wrap" Foreground="{StaticResource HdrFg}" FontWeight="Bold" VerticalAlignment="Center" TextAlignment="Center" Margin="4,0" LineHeight="14"/>
                        </Border>
                    </Grid>
                    <Border Grid.Column="1" Background="{StaticResource HdrBg}"/>
                </Grid>
            </Border>

            <Border Grid.Row="1" BorderBrush="{StaticResource GridLine}" BorderThickness="1,0,1,1" Background="White">
                <ScrollViewer x:Name="RowsScroll" VerticalScrollBarVisibility="Auto" HorizontalScrollBarVisibility="Disabled" CanContentScroll="True">
                    <ItemsControl x:Name="BenchmarkItemsControl" ItemsSource="{Binding Results}" AlternationCount="2">
                        <ItemsControl.ItemsPanel>
                            <ItemsPanelTemplate>
                                <StackPanel/>
                            </ItemsPanelTemplate>
                        </ItemsControl.ItemsPanel>
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Border MinHeight="44">
                                    <Border.Style>
                                        <Style TargetType="Border">
                                            <Setter Property="Background" Value="{StaticResource Row0}"/>
                                            <Style.Triggers>
                                                <DataTrigger Value="1">
                                                    <DataTrigger.Binding>
                                                        <Binding RelativeSource="{RelativeSource AncestorType=ContentPresenter}" Path="(ItemsControl.AlternationIndex)"/>
                                                    </DataTrigger.Binding>
                                                    <Setter Property="Background" Value="{StaticResource Row1}"/>
                                                </DataTrigger>
                                            </Style.Triggers>
                                        </Style>
                                    </Border.Style>
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="1.6*"/>
                                            <ColumnDefinition Width="1.6*"/>
                                            <ColumnDefinition Width="3.0*"/>
                                            <ColumnDefinition Width="1.6*"/>
                                            <ColumnDefinition Width="1.3*"/>
                                            <ColumnDefinition Width="1.8*"/>
                                        </Grid.ColumnDefinitions>

                                        <Border Grid.Column="0" Style="{StaticResource CellBorder}">
                                            <TextBlock Text="{Binding EngineName}" Style="{StaticResource CellTextLeft}"/>
                                        </Border>
                                        <Border Grid.Column="1" Style="{StaticResource CellBorder}">
                                            <TextBlock Text="{Binding TestCaseName}" Style="{StaticResource CellTextCenter}"/>
                                        </Border>
                                        <Border Grid.Column="2" Style="{StaticResource CellBorder}">
                                            <Grid>
                                                <ProgressBar Minimum="0" Maximum="100" Height="18" HorizontalAlignment="Stretch" Margin="10,0" Value="{Binding Progress}"/>
                                            </Grid>
                                        </Border>
                                        <Border Grid.Column="3" Style="{StaticResource CellBorder}">
                                            <StackPanel VerticalAlignment="Center">
                                                <TextBlock Text="{Binding Status}" Style="{StaticResource CellTextCenter}"/>
                                                <TextBlock Margin="0,2,0,0" FontSize="11" Opacity="0.8" TextAlignment="Center">
                                                    <TextBlock.Style>
                                                        <Style TargetType="TextBlock">
                                                            <Setter Property="Text" Value="{Binding TimeRemaining}"/>
                                                            <Setter Property="Visibility" Value="Visible"/>
                                                            <Style.Triggers>
                                                                <DataTrigger Binding="{Binding TimeRemaining}" Value="">
                                                                    <Setter Property="Visibility" Value="Collapsed"/>
                                                                </DataTrigger>
                                                            </Style.Triggers>
                                                        </Style>
                                                    </TextBlock.Style>
                                                </TextBlock>
                                            </StackPanel>
                                        </Border>
                                        <Border Grid.Column="4" Style="{StaticResource CellBorder}">
                                            <TextBlock Text="{Binding ExecutionTime}" Style="{StaticResource CellTextCenter}"/>
                                        </Border>
                                        <Border Grid.Column="5" Style="{StaticResource CellBorder}">
                                            <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                                                <TextBlock Text="{Binding QualityScore}" Style="{StaticResource CellTextCenter}" FontWeight="Bold"/>
                                                <TextBlock Text="{Binding QualityScoreDetails}" FontSize="11" Opacity="0.8" HorizontalAlignment="Center"/>
                                            </StackPanel>
                                        </Border>
                                    </Grid>
                                </Border>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </ScrollViewer>
            </Border>
        </Grid>

        <StackPanel Grid.Row="4" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,12,0,0">
            <Button x:Name="ExportButton" Content="Eksportuj wyniki..." Click="ExportButton_Click" Margin="0,0,20,0" IsEnabled="False"/>
            <Button x:Name="StartButton" Content="Uruchom Testy" Click="StartButton_Click" Padding="10,5" Margin="0,0,10,0"/>
            <Button Content="Zamknij" IsCancel="True" Padding="10,5"/>
        </StackPanel>
    </Grid>
</Window>
----- END FILE: GrafikWPF\BenchmarkWindow.xaml -----

----- BEGIN FILE: GrafikWPF\BenchmarkWindow.xaml.cs -----
using Microsoft.Win32;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.Json;
using System.Windows;
using System.Windows.Threading;

namespace GrafikWPF
{
    public partial class BenchmarkWindow : Window, INotifyPropertyChanged
    {
        public record PriorityProfile(string Name, List<SolverPriority> Priorities);

        private readonly DispatcherTimer _countdownTimer;
        public ObservableCollection<BenchmarkResult> Results { get; set; }
        public ObservableCollection<PriorityProfile> PriorityProfiles { get; set; }

        private PriorityProfile _selectedPriorityProfile;
        public PriorityProfile SelectedPriorityProfile
        {
            get => _selectedPriorityProfile;
            set { _selectedPriorityProfile = value; OnPropertyChanged(); }
        }

        private readonly Dictionary<string, RozwiazanyGrafik> _optimalStandards = new();
        private readonly string _debugLogPath = Path.Combine(AppContext.BaseDirectory, "benchmark_debug_log.txt");

        public BenchmarkWindow()
        {
            InitializeComponent();
            DataContext = this;

            Results = new ObservableCollection<BenchmarkResult>();
            _countdownTimer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(1) };

            PriorityProfiles = new ObservableCollection<PriorityProfile>
            {
                new("Ciągłość > Obsadzenie > Sprawiedliwość > Rozłożenie", new List<SolverPriority> { SolverPriority.CiagloscPoczatkowa, SolverPriority.LacznaLiczbaObsadzonychDni, SolverPriority.SprawiedliwoscObciazenia, SolverPriority.RownomiernoscRozlozenia }),
                new("Obsadzenie > Sprawiedliwość > Rozłożenie > Ciągłość", new List<SolverPriority> { SolverPriority.LacznaLiczbaObsadzonychDni, SolverPriority.SprawiedliwoscObciazenia, SolverPriority.RownomiernoscRozlozenia, SolverPriority.CiagloscPoczatkowa }),
                new("Sprawiedliwość > Rozłożenie > Ciągłość > Obsadzenie", new List<SolverPriority> { SolverPriority.SprawiedliwoscObciazenia, SolverPriority.RownomiernoscRozlozenia, SolverPriority.CiagloscPoczatkowa, SolverPriority.LacznaLiczbaObsadzonychDni }),
                new("Rozłożenie > Ciągłość > Obsadzenie > Sprawiedliwość", new List<SolverPriority> { SolverPriority.RownomiernoscRozlozenia, SolverPriority.CiagloscPoczatkowa, SolverPriority.LacznaLiczbaObsadzonychDni, SolverPriority.SprawiedliwoscObciazenia })
            };
            _selectedPriorityProfile = PriorityProfiles.First();

            LoadOptimalStandards();
            InitializeBenchmarkTasks();
        }

        private void LoadOptimalStandards()
        {
            var assembly = Assembly.GetExecutingAssembly();
            var resourceNames = assembly.GetManifestResourceNames().Where(n => n.Contains("BenchmarkStandards"));

            foreach (var name in resourceNames)
            {
                using var stream = assembly.GetManifestResourceStream(name);
                if (stream == null) continue;
                using var reader = new StreamReader(stream);
                string json = reader.ReadToEnd();
                try
                {
                    var standard = JsonSerializer.Deserialize<RozwiazanyGrafik>(json);
                    if (standard != null)
                    {
                        var key = Path.GetFileNameWithoutExtension(name.Split('.').Reverse().Skip(1).Reverse().Last());
                        _optimalStandards[key] = standard;
                    }
                }
                catch (JsonException ex)
                {
                    MessageBox.Show($"Błąd parsowania pliku wzorca: {name}\n\n{ex.Message}", "Błąd krytyczny", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        private void InitializeBenchmarkTasks()
        {
            Results.Clear();
            var testCases = new[]
            {
                new { Name = "Mały (7 dyżurnych)", DoctorCount = 7 },
                new { Name = "Średni (12 dyżurnych)", DoctorCount = 12 },
                new { Name = "Duży (20 dyżurnych)", DoctorCount = 20 }
            };

            var solvers = Enum.GetValues(typeof(SolverType)).Cast<SolverType>().ToList();

            foreach (var solverType in solvers)
            {
                foreach (var testCase in testCases)
                {
                    Results.Add(new BenchmarkResult
                    {
                        EngineName = solverType.ToString() + "Solver",
                        TestCaseName = testCase.Name,
                        SolverType = solverType,
                        DoctorCount = testCase.DoctorCount
                    });
                }
            }
        }

        private async void StartButton_Click(object sender, RoutedEventArgs e)
        {
            StartButton.IsEnabled = false;
            ExportButton.IsEnabled = false;
            PriorityProfileComboBox.IsEnabled = false;

            if (File.Exists(_debugLogPath)) File.Delete(_debugLogPath);

            var selectedPriorities = SelectedPriorityProfile.Priorities;

            var priorityKeyBuilder = new StringBuilder();
            foreach (var priority in selectedPriorities)
            {
                string keyPart = priority switch
                {
                    SolverPriority.CiagloscPoczatkowa => "continuity",
                    SolverPriority.LacznaLiczbaObsadzonychDni => "coverage",
                    SolverPriority.SprawiedliwoscObciazenia => "fairness",
                    SolverPriority.RownomiernoscRozlozenia => "spacing",
                    _ => ""
                };
                if (priorityKeyBuilder.Length > 0) priorityKeyBuilder.Append('_');
                priorityKeyBuilder.Append(keyPart);
            }
            string profileKey = priorityKeyBuilder.ToString();

            foreach (var result in Results)
            {
                Dispatcher.BeginInvoke(() => (BenchmarkItemsControl.ItemContainerGenerator.ContainerFromItem(result) as FrameworkElement)?.BringIntoView(), DispatcherPriority.Background);

                result.Status = "W toku...";
                result.ExecutionTime = "-";
                result.Progress = 0;
                result.TimeRemaining = "";
                result.QualityScore = "-";

                var testData = BenchmarkDataFactory.CreateTestCase(result.DoctorCount);

                string testCaseKey = result.DoctorCount == 7 ? "small" : (result.DoctorCount == 12 ? "medium" : "large");

                string standardKey = $"optimal_{testCaseKey}_{profileKey}";
                _optimalStandards.TryGetValue(standardKey, out var optimalStandard);

                double optimalScore = 0;

                if (optimalStandard != null)
                {
                    // Używamy nowej, ujednoliconej usługi do oceny wzorca
                    optimalScore = EvaluationAndScoringService.CalculateScore(optimalStandard, selectedPriorities, testData);
                }

                var stopwatch = new Stopwatch();
                using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(60));
                int countdown = 60;

                EventHandler? tickHandler = (s, args) =>
                {
                    countdown--;
                    if (countdown >= 0) result.TimeRemaining = $"Do anulowania: {countdown}s";
                };
                _countdownTimer.Tick += tickHandler;
                result.TimeRemaining = $"Do anulowania: {countdown}s";
                _countdownTimer.Start();

                RozwiazanyGrafik? solverResult = null;

                try
                {
                    solverResult = await Task.Run(() =>
                    {
                        stopwatch.Start();
                        var progress = new Progress<double>(p => result.Progress = p * 100);
                        var solver = SolverFactory.CreateSolver(result.SolverType, testData, selectedPriorities, progress, cts.Token);
                        var solution = solver.ZnajdzOptymalneRozwiazanie();
                        stopwatch.Stop();
                        return solution;
                    }, cts.Token);

                    result.Status = "Ukończono";
                    result.ExecutionTime = stopwatch.ElapsedMilliseconds.ToString();
                    result.Progress = 100;

                    if (solverResult != null && solverResult.Przypisania.Any() && optimalStandard != null && optimalScore > 0)
                    {
                        // Używamy nowej, ujednoliconej usługi do oceny wyniku solvera
                        double solverScore = EvaluationAndScoringService.CalculateScore(solverResult, selectedPriorities, testData);
                        double quality = (solverScore / optimalScore) * 100.0;
                        result.QualityScore = $"{quality:F2}%";
                        LogDebugInfo(result, optimalStandard, solverResult, optimalScore, solverScore, testData);
                    }
                    else if (optimalStandard == null)
                    {
                        result.QualityScore = "Brak wzorca";
                    }
                    else
                    {
                        result.QualityScore = "Brak danych";
                    }
                }
                catch (OperationCanceledException)
                {
                    HandleTimeout(result, stopwatch, solverResult, testData, optimalStandard, selectedPriorities);
                }
                catch (AggregateException ae)
                {
                    if (ae.Flatten().InnerExceptions.OfType<OperationCanceledException>().Any())
                    {
                        HandleTimeout(result, stopwatch, solverResult, testData, optimalStandard, selectedPriorities);
                    }
                    else
                    {
                        HandleGenericError(result, stopwatch, ae);
                    }
                }
                catch (Exception ex)
                {
                    HandleGenericError(result, stopwatch, ex);
                }
                finally
                {
                    _countdownTimer.Stop();
                    _countdownTimer.Tick -= tickHandler;
                    result.TimeRemaining = "";
                }
            }

            StartButton.IsEnabled = true;
            ExportButton.IsEnabled = true;
            PriorityProfileComboBox.IsEnabled = true;
        }

        private void LogDebugInfo(BenchmarkResult result, RozwiazanyGrafik? standard, RozwiazanyGrafik solverResult, double optimalScore, double solverScore, GrafikWejsciowy testData)
        {
            if (standard == null) return;
            var utility = new SolverUtility(testData);

            var standardMetrics = EvaluationAndScoringService.CalculateMetrics(standard.Przypisania, utility.ObliczOblozenie(standard.Przypisania), testData);
            var solverMetrics = solverResult; // solverResult to już obiekt z pełnymi metrykami

            var sb = new StringBuilder();
            sb.AppendLine("===============================================================");
            sb.AppendLine($"DEBUG LOG: {result.EngineName} @ {result.TestCaseName}");
            sb.AppendLine("===============================================================");
            sb.AppendLine();
            sb.AppendLine("---------- WZORZEC (Z PLIKU .JSON) ----------");
            sb.AppendLine($"Optimal Score: {optimalScore:F4}");
            sb.AppendLine($"DlugoscCiaguPoczatkowego: {standardMetrics.DlugoscCiaguPoczatkowego}");
            sb.AppendLine($"LiczbaDniObsadzonych: {standardMetrics.LiczbaDniObsadzonych}");
            sb.AppendLine($"WskaznikRownomiernosci: {standardMetrics.WskaznikRownomiernosci:F10}");
            sb.AppendLine($"WskaznikRozlozeniaDyzurow: {standardMetrics.WskaznikRozlozeniaDyzurow:F10}");
            sb.AppendLine($"ZrealizowaneBardzoChce: {standardMetrics.ZrealizowaneBardzoChce}");
            sb.AppendLine($"ZrealizowaneChce: {standardMetrics.ZrealizowaneChce}");
            sb.AppendLine($"ZrealizowaneMoge: {standardMetrics.ZrealizowaneMoge}");
            sb.AppendLine();
            sb.AppendLine("---------- WYNIK SOLVERA (Z TESTU) ----------");
            sb.AppendLine($"Solver Score: {solverScore:F4}");
            sb.AppendLine($"DlugoscCiaguPoczatkowego: {solverMetrics.DlugoscCiaguPoczatkowego}");
            sb.AppendLine($"LiczbaDniObsadzonych: {solverMetrics.LiczbaDniObsadzonych}");
            sb.AppendLine($"WskaznikRownomiernosci: {solverMetrics.WskaznikRownomiernosci:F10}");
            sb.AppendLine($"WskaznikRozlozeniaDyzurow: {solverMetrics.WskaznikRozlozeniaDyzurow:F10}");
            sb.AppendLine($"ZrealizowaneBardzoChce: {solverMetrics.ZrealizowaneBardzoChce}");
            sb.AppendLine($"ZrealizowaneChce: {solverMetrics.ZrealizowaneChce}");
            sb.AppendLine($"ZrealizowaneMoge: {solverMetrics.ZrealizowaneMoge}");
            sb.AppendLine();

            File.AppendAllText(_debugLogPath, sb.ToString());
        }

        private void HandleTimeout(BenchmarkResult result, Stopwatch stopwatch, RozwiazanyGrafik? solverResult, GrafikWejsciowy testData, RozwiazanyGrafik? optimalStandard, List<SolverPriority> selectedPriorities)
        {
            if (stopwatch.IsRunning) stopwatch.Stop();
            result.Status = "Przekroczono limit czasu";
            result.ExecutionTime = "> 60000";

            if (solverResult != null && solverResult.Przypisania.Any() && optimalStandard != null)
            {
                double optimalScore = EvaluationAndScoringService.CalculateScore(optimalStandard, selectedPriorities, testData);
                double solverScore = EvaluationAndScoringService.CalculateScore(solverResult, selectedPriorities, testData);
                if (optimalScore > 0)
                {
                    double quality = (solverScore / optimalScore) * 100.0;
                    result.QualityScore = $"{quality:F2}% (nieoptymalny)";
                }
            }
            else
            {
                result.QualityScore = "Brak danych";
                result.QualityScoreDetails = "(test przerwany)";
            }
            result.Progress = 0;
        }

        private void HandleGenericError(BenchmarkResult result, Stopwatch stopwatch, Exception ex)
        {
            if (stopwatch.IsRunning) stopwatch.Stop();
            result.Status = $"Błąd: {ex.GetType().Name}";
            result.ExecutionTime = "-";
            result.QualityScore = "Brak danych";
            result.Progress = 0;
        }

        private void ExportButton_Click(object sender, RoutedEventArgs e)
        {
            var dialog = new SaveFileDialog
            {
                Filter = "Pliki CSV (*.csv)|*.csv|Pliki tekstowe (*.txt)|*.*",
                FileName = $"Benchmark_{DateTime.Now:yyyyMMdd_HHmm}.csv",
                Title = "Zapisz wyniki benchmarku"
            };

            if (dialog.ShowDialog() == true)
            {
                var sb = new StringBuilder();
                sb.AppendLine($"Wyniki Benchmarku - Profil: {SelectedPriorityProfile.Name}");
                sb.AppendLine($"Data: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
                sb.AppendLine("Silnik;Scenariusz;Czas (ms);Zgodność z wzorcem (%);Status");

                foreach (var r in Results)
                {
                    sb.AppendLine($"\"{r.EngineName}\";\"{r.TestCaseName}\";\"{r.ExecutionTime}\";\"{r.QualityScore}\";\"{r.Status}\"");
                }

                try
                {
                    File.WriteAllText(dialog.FileName, sb.ToString(), Encoding.UTF8);
                    MessageBox.Show($"Wyniki zapisano do pliku:\n{dialog.FileName}", "Eksport zakończony", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Wystąpił błąd podczas zapisu pliku:\n{ex.Message}", "Błąd eksportu", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? name = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}
----- END FILE: GrafikWPF\BenchmarkWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\BooleanToVisibilityConverter.cs -----
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace GrafikWPF
{
    // Konwerter standardowy: true -> Visible, false -> Collapsed
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (value is bool b && b) ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (value is Visibility v && v == Visibility.Visible);
        }
    }

    // Konwerter odwrócony: true -> Collapsed, false -> Visible
    public class InvertedBooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (value is bool b && b) ? Visibility.Collapsed : Visibility.Visible;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            return (value is Visibility v && v == Visibility.Collapsed);
        }
    }
}
----- END FILE: GrafikWPF\BooleanToVisibilityConverter.cs -----

----- BEGIN FILE: GrafikWPF\ConstraintValidationService.cs -----
using System;
using System.Collections.Generic;
using System.Linq;

namespace GrafikWPF
{
    public static class ConstraintValidationService
    {
        public static List<Lekarz> GetValidCandidatesForDay(
            DateTime dzien,
            GrafikWejsciowy daneWejsciowe,
            IReadOnlyDictionary<DateTime, Lekarz?> aktualnePrzypisania,
            IReadOnlyDictionary<string, int> aktualneOblozenie,
            IReadOnlySet<string> wykorzystaneDyzuryW)
        {
            var dniMiesiaca = daneWejsciowe.DniWMiesiacu;
            var lekarzDniaPoprzedniego = dzien > dniMiesiaca.First() && aktualnePrzypisania.TryGetValue(dzien.AddDays(-1), out var wczorajszyLekarz) ? wczorajszyLekarz : null;

            var kandydaci = new List<Lekarz>();
            foreach (var lekarz in daneWejsciowe.Lekarze.Where(l => l.IsAktywny))
            {
                if (IsValidCandidate(lekarz, dzien, daneWejsciowe, lekarzDniaPoprzedniego, aktualneOblozenie, wykorzystaneDyzuryW))
                {
                    kandydaci.Add(lekarz);
                }
            }
            return kandydaci;
        }

        private static bool IsValidCandidate(Lekarz lekarz, DateTime dzien, GrafikWejsciowy daneWejsciowe, Lekarz? lekarzDniaPoprzedniego, IReadOnlyDictionary<string, int> aktualneOblozenie, IReadOnlySet<string> wykorzystaneDyzuryW)
        {
            int maksymalnaLiczbaDyzurow = daneWejsciowe.LimityDyzurow.GetValueOrDefault(lekarz.Symbol, 0);
            if (maksymalnaLiczbaDyzurow <= 0 || aktualneOblozenie.GetValueOrDefault(lekarz.Symbol, 0) >= maksymalnaLiczbaDyzurow)
                return false;

            var dostepnoscDzis = daneWejsciowe.Dostepnosc[dzien][lekarz.Symbol];
            if (dostepnoscDzis is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny)
                return false;

            bool maBardzoChce = (dostepnoscDzis == TypDostepnosci.BardzoChce);
            if (!maBardzoChce && lekarzDniaPoprzedniego?.Symbol == lekarz.Symbol)
                return false;

            if (!maBardzoChce)
            {
                var jutro = dzien.AddDays(1);
                if (daneWejsciowe.Dostepnosc.ContainsKey(jutro) && daneWejsciowe.Dostepnosc[jutro][lekarz.Symbol] == TypDostepnosci.DyzurInny)
                    return false;

                var wczoraj = dzien.AddDays(-1);
                if (daneWejsciowe.Dostepnosc.ContainsKey(wczoraj) && daneWejsciowe.Dostepnosc[wczoraj][lekarz.Symbol] == TypDostepnosci.DyzurInny)
                    return false;
            }

            if (dostepnoscDzis == TypDostepnosci.MogeWarunkowo && wykorzystaneDyzuryW.Contains(lekarz.Symbol))
                return false;

            return true;
        }


        public static void RepairSchedule(Dictionary<DateTime, Lekarz?> grafik, GrafikWejsciowy daneWejsciowe)
        {
            bool dokonanoZmiany;
            do
            {
                dokonanoZmiany = false;
                var oblozenie = ObliczOblozenie(grafik, daneWejsciowe);
                var wykorzystaneW = ObliczWykorzystaneW(grafik, daneWejsciowe);

                foreach (var lekarzSymbol in oblozenie.Keys)
                {
                    var limit = daneWejsciowe.LimityDyzurow.GetValueOrDefault(lekarzSymbol, 0);
                    while (oblozenie[lekarzSymbol] > limit)
                    {
                        var dyzuryDoUsuniecia = grafik.Where(g => g.Value?.Symbol == lekarzSymbol).ToList();
                        if (dyzuryDoUsuniecia.Any())
                        {
                            var dyzurDoUsuniecia = dyzuryDoUsuniecia
                                .OrderBy(d => GetAvailabilityScore(daneWejsciowe.Dostepnosc[d.Key][d.Value!.Symbol]))
                                .ThenByDescending(d => d.Key)
                                .First();

                            grafik[dyzurDoUsuniecia.Key] = null;
                            oblozenie[lekarzSymbol]--;
                            dokonanoZmiany = true;
                        }
                        else break;
                    }
                }

                foreach (var symbolLekarza in wykorzystaneW.Keys)
                {
                    while (wykorzystaneW[symbolLekarza] > 1)
                    {
                        var dyzuryWdoUsuniecia = grafik.FirstOrDefault(g => g.Value?.Symbol == symbolLekarza && daneWejsciowe.Dostepnosc[g.Key][g.Value.Symbol] == TypDostepnosci.MogeWarunkowo);
                        if (dyzuryWdoUsuniecia.Key != default)
                        {
                            grafik[dyzuryWdoUsuniecia.Key] = null;
                            wykorzystaneW[symbolLekarza]--;
                            dokonanoZmiany = true;
                        }
                        else break;
                    }
                }

                foreach (var dzien in daneWejsciowe.DniWMiesiacu)
                {
                    var lekarz = grafik[dzien];
                    if (lekarz == null) continue;

                    var dostepnosc = daneWejsciowe.Dostepnosc[dzien][lekarz.Symbol];
                    if (dostepnosc == TypDostepnosci.Rezerwacja) continue;

                    if (dostepnosc == TypDostepnosci.BardzoChce)
                        continue;

                    var wczoraj = dzien.AddDays(-1);
                    if (grafik.ContainsKey(wczoraj))
                    {
                        if (grafik[wczoraj]?.Symbol == lekarz.Symbol || daneWejsciowe.Dostepnosc[wczoraj][lekarz.Symbol] == TypDostepnosci.DyzurInny)
                        {
                            grafik[dzien] = null;
                            dokonanoZmiany = true;
                            continue;
                        }
                    }

                    var jutro = dzien.AddDays(1);
                    if (grafik.ContainsKey(jutro) && daneWejsciowe.Dostepnosc[jutro][lekarz.Symbol] == TypDostepnosci.DyzurInny)
                    {
                        grafik[dzien] = null;
                        dokonanoZmiany = true;
                    }
                }

            } while (dokonanoZmiany);
        }

        private static int GetAvailabilityScore(TypDostepnosci typ)
        {
            return typ switch
            {
                TypDostepnosci.MogeWarunkowo => 0,
                TypDostepnosci.Moge => 1,
                TypDostepnosci.Chce => 2,
                TypDostepnosci.BardzoChce => 3,
                TypDostepnosci.Rezerwacja => 99,
                _ => -1
            };
        }

        private static Dictionary<string, int> ObliczOblozenie(IReadOnlyDictionary<DateTime, Lekarz?> genes, GrafikWejsciowy daneWejsciowe)
        {
            var oblozenie = daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            foreach (var lekarz in genes.Values.Where(l => l != null))
            {
                if (lekarz != null) oblozenie[lekarz.Symbol]++;
            }
            return oblozenie;
        }

        private static Dictionary<string, int> ObliczWykorzystaneW(IReadOnlyDictionary<DateTime, Lekarz?> genes, GrafikWejsciowy daneWejsciowe)
        {
            var wykorzystane = daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            foreach (var para in genes)
            {
                if (para.Value != null && daneWejsciowe.Dostepnosc.ContainsKey(para.Key) && daneWejsciowe.Dostepnosc[para.Key][para.Value.Symbol] == TypDostepnosci.MogeWarunkowo)
                {
                    wykorzystane[para.Value.Symbol]++;
                }
            }
            return wykorzystane;
        }
    }
}
----- END FILE: GrafikWPF\ConstraintValidationService.cs -----

----- BEGIN FILE: GrafikWPF\DaneAplikacji.cs -----
namespace GrafikWPF
{
    public class DaneAplikacji
    {
        public string NazwaOddzialu { get; set; } = "Zakład Diagnostyki Obrazowej";
        public string NazwaSzpitala { get; set; } = "Szpital Kliniczny im. dr. Emila Warmińskiego Politechniki Bydgoskiej";

        public List<Lekarz> WszyscyLekarze { get; set; } = new();

        public Dictionary<string, DaneMiesiaca> DaneGrafikow { get; set; } = new();

        public List<SolverPriority> KolejnoscPriorytetowSolvera { get; set; } = new();

        public SolverType WybranyAlgorytm { get; set; } = SolverType.Backtracking;


        public void InicjalizujPriorytety()
        {
            if (KolejnoscPriorytetowSolvera == null || !KolejnoscPriorytetowSolvera.Any())
            {
                KolejnoscPriorytetowSolvera = new List<SolverPriority>
                {
                    SolverPriority.CiagloscPoczatkowa,
                    SolverPriority.LacznaLiczbaObsadzonychDni,
                    SolverPriority.SprawiedliwoscObciazenia,
                    SolverPriority.RownomiernoscRozlozenia
                };
            }
        }
    }
}
----- END FILE: GrafikWPF\DaneAplikacji.cs -----

----- BEGIN FILE: GrafikWPF\DaneMiesiaca.cs -----
namespace GrafikWPF
{
    public class DaneMiesiaca
    {
        /// <summary>
        /// Słownik przechowujący zadeklarowaną dostępność lekarzy w danym miesiącu.
        /// Klucz: Data (DateTime), Wartość: Słownik (Symbol Lekarza -> TypDostepnosci).
        /// </summary>
        public Dictionary<DateTime, Dictionary<string, TypDostepnosci>> Dostepnosc { get; set; } = new();

        /// <summary>
        /// Słownik przechowujący limity dyżurów dla lekarzy w danym miesiącu.
        /// Klucz: Symbol Lekarza, Wartość: Limit (int).
        /// </summary>
        public Dictionary<string, int> LimityDyzurow { get; set; } = new();

        /// <summary>
        /// Wygenerowany i zapisany przez użytkownika grafik dla danego miesiąca.
        /// Może być null, jeśli grafik nie został jeszcze wygenerowany lub zapisany.
        /// </summary>
        public RozwiazanyGrafik? ZapisanyGrafik { get; set; }

        /// <summary>
        /// Przechowuje "migawkę" symboli lekarzy, którzy byli aktywni 
        /// w momencie pierwszego zapisu danych dla tego miesiąca.
        /// </summary>
        public List<string>? SymboleLekarzyAktywnychWMiesiacu { get; set; }
    }
}
----- END FILE: GrafikWPF\DaneMiesiaca.cs -----

----- BEGIN FILE: GrafikWPF\DataManager.cs -----
using System.IO;
using System.Text.Json;
using System.Windows;

namespace GrafikWPF
{
    public static class DataManager
    {
        private static readonly string _dataFolderPath;
        private static readonly string _dataFilePath;
        private static readonly string _backupFilePath;
        private static readonly JsonSerializerOptions _jsonOptions;

        public static DaneAplikacji AppData { get; private set; } = new();

        static DataManager()
        {
            _dataFolderPath = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData), "GrafikOptymalny");
            _dataFilePath = Path.Combine(_dataFolderPath, "data.json");
            _backupFilePath = Path.Combine(_dataFolderPath, "data.bak");
            _jsonOptions = new JsonSerializerOptions { WriteIndented = true, Encoder = System.Text.Encodings.Web.JavaScriptEncoder.UnsafeRelaxedJsonEscaping };
        }

        public static void LoadData()
        {
            try
            {
                Directory.CreateDirectory(_dataFolderPath);

                if (File.Exists(_dataFilePath))
                {
                    string jsonString = File.ReadAllText(_dataFilePath);
                    AppData = JsonSerializer.Deserialize<DaneAplikacji>(jsonString) ?? new DaneAplikacji();
                }
                else if (File.Exists(_backupFilePath))
                {
                    string jsonString = File.ReadAllText(_backupFilePath);
                    AppData = JsonSerializer.Deserialize<DaneAplikacji>(jsonString) ?? new DaneAplikacji();
                    MessageBox.Show("Nie znaleziono głównego pliku danych. Wczytano dane z kopii zapasowej.", "Informacja", MessageBoxButton.OK, MessageBoxImage.Information);
                }

                if (AppData.WszyscyLekarze == null || AppData.WszyscyLekarze.Count == 0)
                {
                    InitializeDefaultData();
                }

                // Czyszczenie priorytetów z nieaktualnych wartości
                var aktualnePriorytety = Enum.GetValues(typeof(SolverPriority)).Cast<SolverPriority>();
                AppData.KolejnoscPriorytetowSolvera = AppData.KolejnoscPriorytetowSolvera
                                                        .Where(p => aktualnePriorytety.Contains(p))
                                                        .ToList();

                AppData.InicjalizujPriorytety();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Wystąpił krytyczny błąd podczas wczytywania danych: {ex.Message}\nAplikacja spróbuje użyć danych domyślnych.", "Błąd wczytywania", MessageBoxButton.OK, MessageBoxImage.Error);
                InitializeDefaultData();
                AppData.InicjalizujPriorytety();
            }
        }

        public static void SaveData()
        {
            try
            {
                if (File.Exists(_dataFilePath))
                {
                    File.Copy(_dataFilePath, _backupFilePath, true);
                }

                string jsonString = JsonSerializer.Serialize(AppData, _jsonOptions);
                File.WriteAllText(_dataFilePath, jsonString);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Wystąpił błąd podczas zapisywania danych: {ex.Message}", "Błąd zapisu", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private static void InitializeDefaultData()
        {
            AppData = new DaneAplikacji
            {
                WszyscyLekarze = new List<Lekarz>
                {
                    new("BIE", "Aleksandra", "Biedroń"),
                    new("GRA", "Rafał", "Grabowski"),
                    new("HRY", "Julia", "Hrycyk"),
                    new("LEM", "Adam", "Lemanowicz"),
                    new("LES", "Natalia", "Leszczyńska"),
                    new("NAR", "Agnieszka", "Narolska-Jochemczak"),
                    new("POL", "Maria", "Polska"),
                    new("PRU", "Kamil", "Prusakowski"),
                    new("SER", "Zbigniew", "Serafin"),
                    new("SOB", "Bartosz", "Sobociński"),
                    new("ŻAK", "Kinga", "Żak")
                }
            };
        }
    }
}
----- END FILE: GrafikWPF\DataManager.cs -----

----- BEGIN FILE: GrafikWPF\Enums\TypDostepnosci.cs -----
namespace GrafikWPF
{
    public enum TypDostepnosci
    {
        Niedostepny,
        Moge,
        Chce,
        BardzoChce,
        Urlop,
        DyzurInny,
        MogeWarunkowo,
        Rezerwacja
    }
}
----- END FILE: GrafikWPF\Enums\TypDostepnosci.cs -----

----- BEGIN FILE: GrafikWPF\EvaluationAndScoringService.cs -----
using System;
using System.Collections.Generic;
using System.Linq;

namespace GrafikWPF
{
    public static class EvaluationAndScoringService
    {
        private static readonly Dictionary<SolverPriority, double> PriorityWeights = new()
        {
            { SolverPriority.CiagloscPoczatkowa,       1_000_000_000_000 },
            { SolverPriority.LacznaLiczbaObsadzonychDni,  1_000_000_000 },
            { SolverPriority.SprawiedliwoscObciazenia,     1_000_000 },
            { SolverPriority.RownomiernoscRozlozenia,       1_000 }
        };

        private const double REZERWACJA_WEIGHT = 100_000_000_000_000;
        private const double BARDZO_CHCE_WEIGHT = 100;
        private const double CHCE_WEIGHT = 10;
        private const double MOGE_WEIGHT = 1;

        public static double CalculateScore(RozwiazanyGrafik grafik, List<SolverPriority> priorytety, GrafikWejsciowy daneWejsciowe)
        {
            if (grafik == null) return double.MinValue;

            double totalDays = daneWejsciowe.DniWMiesiacu.Count;
            if (totalDays == 0) return 0;

            double normContinuity = grafik.DlugoscCiaguPoczatkowego / totalDays;
            double normCoverage = grafik.LiczbaDniObsadzonych / totalDays;
            double normFairness = 1.0 / (1.0 + grafik.WskaznikRownomiernosci);
            double normSpacing = 1.0 / (1.0 + grafik.WskaznikRozlozeniaDyzurow);

            double score = 0;

            score += grafik.ZrealizowaneRezerwacje * REZERWACJA_WEIGHT;

            var normalizedValues = new Dictionary<SolverPriority, double>
            {
                { SolverPriority.CiagloscPoczatkowa, normContinuity },
                { SolverPriority.LacznaLiczbaObsadzonychDni, normCoverage },
                { SolverPriority.SprawiedliwoscObciazenia, normFairness },
                { SolverPriority.RownomiernoscRozlozenia, normSpacing }
            };

            foreach (var priority in priorytety)
            {
                if (PriorityWeights.TryGetValue(priority, out double weight))
                {
                    score += normalizedValues[priority] * weight;
                }
            }

            score += grafik.ZrealizowaneBardzoChce * BARDZO_CHCE_WEIGHT;
            score += grafik.ZrealizowaneChce * CHCE_WEIGHT;
            score += grafik.ZrealizowaneMoge * MOGE_WEIGHT;

            return score;
        }

        public static long[] ToIntVector(RozwiazanyGrafik m, List<SolverPriority> priorytety)
        {
            var v = new long[priorytety.Count + 4]; // 4 dodatkowe metryki (Rezerwacje, BC, Ch, M)
            int i = 0;

            var metricsMap = new Dictionary<SolverPriority, long>
            {
                { SolverPriority.LacznaLiczbaObsadzonychDni, m.LiczbaDniObsadzonych },
                { SolverPriority.CiagloscPoczatkowa, m.DlugoscCiaguPoczatkowego },
                { SolverPriority.SprawiedliwoscObciazenia, -(long)Math.Round(1_000_000.0 * m.WskaznikRownomiernosci) },
                { SolverPriority.RownomiernoscRozlozenia, -(long)Math.Round(1_000_000.0 * m.WskaznikRozlozeniaDyzurow) }
            };

            foreach (var p in priorytety)
            {
                v[i++] = metricsMap.GetValueOrDefault(p, 0);
            }

            v[i++] = m.ZrealizowaneRezerwacje;
            v[i++] = m.ZrealizowaneBardzoChce;
            v[i++] = m.ZrealizowaneChce;
            v[i++] = m.ZrealizowaneMoge;
            return v;
        }

        public static RozwiazanyGrafik CalculateMetrics(IReadOnlyDictionary<DateTime, Lekarz?> przypisania, IReadOnlyDictionary<string, int> oblozenie, GrafikWejsciowy daneWejsciowe)
        {
            var dni = daneWejsciowe.DniWMiesiacu;
            var p = new Dictionary<DateTime, Lekarz?>(przypisania);

            int cp = 0;
            foreach (var key in dni.OrderBy(d => d)) { if (p.TryGetValue(key, out var l) && l != null) cp++; else break; }

            int zrealizowaneRezerwacje = 0;
            int zrealizowaneChce = 0;
            int zrealizowaneBardzoChce = 0;
            int zrealizowaneMoge = 0;
            foreach (var wpis in p.Where(x => x.Value != null))
            {
                var typ = daneWejsciowe.Dostepnosc[wpis.Key][wpis.Value!.Symbol];
                if (typ == TypDostepnosci.Rezerwacja) zrealizowaneRezerwacje++;
                else if (typ == TypDostepnosci.Chce) zrealizowaneChce++;
                else if (typ == TypDostepnosci.BardzoChce) zrealizowaneBardzoChce++;
                else if (typ == TypDostepnosci.Moge) zrealizowaneMoge++;
            }

            var obciazeniaProcentowe = new List<double>();
            foreach (var lekarz in daneWejsciowe.Lekarze.Where(l => l.IsAktywny))
            {
                int maksymalnaLiczbaDyzurow = daneWejsciowe.LimityDyzurow.GetValueOrDefault(lekarz.Symbol, 0);
                if (maksymalnaLiczbaDyzurow > 0)
                {
                    double ldyzurow = oblozenie.GetValueOrDefault(lekarz.Symbol, 0);
                    obciazeniaProcentowe.Add(ldyzurow * 100.0 / maksymalnaLiczbaDyzurow);
                }
            }

            double wskaznikRownomiernosci = 0.0;
            if (obciazeniaProcentowe.Count > 1)
            {
                double srednia = obciazeniaProcentowe.Average();
                double sumaKwadratowRoznic = obciazeniaProcentowe.Sum(val => (val - srednia) * (val - srednia));
                wskaznikRownomiernosci = Math.Sqrt(sumaKwadratowRoznic / obciazeniaProcentowe.Count);
            }

            double wskaznikRozlozeniaDyzurow = 0.0;
            var wszystkieOdchylenia = new List<double>();
            foreach (var lekarz in daneWejsciowe.Lekarze.Where(l => l.IsAktywny))
            {
                var dyzuryLekarza = p.Where(kvp => kvp.Value?.Symbol == lekarz.Symbol)
                                     .Select(kvp => kvp.Key)
                                     .OrderBy(d => d)
                                     .ToList();

                if (dyzuryLekarza.Count > 2)
                {
                    var odstepy = new List<double>();
                    for (int i = 0; i < dyzuryLekarza.Count - 1; i++)
                    {
                        odstepy.Add((dyzuryLekarza[i + 1] - dyzuryLekarza[i]).TotalDays);
                    }

                    if (odstepy.Any())
                    {
                        double sredniOdstep = odstepy.Average();
                        double sumaKwadratowRoznicOdstepow = odstepy.Sum(val => (val - sredniOdstep) * (val - sredniOdstep));
                        wszystkieOdchylenia.Add(Math.Sqrt(sumaKwadratowRoznicOdstepow / odstepy.Count));
                    }
                }
            }
            if (wszystkieOdchylenia.Any())
            {
                wskaznikRozlozeniaDyzurow = wszystkieOdchylenia.Average();
            }

            return new RozwiazanyGrafik
            {
                Przypisania = p,
                DlugoscCiaguPoczatkowego = cp,
                ZrealizowaneRezerwacje = zrealizowaneRezerwacje,
                ZrealizowaneChce = zrealizowaneChce,
                ZrealizowaneBardzoChce = zrealizowaneBardzoChce,
                ZrealizowaneMoge = zrealizowaneMoge,
                FinalneOblozenieLekarzy = new Dictionary<string, int>(oblozenie),
                WskaznikRownomiernosci = wskaznikRownomiernosci,
                WskaznikRozlozeniaDyzurow = wskaznikRozlozeniaDyzurow
            };
        }
    }
}
----- END FILE: GrafikWPF\EvaluationAndScoringService.cs -----

----- BEGIN FILE: GrafikWPF\GeneticSolver.cs -----
using System.Collections.Concurrent;

namespace GrafikWPF
{
    public class GeneticSolver : IGrafikSolver
    {
        private class Chromosome
        {
            public Dictionary<DateTime, Lekarz?> Genes { get; set; }
            public double Fitness { get; set; }

            public Chromosome(Dictionary<DateTime, Lekarz?> genes)
            {
                Genes = genes;
                Fitness = 0.0;
            }

            public Chromosome Clone()
            {
                return new Chromosome(new Dictionary<DateTime, Lekarz?>(Genes));
            }
        }

        private readonly int _populationSize;
        private readonly int _generations;
        private const double CrossoverRate = 0.85;
        private const double MutationRate = 0.05;
        private const int TournamentSize = 5;

        private readonly GrafikWejsciowy _daneWejsciowe;
        private readonly List<SolverPriority> _kolejnoscPriorytetow;
        private readonly IProgress<double>? _progressReporter;
        private readonly CancellationToken _cancellationToken;
        private readonly SolverUtility _utility;

        private List<Chromosome> _population = new();
        private readonly Random _random = new();

        public GeneticSolver(GrafikWejsciowy daneWejsciowe, List<SolverPriority> kolejnoscPriorytetow, IProgress<double>? progress = null, CancellationToken cancellationToken = default)
        {
            _daneWejsciowe = daneWejsciowe;
            _kolejnoscPriorytetow = kolejnoscPriorytetow;
            _progressReporter = progress;
            _cancellationToken = cancellationToken;
            _utility = new SolverUtility(daneWejsciowe);

            int problemSize = _daneWejsciowe.Lekarze.Count * _daneWejsciowe.DniWMiesiacu.Count;
            _populationSize = Math.Max(50, problemSize / 5);
            _generations = Math.Max(150, problemSize * 2);
        }

        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            StworzPopulacjePoczatkowa();
            ObliczDopasowanie();

            for (int i = 0; i < _generations; i++)
            {
                _cancellationToken.ThrowIfCancellationRequested();

                var nowaPopulacja = new ConcurrentBag<Chromosome>();

                var najlepszy = _population.OrderByDescending(c => c.Fitness).First();
                nowaPopulacja.Add(najlepszy.Clone());

                Parallel.For(1, _populationSize, _ =>
                {
                    var rodzic1 = Selekcja();
                    var rodzic2 = Selekcja();
                    var dziecko = Krzyzowanie(rodzic1, rodzic2);
                    Mutacja(dziecko);
                    nowaPopulacja.Add(dziecko);
                });

                _population = nowaPopulacja.ToList();
                ObliczDopasowanie();
                _progressReporter?.Report((double)(i + 1) / _generations);
            }

            _progressReporter?.Report(1.0);
            var finalnyNajlepszy = _population.OrderByDescending(c => c.Fitness).First();
            return EvaluationAndScoringService.CalculateMetrics(finalnyNajlepszy.Genes, _utility.ObliczOblozenie(finalnyNajlepszy.Genes), _daneWejsciowe);
        }

        private void StworzPopulacjePoczatkowa()
        {
            _population = new List<Chromosome>();
            for (int i = 0; i < _populationSize; i++)
            {
                _population.Add(new Chromosome(_utility.StworzLosoweRozwiazanie()));
            }
        }

        private void ObliczDopasowanie()
        {
            Parallel.ForEach(_population, chromosom =>
            {
                var metryki = EvaluationAndScoringService.CalculateMetrics(chromosom.Genes, _utility.ObliczOblozenie(chromosom.Genes), _daneWejsciowe);
                chromosom.Fitness = EvaluationAndScoringService.CalculateScore(metryki, _kolejnoscPriorytetow, _daneWejsciowe);
            });
        }

        private Chromosome Selekcja()
        {
            var turniej = new List<Chromosome>();
            for (int i = 0; i < TournamentSize; i++)
            {
                turniej.Add(_population[_random.Next(_populationSize)]);
            }
            return turniej.OrderByDescending(c => c.Fitness).First();
        }

        private Chromosome Krzyzowanie(Chromosome rodzic1, Chromosome rodzic2)
        {
            if (_random.NextDouble() > CrossoverRate)
            {
                return rodzic1.Clone();
            }

            var punktKrzyzowania = _random.Next(_daneWejsciowe.DniWMiesiacu.Count);
            var dni = _daneWejsciowe.DniWMiesiacu;
            var dzieckoGenes = new Dictionary<DateTime, Lekarz?>();

            for (int i = 0; i < dni.Count; i++)
            {
                dzieckoGenes[dni[i]] = i < punktKrzyzowania ? rodzic1.Genes[dni[i]] : rodzic2.Genes[dni[i]];
            }

            ConstraintValidationService.RepairSchedule(dzieckoGenes, _daneWejsciowe);
            return new Chromosome(dzieckoGenes);
        }

        private void Mutacja(Chromosome chromosom)
        {
            foreach (var dzien in _daneWejsciowe.DniWMiesiacu)
            {
                if (_random.NextDouble() < MutationRate)
                {
                    var oblozenie = _utility.ObliczOblozenie(chromosom.Genes);
                    var wykorzystaneW = chromosom.Genes
                        .Where(g => g.Value != null && _daneWejsciowe.Dostepnosc[g.Key][g.Value.Symbol] == TypDostepnosci.MogeWarunkowo)
                        .Select(g => g.Value!.Symbol)
                        .ToHashSet();

                    var kandydaci = ConstraintValidationService.GetValidCandidatesForDay(dzien, _daneWejsciowe, chromosom.Genes, oblozenie, wykorzystaneW);
                    chromosom.Genes[dzien] = kandydaci.Any() ? kandydaci[_random.Next(kandydaci.Count)] : null;
                }
            }
            ConstraintValidationService.RepairSchedule(chromosom.Genes, _daneWejsciowe);
        }
    }
}
----- END FILE: GrafikWPF\GeneticSolver.cs -----

----- BEGIN FILE: GrafikWPF\GrafikWejsciowy.cs -----
namespace GrafikWPF
{
    public class GrafikWejsciowy
    {
        public List<Lekarz> Lekarze { get; set; } = new();
        public Dictionary<DateTime, Dictionary<string, TypDostepnosci>> Dostepnosc { get; set; } = new();

        // NOWY ELEMENT: Słownik przechowujący limity dyżurów (Symbol Lekarza -> Limit)
        public Dictionary<string, int> LimityDyzurow { get; set; } = new();

        public List<DateTime> DniWMiesiacu => Dostepnosc.Keys.OrderBy(d => d).ToList();
    }
}
----- END FILE: GrafikWPF\GrafikWejsciowy.cs -----

----- BEGIN FILE: GrafikWPF\GrafikWPF.csproj -----
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <OutputType>WinExe</OutputType>
    <TargetFramework>net8.0-windows</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
    <UseWPF>true</UseWPF>
  </PropertyGroup>

  <ItemGroup>
    <None Remove="BenchmarkStandards\optimal_large_continuity_coverage_fairness_spacing.json" />
    <None Remove="BenchmarkStandards\optimal_large_coverage_fairness_spacing_continuity.json" />
    <None Remove="BenchmarkStandards\optimal_large_fairness_spacing_continuity_coverage.json" />
    <None Remove="BenchmarkStandards\optimal_large_spacing_continuity_coverage_fairness.json" />
    <None Remove="BenchmarkStandards\optimal_medium_continuity_coverage_fairness_spacing.json" />
    <None Remove="BenchmarkStandards\optimal_medium_coverage_fairness_spacing_continuity.json" />
    <None Remove="BenchmarkStandards\optimal_medium_fairness_spacing_continuity_coverage.json" />
    <None Remove="BenchmarkStandards\optimal_medium_spacing_continuity_coverage_fairness.json" />
    <None Remove="BenchmarkStandards\optimal_small_continuity_coverage_fairness_spacing.json" />
    <None Remove="BenchmarkStandards\optimal_small_coverage_fairness_spacing_continuity.json" />
    <None Remove="BenchmarkStandards\optimal_small_fairness_spacing_continuity_coverage.json" />
    <None Remove="BenchmarkStandards\optimal_small_spacing_continuity_coverage_fairness.json" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Include="BenchmarkStandards\optimal_large_continuity_coverage_fairness_spacing.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_large_coverage_fairness_spacing_continuity.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_large_fairness_spacing_continuity_coverage.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_large_spacing_continuity_coverage_fairness.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_medium_continuity_coverage_fairness_spacing.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_medium_coverage_fairness_spacing_continuity.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_medium_fairness_spacing_continuity_coverage.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_medium_spacing_continuity_coverage_fairness.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_small_continuity_coverage_fairness_spacing.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_small_coverage_fairness_spacing_continuity.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_small_fairness_spacing_continuity_coverage.json" />
    <EmbeddedResource Include="BenchmarkStandards\optimal_small_spacing_continuity_coverage_fairness.json" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="ClosedXML" Version="0.105.0" />
    <PackageReference Include="EPPlus" Version="8.0.8" />
    <PackageReference Include="QuestPDF" Version="2025.7.0" />
  </ItemGroup>

</Project>

----- END FILE: GrafikWPF\GrafikWPF.csproj -----

----- BEGIN FILE: GrafikWPF\Heuristics\CandidateOrdering.cs -----
namespace GrafikWPF.Heuristics
{
    public static class CandidateOrdering
    {
        // Zwraca grupę porządkową 0..3 (BC,Chce,Moge,MogeWar) dla danego TypDostepnosci
        public static int GroupFor(TypDostepnosci av)
        {
            return av switch
            {
                TypDostepnosci.BardzoChce => 0,
                TypDostepnosci.Chce => 1,
                TypDostepnosci.Moge => 2,
                TypDostepnosci.MogeWarunkowo => 3,
                _ => 99
            };
        }
    }
}

----- END FILE: GrafikWPF\Heuristics\CandidateOrdering.cs -----

----- BEGIN FILE: GrafikWPF\Heuristics\GreedySeed.cs -----
namespace GrafikWPF.Heuristics
{
    public static class GreedySeed
    {
        // MRV po dniach, kandydaci BC->Chce->Moge->MogeWar, w grupie najmniejszy workload.
        // Respektuje limity dyżurów.
        public static int[] Generate(GrafikWejsciowy data, out int[] seedWorkload)
        {
            int days = data.DniWMiesiacu.Count;
            var doctors = data.Lekarze.FindAll(l => l.IsAktywny);
            int D = doctors.Count;

            var limit = new int[D];
            for (int p = 0; p < D; p++) limit[p] = data.LimityDyzurow.GetValueOrDefault(doctors[p].Symbol, 0);

            var ass = new int[days];
            var wl = new int[D];
            Array.Fill(ass, -1);

            for (int step = 0; step < days; step++)
            {
                // wybór dnia o najmniejszej liczbie kandydatów
                int bestDay = -1, bestCnt = int.MaxValue, bestBC = -1;
                for (int d = 0; d < days; d++)
                {
                    if (ass[d] != -1) continue;
                    int cnt = 0, hasBC = 0;
                    for (int p = 0; p < D; p++)
                    {
                        if (wl[p] >= limit[p]) continue;
                        var sym = doctors[p].Symbol;
                        var av = data.Dostepnosc[data.DniWMiesiacu[d]].GetValueOrDefault(sym, TypDostepnosci.Niedostepny);
                        if (av is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny) continue;
                        cnt++;
                        if (av == TypDostepnosci.BardzoChce) hasBC = 1;
                    }
                    if (cnt == 0) { bestDay = d; bestCnt = 0; bestBC = 0; break; }
                    if (cnt < bestCnt || (cnt == bestCnt && hasBC > bestBC))
                    { bestDay = d; bestCnt = cnt; bestBC = hasBC; }
                }

                // wybór lekarza z poszanowaniem limitów
                int sel = -1, selGroup = 999, selWl = int.MaxValue;
                for (int p = 0; p < D; p++)
                {
                    if (wl[p] >= limit[p]) continue;
                    var sym = doctors[p].Symbol;
                    var av = data.Dostepnosc[data.DniWMiesiacu[bestDay]].GetValueOrDefault(sym, TypDostepnosci.Niedostepny);
                    if (av is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny) continue;
                    int g = CandidateOrdering.GroupFor(av);
                    if (g > selGroup) continue;
                    if (g < selGroup || wl[p] < selWl) { sel = p; selGroup = g; selWl = wl[p]; }
                }
                ass[bestDay] = sel;
                if (sel >= 0) wl[sel]++;
            }

            seedWorkload = wl;
            return ass;
        }
    }
}

----- END FILE: GrafikWPF\Heuristics\GreedySeed.cs -----

----- BEGIN FILE: GrafikWPF\Heuristics\LocalSearch.cs -----
namespace GrafikWPF.Heuristics
{
    public static class LocalSearch
    {
        // Bardzo lekka poprawa: próby swap/relocate, akceptuj gdy poprawia metryki.
        public static void Improve(int[] assignments, GrafikWejsciowy data, int maxIters = 2000)
        {
            var days = data.DniWMiesiacu.Count;
            var wl = new Dictionary<string, int>();
            foreach (var l in data.Lekarze) if (l.IsAktywny) wl[l.Symbol] = 0;
            for (int d = 0; d < days; d++) if (assignments[d] >= 0) wl[data.Lekarze[assignments[d]].Symbol]++;

            var best = Score(assignments, data);
            var rnd = new Random(17);

            for (int it = 0; it < maxIters; it++)
            {
                int a = rnd.Next(days), b = rnd.Next(days);
                if (a == b) continue;
                (assignments[a], assignments[b]) = (assignments[b], assignments[a]);

                var sc = Score(assignments, data);
                if (Better(sc, best)) best = sc;
                else (assignments[a], assignments[b]) = (assignments[b], assignments[a]);
            }
        }

        private static RozwiazanyGrafik Score(int[] a, GrafikWejsciowy d)
        {
            var map = new Dictionary<DateTime, Lekarz?>();
            var ob = new Dictionary<string, int>();
            foreach (var l in d.Lekarze) if (l.IsAktywny) ob[l.Symbol] = 0;
            for (int i = 0; i < d.DniWMiesiacu.Count; i++)
            {
                var day = d.DniWMiesiacu[i];
                if (a[i] >= 0) { var L = d.Lekarze[a[i]]; map[day] = L; ob[L.Symbol]++; }
                else map[day] = null;
            }
            return EvaluationAndScoringService.CalculateMetrics(map, ob, d);
        }
        private static bool Better(RozwiazanyGrafik x, RozwiazanyGrafik y)
        {
            // uproszczona, ale deterministyczna kolejność ważna dla seeda
            if (x.LiczbaDniObsadzonych != y.LiczbaDniObsadzonych) return x.LiczbaDniObsadzonych > y.LiczbaDniObsadzonych;
            if (x.DlugoscCiaguPoczatkowego != y.DlugoscCiaguPoczatkowego) return x.DlugoscCiaguPoczatkowego > y.DlugoscCiaguPoczatkowego;
            var xf = 1.0 / (1.0 + x.WskaznikRownomiernosci); var yf = 1.0 / (1.0 + y.WskaznikRownomiernosci);
            if (xf != yf) return xf > yf;
            var xr = 1.0 / (1.0 + x.WskaznikRozlozeniaDyzurow); var yr = 1.0 / (1.0 + y.WskaznikRozlozeniaDyzurow);
            if (xr != yr) return xr > yr;
            if (x.ZrealizowaneBardzoChce != y.ZrealizowaneBardzoChce) return x.ZrealizowaneBardzoChce > y.ZrealizowaneBardzoChce;
            if (x.ZrealizowaneChce != y.ZrealizowaneChce) return x.ZrealizowaneChce > y.ZrealizowaneChce;
            if (x.ZrealizowaneMoge != y.ZrealizowaneMoge) return x.ZrealizowaneMoge > y.ZrealizowaneMoge;
            return false;
        }
    }
}

----- END FILE: GrafikWPF\Heuristics\LocalSearch.cs -----

----- BEGIN FILE: GrafikWPF\IGrafikSolver.cs -----
namespace GrafikWPF
{
    /// <summary>
    /// Definiuje wspólny kontrakt dla wszystkich silników obliczeniowych generujących grafik.
    /// </summary>
    public interface IGrafikSolver
    {
        /// <summary>
        /// Uruchamia proces obliczeniowy w celu znalezienia najlepszego możliwego grafiku.
        /// </summary>
        /// <returns>Obiekt RozwiazanyGrafik zawierający najlepsze znalezione rozwiązanie.</returns>
        RozwiazanyGrafik ZnajdzOptymalneRozwiazanie();
    }
}
----- END FILE: GrafikWPF\IGrafikSolver.cs -----

----- BEGIN FILE: GrafikWPF\InfoWindow.xaml -----
<Window x:Class="GrafikWPF.InfoWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Informacje o programie" 
        Width="550"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        WindowStyle="ToolWindow"
        ResizeMode="NoResize"
        Background="LightGray">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" FontSize="22" FontWeight="Bold" Text="Grafikomat dyżurowy"/>
        <TextBlock Grid.Row="1" Margin="0,5,0,15" LineHeight="20" TextWrapping="Wrap">
            <Run FontWeight="Bold">Wersja programu:</Run> 1.0<LineBreak/>
            <Run FontWeight="Bold">Koncepcja, funkcjonalność i projekt UI:</Run> Adam Lemanowicz<LineBreak/>
            <Run FontWeight="Bold">Przygotowanie kodu:</Run> Gemini 2.5 Pro (model AI od Google) na podstawie promptów (instrukcji) Adama Lemanowicza<LineBreak/>
            <Run FontWeight="Bold">Testowanie:</Run> Adam Lemanowicz<LineBreak/>
            <Run FontWeight="Bold">Debugging:</Run> Adam Lemanowicz &amp; Gemini 2.5 Pro
        </TextBlock>

        <Border Grid.Row="2" BorderBrush="DarkGray" BorderThickness="1" Padding="10">
            <ScrollViewer VerticalScrollBarVisibility="Auto" MaxHeight="250">
                <TextBlock TextWrapping="Wrap" TextAlignment="Justify">
                    <Run>Ten program jest udostępniany na licencji </Run>
                    <Run FontWeight="Bold">Creative Commons Uznanie autorstwa-Użycie niekomercyjne-Bez utworów zależnych 4.0 Międzynarodowe (CC BY-NC-ND 4.0)</Run>
                    <Run>.</Run>
                    <LineBreak/><LineBreak/>
                    <Run>Umożliwia ona swobodne kopiowanie i rozpowszechnianie programu w celach niekomercyjnych, pod warunkiem zachowania jego oryginalnej formy i podania autorstwa.</Run>
                    <LineBreak/><LineBreak/>
                    <Run>Pełna treść licencji dostępna jest pod adresem:</Run>
                    <LineBreak/>
                    <Hyperlink NavigateUri="https://creativecommons.org/licenses/by-nc-nd/4.0/deed.pl" RequestNavigate="Hyperlink_RequestNavigate">
                        https://creativecommons.org/licenses/by-nc-nd/4.0/deed.pl
                    </Hyperlink>
                </TextBlock>
            </ScrollViewer>
        </Border>

        <Button Grid.Row="3" Content="Zamknij" IsDefault="True" Click="Zamknij_Click" HorizontalAlignment="Right" Margin="0,15,0,0" Padding="10,5"/>
    </Grid>
</Window>
----- END FILE: GrafikWPF\InfoWindow.xaml -----

----- BEGIN FILE: GrafikWPF\InfoWindow.xaml.cs -----
using System.Diagnostics;
using System.Windows;
using System.Windows.Navigation;

namespace GrafikWPF
{
    public partial class InfoWindow : Window
    {
        public InfoWindow()
        {
            InitializeComponent();
        }

        private void Zamknij_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        // ### ZMIANA ### Dodano metodę do obsługi kliknięcia w link licencji
        private void Hyperlink_RequestNavigate(object sender, RequestNavigateEventArgs e)
        {
            Process.Start(new ProcessStartInfo(e.Uri.AbsoluteUri) { UseShellExecute = true });
            e.Handled = true;
        }
    }
}
----- END FILE: GrafikWPF\InfoWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\LegendaWindow.xaml -----
<Window x:Class="GrafikWPF.LegendaWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Wyjaśnienie deklaracji"
        Width="600"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        WindowStyle="ToolWindow"
        ResizeMode="NoResize"
        Background="LightGray">

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <ScrollViewer Grid.Row="0" VerticalScrollBarVisibility="Auto">
            <TextBlock TextWrapping="Wrap" LineHeight="20">
                <TextBlock FontWeight="Bold" FontSize="16">Dostępność i deklaracje dyżurnych</TextBlock>
                <LineBreak/><LineBreak/>
                <Run>Poniższe deklaracje określają dostępność i preferencje lekarza co do dyżuru w danym dniu. Algorytm używa ich do znalezienia optymalnego grafiku.</Run>
                <LineBreak/><LineBreak/>

                <TextBlock FontWeight="Bold" FontSize="14" Foreground="#006400">Deklaracje pozytywne (chęć podjęcia dyżuru)</TextBlock>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="📌" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Rezerwacja:</Run> Najwyższy możliwy priorytet. Oznacza, że lekarz bezwzględnie musi otrzymać dyżur w tym dniu, o ile nie łamie to twardych reguł (np. limitu dyżurów). Żaden inny kandydat nie będzie w tym dniu rozpatrywany.</TextBlock>
                </Grid>
                
                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="✅" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Bardzo chcę:</Run> Wysoki priorytet. Deklaracja ta jako jedyna ignoruje ograniczenia dyżuru dzień po dniu oraz w sąsiedztwie "Innego dyżuru".</TextBlock>
                </Grid>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="👍" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Chcę:</Run> Wyższy priorytet. Lekarz z tą deklaracją będzie brany pod uwagę przed lekarzem, który tylko "Może".</TextBlock>
                </Grid>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="🆗" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Mogę:</Run> Deklaracja neutralna, standardowa dostępność.</TextBlock>
                </Grid>
                
                <LineBreak/><LineBreak/>
                <TextBlock FontWeight="Bold" FontSize="14" Foreground="#b22222">Deklaracje z ograniczeniami lub negatywne</TextBlock>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="⚠️" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Mogę warunkowo:</Run> Deklaracja specjalna. Lekarzowi w ciągu miesiąca zostanie przydzielony co najwyżej jeden dyżur spośród wszystkich dni oznaczonych w ten sposób.</TextBlock>
                </Grid>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="🏥" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Inny dyżur:</Run> Oznacza dyżur w innym miejscu. Blokuje możliwość przydziału dyżuru w dniu poprzedzającym i następującym (chyba że występuje tam deklaracja "Bardzo chcę").</TextBlock>
                </Grid>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="🌴" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Urlop:</Run> Lekarz jest całkowicie niedostępny.</TextBlock>
                </Grid>

                <Grid Margin="20,10,0,0">
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto" />
                        <ColumnDefinition Width="*" />
                    </Grid.ColumnDefinitions>
                    <TextBlock Grid.Column="0" Text="❌" Margin="0,0,15,0" FontSize="14" VerticalAlignment="Center"/>
                    <TextBlock Grid.Column="1" TextWrapping="Wrap" VerticalAlignment="Center"><Run FontWeight="Bold">Niedostępny (---):</Run> Lekarz jest całkowicie niedostępny. Domyślna deklaracja dla każdego dnia.</TextBlock>
                </Grid>
            </TextBlock>
        </ScrollViewer>

        <Button Grid.Row="1" Content="Zamknij" IsDefault="True" Click="Zamknij_Click" HorizontalAlignment="Right" Margin="0,15,0,0" Padding="10,5"/>
    </Grid>
</Window>
----- END FILE: GrafikWPF\LegendaWindow.xaml -----

----- BEGIN FILE: GrafikWPF\LegendaWindow.xaml.cs -----
using System.Windows;

namespace GrafikWPF
{
    public partial class LegendaWindow : Window
    {
        public LegendaWindow()
        {
            InitializeComponent();
            this.Loaded += LegendaWindow_Loaded;
        }

        private void LegendaWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // Ograniczamy maksymalną wysokość okna do wysokości ekranu
            this.MaxHeight = SystemParameters.WorkArea.Height;
        }

        private void Zamknij_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }
    }
}
----- END FILE: GrafikWPF\LegendaWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\Lekarz.cs -----
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace GrafikWPF
{
    public class Lekarz : INotifyPropertyChanged
    {
        private string _symbol = "";
        public string Symbol
        {
            get => _symbol;
            set { _symbol = value; OnPropertyChanged(); }
        }

        private string _imie = "";
        public string Imie
        {
            get => _imie;
            set { _imie = value; OnPropertyChanged(); }
        }

        private string _nazwisko = "";
        public string Nazwisko
        {
            get => _nazwisko;
            set { _nazwisko = value; OnPropertyChanged(); }
        }

        private bool _isAktywny = true;
        public bool IsAktywny
        {
            get => _isAktywny;
            set { _isAktywny = value; OnPropertyChanged(); }
        }

        private bool _isUkryty = false;
        public bool IsUkryty
        {
            get => _isUkryty;
            set { _isUkryty = value; OnPropertyChanged(); }
        }

        public string PelneImie => $"{Imie} {Nazwisko}";

        public Lekarz() { }

        public Lekarz(string symbol, string imie, string nazwisko, bool isAktywny = true)
        {
            _symbol = symbol;
            _imie = imie;
            _nazwisko = nazwisko;
            _isAktywny = isAktywny;
            _isUkryty = false;
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? name = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}
----- END FILE: GrafikWPF\Lekarz.cs -----

----- BEGIN FILE: GrafikWPF\LogikaSolveraWindow.xaml -----
<Window x:Class="GrafikWPF.LogikaSolveraWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Logika i Strategia Działania"
        Width="650"
        SizeToContent="Height"
        WindowStartupLocation="CenterOwner"
        WindowStyle="ToolWindow"
        ResizeMode="NoResize"
        Background="LightGray">

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <ScrollViewer Grid.Row="0" VerticalScrollBarVisibility="Auto">
            <TextBlock TextWrapping="Wrap" LineHeight="20" TextAlignment="Justify">
                <TextBlock FontWeight="Bold" FontSize="16">Jak działa program?</TextBlock>
                <LineBreak/><LineBreak/>
                <Run>
                    Problem optymalnego ułożenia grafiku dyżurów jest wysoce złożonym zagadnieniem. Ilość możliwych kombinacji rośnie astronomicznie z każdym kolejnym lekarzem i dniem, uniemożliwiając ich pełne sprawdzenie. Program podchodzi do tego problemu w sposób strategiczny.
                </Run>                
                <LineBreak/><LineBreak/>
                
                <TextBlock FontWeight="Bold" FontSize="14">1. Cel: Czym jest "optymalny" grafik?</TextBlock>
                <LineBreak/>
                <Run>
                    To Ty decydujesz, co jest najważniejsze. W oknie "Kolejność priorytetów" układasz cele (np. ciągłość obsady, sprawiedliwość obciążenia) od najważniejszego do najmniej istotnego. Algorytm zawsze będzie dążył do maksymalizacji celu o wyższym priorytecie, traktując kolejne jako kryteria rozstrzygające w przypadku remisu.
                </Run>
                <LineBreak/><LineBreak/>

                <TextBlock FontWeight="Bold" FontSize="14">2. Narzędzia: Jak szukamy rozwiązania?</TextBlock>
                <LineBreak/>
                <Run>
                    Program posiada zestaw wyspecjalizowanych "silników" (algorytmów), z których każdy ma inną strategię działania. Wyboru dokonujesz w oknie "Wybór algorytmu". Można je porównać do różnych metod dotarcia na szczyt góry:
                </Run>
                <LineBreak/>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap"><Run FontWeight="Bold">Silniki Gwarantujące Optimum</Run> (np. Backtracking, AStar): Działają jak detektyw z kompletną mapą – metodycznie sprawdzają wszystkie obiecujące ścieżki. Dają gwarancję znalezienia absolutnie najlepszego możliwego wyniku, ale dla złożonych problemów ich praca może trwać bardzo długo.</TextBlock>
                </BulletDecorator>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap"><Run FontWeight="Bold">Silniki Metaheurystyczne</Run> (np. Genetic, AntColony): Działają jak doświadczony strateg – nie analizują każdej możliwości, ale używają inteligentnych technik, by bardzo szybko znaleźć rozwiązanie bliskie ideału. Są idealne dla skomplikowanych grafików pod presją czasu.</TextBlock>
                </BulletDecorator>
                <LineBreak/><LineBreak/>

                <TextBlock FontWeight="Bold" FontSize="14">3. Fundament: Nienaruszalne reguły</TextBlock>
                <LineBreak/>
                <Run>
                    Niezależnie od wybranych priorytetów i silnika, program zawsze i bezwzględnie przestrzega następujących "twardych" zasad:
                </Run>
                <LineBreak/>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap"><Run FontWeight="Bold">Rezerwacje</Run> są przydzielane w pierwszej kolejności, zanim algorytm zacznie wypełniać resztę grafiku.</TextBlock>
                </BulletDecorator>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap">Lekarz nie może przekroczyć swojego <Run FontWeight="Bold">limitu dyżurów</Run>.</TextBlock>
                </BulletDecorator>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap">Wymagany jest <Run FontWeight="Bold">odpoczynek</Run> (dyżur dzień po dniu jest zabroniony), chyba że na drugi dzień przypada deklaracja <Run FontWeight="Bold">"Bardzo chcę"</Run>.</TextBlock>
                </BulletDecorator>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap">Dyżur nie może sąsiadować z <Run FontWeight="Bold">"Innym dyżurem"</Run> (chyba że występuje "Bardzo chcę").</TextBlock>
                </BulletDecorator>
                <BulletDecorator Margin="20,5,0,0">
                    <BulletDecorator.Bullet>
                        <TextBlock Text="•" Margin="0,0,10,0"/>
                    </BulletDecorator.Bullet>
                    <TextBlock TextWrapping="Wrap">Lekarz może wziąć tylko jeden dyżur z deklaracją <Run FontWeight="Bold">"Mogę warunkowo"</Run>.</TextBlock>
                </BulletDecorator>
            </TextBlock>
        </ScrollViewer>

        <Button Grid.Row="1" Content="Zamknij" IsDefault="True" Click="Zamknij_Click" HorizontalAlignment="Right" Margin="0,15,0,0" Padding="10,5"/>
    </Grid>
</Window>
----- END FILE: GrafikWPF\LogikaSolveraWindow.xaml -----

----- BEGIN FILE: GrafikWPF\LogikaSolveraWindow.xaml.cs -----
using System.Windows;

namespace GrafikWPF
{
    public partial class LogikaSolveraWindow : Window
    {
        public LogikaSolveraWindow()
        {
            InitializeComponent();
            this.Loaded += (s, e) => { this.MaxHeight = SystemParameters.WorkArea.Height; };
        }

        private void Zamknij_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }
    }
}
----- END FILE: GrafikWPF\LogikaSolveraWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\MainWindow.xaml -----
<Window x:Class="GrafikWPF.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GrafikWPF"
        mc:Ignorable="d"
        Title="{Binding DynamicWindowTitle}"
        Background="LightGray"
        StateChanged="MainWindow_StateChanged"
        WindowStartupLocation="CenterScreen"
        MinWidth="1280"
        MinHeight="900">

    <Window.Resources>
        <local:BooleanToVisibilityConverter x:Key="BoolToVis"/>
        <local:InvertedBooleanToVisibilityConverter x:Key="InvertedBoolToVis"/>

        <Style TargetType="Button" x:Key="NavButtonStyle">
            <Setter Property="Width" Value="25"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="VerticalContentAlignment" Value="Center" />
            <Setter Property="Padding" Value="0,0,0,3"/>
        </Style>

        <Style x:Key="SingleClickEditingCellStyle" TargetType="DataGridCell">
            <EventSetter Event="PreviewMouseLeftButtonDown" Handler="DataGridCell_PreviewMouseLeftButtonDown"/>
        </Style>

        <Style x:Key="StaticColumnStyle" TargetType="DataGridCell">
            <Setter Property="Background" Value="#FFCDCDCD"/>
            <Setter Property="Foreground" Value="Black"/>
            <Setter Property="Focusable" Value="False"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="DataGridCell">
                        <Border Background="{TemplateBinding Background}"
                                BorderBrush="Transparent"
                                BorderThickness="0">
                            <ContentPresenter VerticalAlignment="Center" HorizontalAlignment="Center" />
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
            <Style.Triggers>
                <DataTrigger Binding="{Binding RelativeSource={RelativeSource AncestorType=DataGridRow}, Path=Tag}" Value="Holiday">
                    <Setter Property="Background" Value="#FFA0A0A0"/>
                </DataTrigger>
            </Style.Triggers>
        </Style>

        <Style x:Key="CenterVTextBlockStyle" TargetType="TextBlock">
            <Setter Property="VerticalAlignment" Value="Center" />
            <Setter Property="HorizontalAlignment" Value="Center"/>
            <Setter Property="Padding" Value="8,0,8,0"/>
        </Style>
    </Window.Resources>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto" x:Name="DateSelectorRow"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <Menu Grid.Row="0">
            <MenuItem Header="_Plik">
                <MenuItem Header="_Zakończ" Click="Exit_Click"/>
            </MenuItem>
            <MenuItem Header="_Ustawienia">
                <MenuItem Header="_Ustawienia ogólne..." Click="GeneralSettings_Click"/>
                <MenuItem Header="_Zarządzanie dyżurnymi..." Click="SettingsButton_Click"/>
                <MenuItem Header="_Kolejność priorytetów..." Click="PrioritiesSettings_Click"/>
                <MenuItem Header="_Wybór silnika obliczeniowego..." Click="AlgorithmSettings_Click"/>
            </MenuItem>
            <MenuItem Header="_Pomoc">
                <MenuItem Header="_Wyjaśnienie deklaracji" Click="Legenda_Click"/>
                <MenuItem Header="_Logika i strategia działania" Click="Logic_Click"/>
                <MenuItem Header="_Informacje o programie" Click="Info_Click"/>
            </MenuItem>
        </Menu>

        <TextBlock Grid.Row="1" HorizontalAlignment="Center" TextAlignment="Center" Margin="10,20,10,20">
            <Run FontSize="20" FontWeight="Bold">Grafikomat dyżurowy</Run>
            <LineBreak/>
            <Run FontSize="16"><Run.Text><Binding Path="NazwaOddzialuInfo" Mode="OneWay"/></Run.Text></Run>
            <LineBreak/>
            <Run FontSize="16"><Run.Text><Binding Path="NazwaSzpitalaInfo" Mode="OneWay"/></Run.Text></Run>
        </TextBlock>

        <Separator Grid.Row="2" Margin="10,0,10,10"/>

        <StackPanel Grid.Row="3" Orientation="Horizontal" HorizontalAlignment="Center" Margin="10,0,10,10" VerticalAlignment="Center">
            <TextBlock Text="Rok:" VerticalAlignment="Center" Margin="0,0,5,0"/>
            <Button x:Name="PrevYearButton" Content="&lt;" Click="PrevYear_Click" Margin="0,0,5,0" Style="{StaticResource NavButtonStyle}"/>
            <ComboBox x:Name="YearComboBox" Width="100" VerticalContentAlignment="Center"/>
            <Button x:Name="NextYearButton" Content="&gt;" Click="NextYear_Click" Margin="5,0,0,0" Style="{StaticResource NavButtonStyle}"/>

            <TextBlock Text="Miesiąc:" VerticalAlignment="Center" Margin="20,0,5,0"/>
            <Button x:Name="PrevMonthButton" Content="&lt;" Click="PrevMonth_Click" Margin="0,0,5,0" Style="{StaticResource NavButtonStyle}"/>
            <ComboBox x:Name="MonthComboBox" Width="150" VerticalContentAlignment="Center"/>
            <Button x:Name="NextMonthButton" Content="&gt;" Click="NextMonth_Click" Margin="5,0,0,0" Style="{StaticResource NavButtonStyle}"/>
        </StackPanel>

        <Grid Grid.Row="4">
            <Grid x:Name="MainContainer" Visibility="{Binding IsBusy, Converter={StaticResource InvertedBoolToVis}}">
                <Separator VerticalAlignment="Top" Margin="10,0,10,0" />
                <Grid x:Name="TableContainerGrid" Margin="10">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="*"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>

                    <StackPanel Grid.Row="0" x:Name="HeaderAndGridContainer" Orientation="Vertical">
                        <Grid x:Name="UnifiedHeaderGrid" />
                        <Border ClipToBounds="True">
                            <DataGrid x:Name="GrafikGrid"
                                      AutoGenerateColumns="False" 
                                      CanUserSortColumns="False" 
                                      CanUserAddRows="False"
                                      CanUserResizeColumns="False"
                                      HeadersVisibility="None"
                                      SelectionUnit="Cell"
                                      Background="Transparent"
                                      BorderBrush="DarkGray"
                                      GridLinesVisibility="All"
                                      HorizontalGridLinesBrush="DarkGray"
                                      VerticalGridLinesBrush="DarkGray"
                                      BorderThickness="1,0,1,1"/>
                        </Border>
                    </StackPanel>

                    <Grid Grid.Row="1" x:Name="FooterPanel" Margin="0,10,0,0">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>

                        <StackPanel Grid.Column="0" VerticalAlignment="Center" HorizontalAlignment="Left">
                            <TextBlock Text="{Binding SelectedEngineInfo}" TextWrapping="Wrap"/>
                            <TextBlock Text="{Binding PriorityOrderInfo}" TextWrapping="Wrap" Margin="0,2,0,0"/>
                        </StackPanel>

                        <CheckBox x:Name="UnlockEditCheckBox"
                                  Grid.Column="1"
                                  Content="Odblokuj edycję"
                                  VerticalAlignment="Center"
                                  HorizontalAlignment="Center"
                                  Margin="0,0,20,0"
                                  Visibility="Collapsed"
                                  Checked="UnlockEditCheckBox_Changed"
                                  Unchecked="UnlockEditCheckBox_Changed"/>

                        <Button x:Name="ExportButton" Grid.Column="2" Content="Eksportuj grafik..." Click="ExportButton_Click" Padding="10,5" Margin="2">
                            <Button.ContextMenu>
                                <ContextMenu>
                                    <MenuItem Header="Kopiuj listę dyżurnych (format Excel)" Click="KopiujDoSchowka_Click" />
                                    <MenuItem Header="Zapisz jako .pdf" Click="ZapiszJakoPdf_Click" />
                                    <MenuItem Header="Zapisz jako .xlsx" Click="ZapiszJakoXlsx_Click" />
                                </ContextMenu>
                            </Button.ContextMenu>
                        </Button>
                    </Grid>
                </Grid>
            </Grid>

            <Border Background="#99FFFFFF" Visibility="{Binding IsBusy, Converter={StaticResource BoolToVis}}">
                <StackPanel VerticalAlignment="Center" HorizontalAlignment="Center">
                    <ProgressBar IsIndeterminate="{Binding IsProgressIndeterminate}" Value="{Binding GenerationProgress}" Width="250" Height="22" Visibility="{Binding IsBusy, Converter={StaticResource BoolToVis}}"/>
                    <TextBlock Text="{Binding BusyMessage}" Foreground="Black" Margin="0,10,0,0" HorizontalAlignment="Center" FontSize="14"/>

                    <TextBlock Text="{Binding CountdownMessage}" 
                               Foreground="DarkRed" Margin="0,5,0,0" 
                               HorizontalAlignment="Center" FontSize="12" 
                               Visibility="{Binding ShowCountdown, Converter={StaticResource BoolToVis}}"/>

                    <TextBlock Text="{Binding EtaMessage}" 
                               Foreground="DarkBlue" Margin="0,5,0,0" 
                               HorizontalAlignment="Center" FontSize="12" 
                               Visibility="{Binding ShowEta, Converter={StaticResource BoolToVis}}"/>

                    <RichTextBox IsReadOnly="True" Background="Transparent" BorderThickness="0"
                                 Visibility="{Binding IsDeterministicSolverRunning, Converter={StaticResource BoolToVis}}"
                                 FontSize="11" FontStyle="Italic" Foreground="Gray"
                                 TextOptions.TextFormattingMode="Ideal"
                                 MaxWidth="450" Margin="0,10,0,0">
                        <FlowDocument TextAlignment="Center">
                            <Paragraph>
                                <Run>Wybrany silnik,</Run>
                                <Run FontWeight="Bold" Text="{Binding DeterministicSolverName}"/>
                                <Run>, gwarantuje znalezienie najlepszego możliwego wyniku. Jednak jego czas wykonania jest nieprzewidywalny; analiza złożonych danych może uniemożliwić znalezienie rozwiązania w akceptowalnym przez użytkownika czasie.</Run>
                            </Paragraph>
                        </FlowDocument>
                    </RichTextBox>
                    <Button Content="Przerwij" Margin="0,15,0,0" Padding="10,5" Click="CancelButton_Click" Visibility="{Binding IsGenerating, Converter={StaticResource BoolToVis}}"/>
                </StackPanel>
            </Border>
        </Grid>
    </Grid>
</Window>
----- END FILE: GrafikWPF\MainWindow.xaml -----

----- BEGIN FILE: GrafikWPF\MainWindow.xaml.cs -----
using ClosedXML.Excel;
using Microsoft.Win32;
using QuestPDF.Fluent;
using QuestPDF.Helpers;
using QuestPDF.Infrastructure;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Threading;

namespace GrafikWPF
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private bool _isCurrentViewLockedByDefault = false;
        private record PreparedData(DataTable DataTable, Dictionary<string, int> Limity, List<Lekarz> LekarzeAktywni, RozwiazanyGrafik? ZapisanyGrafik);

        private const int MAKS_KOLUMN_LEKARZY = 20;
        private const int GLOBAL_TIMEOUT_SECONDS = 600;
        private readonly List<DataGridTemplateColumn> _doctorColumns = new();
        private Button? _settingsButton;
        private DispatcherTimer _countdownTimer;
        private CancellationTokenSource? _cts;
        private bool _isManualCancellation = false;

        private Dictionary<string, int> _limityDyzurow = new();
        private readonly Dictionary<string, TypDostepnosci> _mapaNazwDostepnosci;
        private readonly Dictionary<TypDostepnosci, string> _mapaDostepnosciDoNazw;
        public List<string> OpcjeDostepnosci { get; }

        private DataTable _grafikDataTable = new();
        private bool _isInitializing = true;
        private bool _grafikZostalWygenerowany = false;
        private TextBlock? _maksDyzurTextBlock;

        private Button? _generateButton;
        private string? _aktualnyKluczMiesiaca;

        private bool _isChangingMonth = false;

        #region INotifyPropertyChanged Properties

        public string NazwaOddzialuInfo
        {
            get { return DataManager.AppData.NazwaOddzialu; }
        }
        public string NazwaSzpitalaInfo
        {
            get { return DataManager.AppData.NazwaSzpitala; }
        }
        public string DynamicWindowTitle
        {
            get { return $":: Grafikomat dyżurowy :: {NazwaOddzialuInfo}, {NazwaSzpitalaInfo}"; }
        }

        private bool _isBusy;
        public bool IsBusy
        {
            get => _isBusy;
            set { _isBusy = value; OnPropertyChanged(); }
        }

        private bool _isGenerating;
        public bool IsGenerating
        {
            get => _isGenerating;
            set { _isGenerating = value; OnPropertyChanged(); }
        }

        private string _busyMessage = "Przetwarzanie...";
        public string BusyMessage
        {
            get => _busyMessage;
            set { _busyMessage = value; OnPropertyChanged(); }
        }

        private double _generationProgress;
        public double GenerationProgress
        {
            get => _generationProgress;
            set { _generationProgress = value; OnPropertyChanged(); }
        }

        private string? _countdownMessage;
        public string? CountdownMessage
        {
            get => _countdownMessage;
            set { _countdownMessage = value; OnPropertyChanged(); }
        }

        private bool _isDeterministicSolverRunning;
        public bool IsDeterministicSolverRunning
        {
            get => _isDeterministicSolverRunning;
            set { _isDeterministicSolverRunning = value; OnPropertyChanged(); }
        }

        private string _deterministicSolverName = "";
        public string DeterministicSolverName
        {
            get => _deterministicSolverName;
            set { _deterministicSolverName = value; OnPropertyChanged(); }
        }

        private string? _selectedEngineInfo;
        public string? SelectedEngineInfo
        {
            get => _selectedEngineInfo;
            set { _selectedEngineInfo = value; OnPropertyChanged(); }
        }

        private string? _priorityOrderInfo;
        public string? PriorityOrderInfo
        {
            get => _priorityOrderInfo;
            set { _priorityOrderInfo = value; OnPropertyChanged(); }
        }

        private bool _isProgressIndeterminate;
        public bool IsProgressIndeterminate
        {
            get => _isProgressIndeterminate;
            set { _isProgressIndeterminate = value; OnPropertyChanged(); }
        }

        private string? _etaMessage;
        public string? EtaMessage
        {
            get => _etaMessage;
            set { _etaMessage = value; OnPropertyChanged(); }
        }

        private bool _showCountdown;
        public bool ShowCountdown
        {
            get => _showCountdown;
            set { _showCountdown = value; OnPropertyChanged(); }
        }

        private bool _showEta;
        public bool ShowEta
        {
            get => _showEta;
            set { _showEta = value; OnPropertyChanged(); }
        }
        #endregion

        public MainWindow()
        {
            InitializeComponent();
            QuestPDF.Settings.License = LicenseType.Community;

            _countdownTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };

            _mapaNazwDostepnosci = new Dictionary<string, TypDostepnosci>
            {
                { "---", TypDostepnosci.Niedostepny }, { "Mogę", TypDostepnosci.Moge },
                { "Chcę", TypDostepnosci.Chce }, { "Bardzo chcę", TypDostepnosci.BardzoChce },
                { "Rezerwacja", TypDostepnosci.Rezerwacja },
                { "Urlop", TypDostepnosci.Urlop }, { "Dyżur (inny)", TypDostepnosci.DyzurInny },
                { "Mogę warunkowo", TypDostepnosci.MogeWarunkowo }
            };
            _mapaDostepnosciDoNazw = _mapaNazwDostepnosci.ToDictionary(kp => kp.Value, kp => kp.Key);

            OpcjeDostepnosci = new List<string>
            {
                "---", "Mogę", "Chcę", "Bardzo chcę", "Rezerwacja",
                "Mogę warunkowo", "Dyżur (inny)", "Urlop"
            };

            InicjalizujStaleKolumnySiatki();

            GrafikGrid.LoadingRow += DataGrid_LoadingRow_Styling;
            this.Loaded += Window_Loaded;
            this.Closing += Window_Closing;
            this.DataContext = this;
        }

        private void RefreshDynamicTitles()
        {
            OnPropertyChanged(nameof(NazwaOddzialuInfo));
            OnPropertyChanged(nameof(NazwaSzpitalaInfo));
            OnPropertyChanged(nameof(DynamicWindowTitle));
        }

        private void UpdateSolverInfo()
        {
            var descriptions = DataManager.AppData.KolejnoscPriorytetowSolvera
                .Select(p => PrioritiesWindow.GetEnumDescription(p));

            var algorytmName = DataManager.AppData.WybranyAlgorytm.ToString() + "Solver";

            SelectedEngineInfo = $"Wybrany silnik: {algorytmName}";
            PriorityOrderInfo = $"Kolejność priorytetów: {string.Join(" > ", descriptions)}";
        }

        private async void Window_Closing(object? sender, CancelEventArgs e)
        {
            await ZapiszBiezacyMiesiac();
            DataManager.SaveData();
        }

        private void Window_Loaded(object? sender, RoutedEventArgs e)
        {
            _isInitializing = true;
            InicjalizujWyborDaty();
            RefreshDynamicTitles();
            _isInitializing = false;
            _ = Dispatcher.BeginInvoke(new Action(async () => await ReloadViewAsync()), DispatcherPriority.ContextIdle);
        }

        private async void DateSelection_Changed(object? sender, SelectionChangedEventArgs? e)
        {
            if (_isInitializing || _isChangingMonth || e?.OriginalSource is not ComboBox)
            {
                return;
            }

            _isChangingMonth = true;

            try
            {
                await ZapiszBiezacyMiesiac();
                await ReloadViewAsync();
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Wystąpił nieoczekiwany błąd podczas zmiany miesiąca. Aplikacja może być w niestabilnym stanie.\n\nSzczegóły techniczne: {ex.Message}",
                                "Błąd krytyczny",
                                MessageBoxButton.OK,
                                MessageBoxImage.Error);
            }
            finally
            {
                _isChangingMonth = false;
            }
        }

        private async Task ReloadViewAsync()
        {
            BusyMessage = "Odświeżanie widoku...";
            IsGenerating = false;
            IsProgressIndeterminate = true;
            IsBusy = true;

            try
            {
                if (YearComboBox.SelectedItem == null || MonthComboBox.SelectedItem == null) return;

                int rok = (int)YearComboBox.SelectedItem;
                int miesiac = MonthComboBox.SelectedIndex + 1;

                await Dispatcher.InvokeAsync(() =>
                {
                    var dzis = DateTime.Today;
                    var wybranaData = new DateTime(rok, miesiac, 1);

                    _isCurrentViewLockedByDefault = (wybranaData.Year < dzis.Year) || (wybranaData.Year == dzis.Year && wybranaData.Month <= dzis.Month);

                    bool shouldCheckboxBeVisible = (wybranaData.Year == dzis.Year && wybranaData.Month == dzis.Month);
                    UnlockEditCheckBox.IsChecked = false;
                    UnlockEditCheckBox.Visibility = shouldCheckboxBeVisible ? Visibility.Visible : Visibility.Collapsed;

                    UpdateSolverInfo();
                });

                var preparedData = await WygenerujDaneWtle(rok, miesiac);

                await Dispatcher.InvokeAsync(() =>
                {
                    _limityDyzurow = preparedData.Limity;
                    _grafikDataTable = preparedData.DataTable;
                    _grafikZostalWygenerowany = preparedData.ZapisanyGrafik != null;

                    GrafikGrid.ItemsSource = null;
                });

                await Dispatcher.InvokeAsync(async () =>
                {
                    await WypelnijNaglowkiDanymiAsync(preparedData.LekarzeAktywni);
                    AktualizujWidokSiatki(preparedData.LekarzeAktywni);
                });

                await Dispatcher.InvokeAsync(() => {
                    GrafikGrid.ItemsSource = _grafikDataTable.DefaultView;
                });

                if (_grafikZostalWygenerowany)
                {
                    await Dispatcher.InvokeAsync(() =>
                    {
                        WyswietlWynikWGrid(preparedData.ZapisanyGrafik!);
                    });
                }

                await Dispatcher.InvokeAsync(() =>
                {
                    UpdateLayoutAndText();
                    SetReadOnlyState();
                }, DispatcherPriority.ContextIdle);

            }
            finally
            {
                IsBusy = false;
            }
        }

        private async Task ZapiszBiezacyMiesiac()
        {
            if (string.IsNullOrEmpty(_aktualnyKluczMiesiaca)) return;

            if (!DataManager.AppData.DaneGrafikow.ContainsKey(_aktualnyKluczMiesiaca))
            {
                DataManager.AppData.DaneGrafikow[_aktualnyKluczMiesiaca] = new DaneMiesiaca();
            }
            var daneMiesiaca = DataManager.AppData.DaneGrafikow[_aktualnyKluczMiesiaca];
            daneMiesiaca.LimityDyzurow = new Dictionary<string, int>(_limityDyzurow);

            if (daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu == null || !daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu.Any())
            {
                daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu = DataManager.AppData.WszyscyLekarze
                    .Where(l => l.IsAktywny)
                    .Select(l => l.Symbol)
                    .ToList();
            }

            var dostepnosc = new Dictionary<DateTime, Dictionary<string, TypDostepnosci>>();
            await Task.Run(() =>
            {
                if (_grafikDataTable == null || _grafikDataTable.Rows.Count == 0) return;

                var symboleAktywnych = daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu ?? new List<string>();
                var lekarzeAktywniDoZapisu = DataManager.AppData.WszyscyLekarze
                                                .Where(l => symboleAktywnych.Contains(l.Symbol))
                                                .OrderBy(l => l.Nazwisko).ThenBy(l => l.Imie)
                                                .ToList();

                foreach (DataRow row in _grafikDataTable.Rows)
                {
                    var data = (DateTime)row["FullDate"];
                    var wpisyDnia = new Dictionary<string, TypDostepnosci>();

                    for (int i = 0; i < lekarzeAktywniDoZapisu.Count; i++)
                    {
                        var lekarz = lekarzeAktywniDoZapisu[i];
                        string nazwaKolumny = $"Lekarz_{i}";
                        if (_grafikDataTable.Columns.Contains(nazwaKolumny))
                        {
                            _mapaNazwDostepnosci.TryGetValue(row[nazwaKolumny].ToString() ?? "---", out var typ);
                            wpisyDnia[lekarz.Symbol] = typ;
                        }
                    }
                    dostepnosc[data] = wpisyDnia;
                }
            });
            daneMiesiaca.Dostepnosc = dostepnosc;
        }

        private async Task<PreparedData> WygenerujDaneWtle(int rok, int miesiac)
        {
            return await Task.Run(() =>
            {
                _aktualnyKluczMiesiaca = $"{rok:D4}-{miesiac:D2}";

                List<Lekarz> lekarzeAktywni;
                DataTable dt;
                Dictionary<string, int> limity;
                RozwiazanyGrafik? zapisanyGrafik = null;

                var dzis = DateTime.Today;
                var wybranaData = new DateTime(rok, miesiac, 1);
                bool czyMiesiacArchiwalny = (wybranaData.Year < dzis.Year) || (wybranaData.Year == dzis.Year && wybranaData.Month < dzis.Month);

                bool daneMiesiacaIstnieja = DataManager.AppData.DaneGrafikow.TryGetValue(_aktualnyKluczMiesiaca, out var daneMiesiaca);

                if (czyMiesiacArchiwalny && daneMiesiacaIstnieja && daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu != null && daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu.Any())
                {
                    var symboleHistoryczne = daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu;
                    lekarzeAktywni = DataManager.AppData.WszyscyLekarze
                        .Where(l => symboleHistoryczne.Contains(l.Symbol))
                        .OrderBy(l => l.Nazwisko).ThenBy(l => l.Imie)
                        .ToList();

                    limity = new Dictionary<string, int>(daneMiesiaca.LimityDyzurow);
                    dt = PrzygotujSiatkeDanychZBiezacychDanych(rok, miesiac, lekarzeAktywni, daneMiesiaca);
                    zapisanyGrafik = daneMiesiaca.ZapisanyGrafik;
                }
                else
                {
                    lekarzeAktywni = DataManager.AppData.WszyscyLekarze
                        .Where(l => l.IsAktywny)
                        .OrderBy(l => l.Nazwisko).ThenBy(l => l.Imie)
                        .ToList();

                    if (daneMiesiaca != null)
                    {
                        daneMiesiaca.SymboleLekarzyAktywnychWMiesiacu = lekarzeAktywni.Select(l => l.Symbol).ToList();
                    }

                    limity = daneMiesiaca != null ? new Dictionary<string, int>(daneMiesiaca.LimityDyzurow) : lekarzeAktywni.ToDictionary(l => l.Symbol, l => 0);
                    dt = daneMiesiaca != null ? PrzygotujSiatkeDanychZBiezacychDanych(rok, miesiac, lekarzeAktywni, daneMiesiaca) : PrzygotujSiatkeDanychNowyMiesiac(rok, miesiac, lekarzeAktywni);
                    zapisanyGrafik = daneMiesiaca?.ZapisanyGrafik;
                }

                return new PreparedData(dt, limity, lekarzeAktywni, zapisanyGrafik);
            });
        }

        private DataTable StworzPustaSiatkeDanych()
        {
            var dt = new DataTable();
            dt.Columns.Add("FullDate", typeof(DateTime));
            dt.Columns.Add("Data", typeof(string));
            for (int i = 0; i < MAKS_KOLUMN_LEKARZY; i++)
            {
                dt.Columns.Add($"Lekarz_{i}", typeof(string));
            }
            dt.Columns.Add("Data_Powtorzona", typeof(string));
            dt.Columns.Add("Wynik", typeof(string));
            dt.Columns.Add("WynikLekarz", typeof(Lekarz));
            return dt;
        }

        private DataTable PrzygotujSiatkeDanychNowyMiesiac(int rok, int miesiac, List<Lekarz> lekarzeAktywni)
        {
            var dt = StworzPustaSiatkeDanych();

            int dniWMiesiacu = DateTime.DaysInMonth(rok, miesiac);
            for (int dzien = 1; dzien <= dniWMiesiacu; dzien++)
            {
                var data = new DateTime(rok, miesiac, dzien);
                var row = dt.NewRow();
                row["FullDate"] = data;
                row["Data"] = data.ToString("dd.MM (dddd)", new CultureInfo("pl-PL"));
                for (int i = 0; i < MAKS_KOLUMN_LEKARZY; i++)
                {
                    row[$"Lekarz_{i}"] = "---";
                }
                row["Data_Powtorzona"] = row["Data"];
                row["WynikLekarz"] = DBNull.Value;
                dt.Rows.Add(row);
            }
            return dt;
        }

        private DataTable PrzygotujSiatkeDanychZBiezacychDanych(int rok, int miesiac, List<Lekarz> lekarzeAktywni, DaneMiesiaca daneMiesiaca)
        {
            var dt = StworzPustaSiatkeDanych();

            int dniWMiesiacu = DateTime.DaysInMonth(rok, miesiac);
            for (int dzien = 1; dzien <= dniWMiesiacu; dzien++)
            {
                var data = new DateTime(rok, miesiac, dzien);
                var row = dt.NewRow();
                row["FullDate"] = data;
                row["Data"] = data.ToString("dd.MM (dddd)", new CultureInfo("pl-PL"));

                if (daneMiesiaca.Dostepnosc != null && daneMiesiaca.Dostepnosc.TryGetValue(data, out var dostepnosciDnia))
                {
                    for (int i = 0; i < lekarzeAktywni.Count; i++)
                    {
                        var lekarz = lekarzeAktywni[i];
                        if (dostepnosciDnia.TryGetValue(lekarz.Symbol, out var typ))
                        {
                            row[$"Lekarz_{i}"] = _mapaDostepnosciDoNazw.GetValueOrDefault(typ, "---");
                        }
                    }
                }

                row["Data_Powtorzona"] = row["Data"];
                row["WynikLekarz"] = DBNull.Value;
                dt.Rows.Add(row);
            }
            return dt;
        }

        private void InicjalizujStaleKolumnySiatki()
        {
            var staticStyle = (Style)this.TryFindResource("StaticColumnStyle");
            var centerTextStyle = (Style)this.TryFindResource("CenterVTextBlockStyle");
            var singleClickStyle = (Style)this.TryFindResource("SingleClickEditingCellStyle");

            GrafikGrid.Columns.Add(new DataGridTextColumn
            {
                Header = null,
                Binding = new Binding("[Data]"),
                IsReadOnly = true,
                Width = new DataGridLength(1.5, DataGridLengthUnitType.Star),
                MinWidth = 130,
                CellStyle = staticStyle,
                ElementStyle = centerTextStyle
            });

            for (int i = 0; i < MAKS_KOLUMN_LEKARZY; i++)
            {
                var templateColumn = new DataGridTemplateColumn
                {
                    Header = "Dyżurny",
                    Width = new DataGridLength(1, DataGridLengthUnitType.Star),
                    CellStyle = singleClickStyle,
                    Visibility = Visibility.Collapsed
                };

                var textFactory = new FrameworkElementFactory(typeof(TextBlock));
                textFactory.SetValue(TextBlock.HorizontalAlignmentProperty, System.Windows.HorizontalAlignment.Center);
                textFactory.SetValue(TextBlock.VerticalAlignmentProperty, System.Windows.VerticalAlignment.Center);
                textFactory.SetBinding(TextBlock.TextProperty, new Binding($"[Lekarz_{i}]"));
                templateColumn.CellTemplate = new DataTemplate { VisualTree = textFactory };

                var comboFactory = new FrameworkElementFactory(typeof(ComboBox));
                comboFactory.SetValue(ComboBox.HorizontalContentAlignmentProperty, System.Windows.HorizontalAlignment.Center);
                comboFactory.SetValue(ComboBox.VerticalContentAlignmentProperty, System.Windows.VerticalAlignment.Center);
                comboFactory.SetValue(ComboBox.IsDropDownOpenProperty, true);
                comboFactory.SetBinding(ItemsControl.ItemsSourceProperty, new Binding("DataContext.OpcjeDostepnosci")
                {
                    RelativeSource = new RelativeSource(RelativeSourceMode.FindAncestor, typeof(Window), 1)
                });
                comboFactory.SetBinding(ComboBox.SelectedItemProperty, new Binding($"[Lekarz_{i}]")
                {
                    Mode = BindingMode.TwoWay,
                    UpdateSourceTrigger = UpdateSourceTrigger.PropertyChanged
                });
                templateColumn.CellEditingTemplate = new DataTemplate { VisualTree = comboFactory };

                _doctorColumns.Add(templateColumn);
                GrafikGrid.Columns.Add(templateColumn);
            }

            GrafikGrid.Columns.Add(new DataGridTextColumn()
            {
                Header = null,
                Binding = new Binding("[Data_Powtorzona]"),
                IsReadOnly = true,
                Width = new DataGridLength(1.5, DataGridLengthUnitType.Star),
                MinWidth = 130,
                CellStyle = staticStyle,
                ElementStyle = centerTextStyle
            });

            GrafikGrid.Columns.Add(new DataGridTextColumn()
            {
                Header = null,
                Binding = new Binding("[Wynik]"),
                IsReadOnly = true,
                Width = new DataGridLength(1.5, DataGridLengthUnitType.Star),
                MinWidth = 130,
                CellStyle = staticStyle,
                ElementStyle = centerTextStyle
            });
        }

        private void AktualizujWidokSiatki(List<Lekarz> lekarzeAktywni)
        {
            for (int i = 0; i < MAKS_KOLUMN_LEKARZY; i++)
            {
                if (i < _doctorColumns.Count)
                {
                    var column = _doctorColumns[i];
                    if (i < lekarzeAktywni.Count)
                    {
                        column.Visibility = Visibility.Visible;
                    }
                    else
                    {
                        column.Visibility = Visibility.Collapsed;
                    }
                }
            }
        }

        private void UpdateLayoutAndText()
        {
            UpdateRowHeights();
            UpdateMaksDyzurText();
            UpdateSettingsButtonText();
            UpdateResultColumnDisplay();
        }

        private void UpdateSettingsButtonText()
        {
            if (_settingsButton == null || GrafikGrid.Columns.Count == 0) return;

            double columnWidth = GrafikGrid.Columns[0].ActualWidth;
            if (columnWidth < 120)
            {
                _settingsButton.Content = "Zarz. dyżurnymi";
            }
            else
            {
                _settingsButton.Content = "Zarządzanie dyżurnymi";
            }
        }

        private void UpdateRowHeights()
        {
            if (!this.IsLoaded || GrafikGrid.Items.Count <= 0) return;
            double headerRowHeight = 35;
            DateSelectorRow.Height = new GridLength(headerRowHeight);

            if (UnifiedHeaderGrid.RowDefinitions.Count > 0)
            {
                UnifiedHeaderGrid.UpdateLayout();
            }

            double headersActualHeight = UnifiedHeaderGrid.ActualHeight;
            double footerHeight = FooterPanel.ActualHeight + FooterPanel.Margin.Top + FooterPanel.Margin.Bottom;

            double containerHeight = TableContainerGrid.ActualHeight;
            double gridRowZeroHeight = containerHeight - footerHeight;

            if (gridRowZeroHeight > headersActualHeight)
            {
                double dataGridAvailableHeight = gridRowZeroHeight - headersActualHeight - 2;
                if (dataGridAvailableHeight > 1)
                {
                    GrafikGrid.RowHeight = dataGridAvailableHeight / GrafikGrid.Items.Count;
                }
            }
        }

        private void UpdateMaksDyzurText()
        {
            if (_maksDyzurTextBlock != null && GrafikGrid.Columns.Count > 0)
            {
                double columnWidth = GrafikGrid.Columns[0].ActualWidth;
                if (columnWidth > 160) _maksDyzurTextBlock.Text = "Maksymalna ilość dyżurów";
                else if (columnWidth > 120) _maksDyzurTextBlock.Text = "Maks. ilość dyżurów";
                else _maksDyzurTextBlock.Text = "Maks. dyżurów";
            }
        }

        private void UpdateResultColumnDisplay()
        {
            if (!GrafikGrid.IsLoaded || _grafikDataTable.Rows.Count == 0 || GrafikGrid.Columns.Count < 1) return;
            var wynikColumn = GrafikGrid.Columns.Last();
            double columnWidth = wynikColumn.ActualWidth - 16;
            bool useSymbol = false;
            if (_grafikZostalWygenerowany)
            {
                foreach (DataRow row in _grafikDataTable.Rows)
                {
                    if (row["WynikLekarz"] is Lekarz lekarz)
                    {
                        var formattedText = new FormattedText(
                            lekarz.PelneImie, CultureInfo.CurrentCulture, FlowDirection.LeftToRight,
                            new Typeface(this.FontFamily, this.FontStyle, this.FontWeight, this.FontStretch),
                            GrafikGrid.FontSize, Brushes.Black, new NumberSubstitution(), 1);
                        if (formattedText.Width > columnWidth)
                        {
                            useSymbol = true;
                            break;
                        }
                    }
                }
            }
            foreach (DataRow row in _grafikDataTable.Rows)
            {
                if (row["WynikLekarz"] is Lekarz lekarz)
                {
                    row["Wynik"] = useSymbol ? lekarz.Symbol : lekarz.PelneImie;
                }
                else
                {
                    row["Wynik"] = _grafikZostalWygenerowany ? "--- BRAK OBSADY ---" : "";
                }
            }
        }

        private void Legenda_Click(object? sender, RoutedEventArgs e)
        {
            var legendaWindow = new LegendaWindow { Owner = this };
            legendaWindow.ShowDialog();
        }

        private void Logic_Click(object sender, RoutedEventArgs e)
        {
            var logicWindow = new LogikaSolveraWindow { Owner = this };
            logicWindow.ShowDialog();
        }

        private void Info_Click(object sender, RoutedEventArgs e)
        {
            var infoWindow = new InfoWindow { Owner = this };
            infoWindow.ShowDialog();
        }

        private void Exit_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        private async void SettingsButton_Click(object? sender, RoutedEventArgs e)
        {
            await ZapiszBiezacyMiesiac();

            var settingsWindow = new UstawieniaLekarzyWindow(DataManager.AppData.WszyscyLekarze) { Owner = this };
            bool? result = settingsWindow.ShowDialog();

            if (result == true)
            {
                var updatedList = settingsWindow.ZaktualizowaniLekarze;
                DataManager.AppData.WszyscyLekarze.Clear();
                DataManager.AppData.WszyscyLekarze.AddRange(updatedList);
                await ReloadViewAsync();
            }
        }

        private void GeneralSettings_Click(object sender, RoutedEventArgs e)
        {
            var settingsWindow = new UstawieniaOgolneWindow(DataManager.AppData) { Owner = this };
            var result = settingsWindow.ShowDialog();
            if (result == true)
            {
                DataManager.AppData.NazwaOddzialu = settingsWindow.NazwaOddzialu;
                DataManager.AppData.NazwaSzpitala = settingsWindow.NazwaSzpitala;
                RefreshDynamicTitles();
            }
        }

        private void PrioritiesSettings_Click(object sender, RoutedEventArgs e)
        {
            var prioritiesWindow = new PrioritiesWindow(DataManager.AppData.KolejnoscPriorytetowSolvera)
            {
                Owner = this
            };
            bool? result = prioritiesWindow.ShowDialog();
            if (result == true)
            {
                DataManager.AppData.KolejnoscPriorytetowSolvera = prioritiesWindow.NewOrder;
                UpdateSolverInfo();
            }
        }

        private void AlgorithmSettings_Click(object sender, RoutedEventArgs e)
        {
            var currentSelection = DataManager.AppData.WybranyAlgorytm;
            var dialog = new WyborAlgorytmuWindow(currentSelection) { Owner = this };

            var result = dialog.ShowDialog();

            if (result == true)
            {
                if (dialog.SelectedAlgorithm != currentSelection)
                {
                    DataManager.AppData.WybranyAlgorytm = dialog.SelectedAlgorithm;
                    UpdateSolverInfo();
                }
            }
        }

        private void InicjalizujWyborDaty()
        {
            for (int rok = DateTime.Now.Year - 5; rok <= DateTime.Now.Year + 5; rok++) YearComboBox.Items.Add(rok);
            for (int i = 1; i <= 12; i++) MonthComboBox.Items.Add(new DateTime(2000, i, 1).ToString("MMMM", new CultureInfo("pl-PL")));

            YearComboBox.SelectionChanged += DateSelection_Changed;
            MonthComboBox.SelectionChanged += DateSelection_Changed;

            var dataStartowa = DateTime.Now.AddMonths(1);
            YearComboBox.SelectedItem = dataStartowa.Year;
            MonthComboBox.SelectedIndex = dataStartowa.Month - 1;
        }

        private async Task WypelnijNaglowkiDanymiAsync(List<Lekarz> lekarzeAktywni)
        {
            UnifiedHeaderGrid.ColumnDefinitions.Clear();
            UnifiedHeaderGrid.RowDefinitions.Clear();
            UnifiedHeaderGrid.Children.Clear();

            UnifiedHeaderGrid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            UnifiedHeaderGrid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            UnifiedHeaderGrid.RowDefinitions.Add(new RowDefinition { Height = GridLength.Auto });
            UnifiedHeaderGrid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(5) });
            UnifiedHeaderGrid.RowDefinitions.Add(new RowDefinition { Height = new GridLength(35) });

            for (int i = 0; i < GrafikGrid.Columns.Count; i++)
            {
                var binding = new Binding($"Columns[{i}].ActualWidth") { Source = GrafikGrid };
                var colDef = new ColumnDefinition();
                BindingOperations.SetBinding(colDef, ColumnDefinition.WidthProperty, binding);
                UnifiedHeaderGrid.ColumnDefinitions.Add(colDef);
            }

            await Dispatcher.Yield(DispatcherPriority.Background);

            _settingsButton = new Button { Content = "Zarządzanie dyżurnymi", Padding = new Thickness(4, 1, 4, 1), Margin = new Thickness(2) };
            _settingsButton.Click += SettingsButton_Click;
            Grid.SetRow(_settingsButton, 0);
            Grid.SetColumn(_settingsButton, 0);
            UnifiedHeaderGrid.Children.Add(_settingsButton);

            for (int i = 0; i < lekarzeAktywni.Count; i++)
            {
                var symbolBlock = new TextBlock { Text = lekarzeAktywni[i].Symbol, FontWeight = FontWeights.Bold, FontSize = 14, HorizontalAlignment = System.Windows.HorizontalAlignment.Center, VerticalAlignment = System.Windows.VerticalAlignment.Center };
                Grid.SetRow(symbolBlock, 0);
                Grid.SetColumn(symbolBlock, i + 1);
                UnifiedHeaderGrid.Children.Add(symbolBlock);
            }

            await Dispatcher.Yield(DispatcherPriority.Background);

            var borderBrush = Brushes.DarkGray;
            var separator = new Border { BorderBrush = borderBrush, BorderThickness = new Thickness(0, 0, 0, 1), Margin = new Thickness(0, 4, 0, 4) };
            Grid.SetRow(separator, 1);
            Grid.SetColumnSpan(separator, UnifiedHeaderGrid.ColumnDefinitions.Count);
            UnifiedHeaderGrid.Children.Add(separator);

            _maksDyzurTextBlock = new TextBlock { Text = "Maks. dyżurów", FontWeight = FontWeights.Bold, HorizontalAlignment = System.Windows.HorizontalAlignment.Center, VerticalAlignment = System.Windows.VerticalAlignment.Center };
            Grid.SetRow(_maksDyzurTextBlock, 2);
            Grid.SetColumn(_maksDyzurTextBlock, 0);
            UnifiedHeaderGrid.Children.Add(_maksDyzurTextBlock);

            for (int i = 0; i < lekarzeAktywni.Count; i++)
            {
                var textBox = new TextBox
                {
                    Text = _limityDyzurow.GetValueOrDefault(lekarzeAktywni[i].Symbol, 0).ToString(),
                    Tag = lekarzeAktywni[i],
                    HorizontalContentAlignment = System.Windows.HorizontalAlignment.Center,
                    VerticalContentAlignment = System.Windows.VerticalAlignment.Center,
                    Width = 45,
                    HorizontalAlignment = System.Windows.HorizontalAlignment.Center,
                    Margin = new Thickness(5, 4, 5, 4),
                    Padding = new Thickness(0, 1, 0, 1)
                };
                textBox.LostFocus += LimitTextBox_LostFocus;
                textBox.PreviewTextInput += LimitTextBox_PreviewTextInput;
                Grid.SetRow(textBox, 2);
                Grid.SetColumn(textBox, i + 1);
                UnifiedHeaderGrid.Children.Add(textBox);
            }

            await Dispatcher.Yield(DispatcherPriority.Background);

            int resultColIndex = 1 + MAKS_KOLUMN_LEKARZY + 1;
            _generateButton = new Button { Content = "Generuj Grafik", Padding = new Thickness(10, 5, 10, 5), Margin = new Thickness(2) };
            _generateButton.Click += new RoutedEventHandler(GenerateButton_Click);
            Grid.SetRow(_generateButton, 2);
            Grid.SetColumn(_generateButton, resultColIndex);
            UnifiedHeaderGrid.Children.Add(_generateButton);

            var mainBarBackground = new SolidColorBrush(System.Windows.Media.Color.FromRgb(79, 79, 79));
            var borderThickness = new Thickness(0, 1, 1, 0);
            var newPadding = new Thickness(0, 8, 0, 8);

            var rowBackground = new Border { Background = mainBarBackground, BorderBrush = borderBrush, BorderThickness = new Thickness(1, 1, 1, 0) };
            Grid.SetRow(rowBackground, 4);
            Grid.SetColumnSpan(rowBackground, UnifiedHeaderGrid.ColumnDefinitions.Count);
            UnifiedHeaderGrid.Children.Add(rowBackground);

            var mainDataHeader = new TextBlock { Text = "Data", FontWeight = FontWeights.Bold, Foreground = Brushes.White, VerticalAlignment = System.Windows.VerticalAlignment.Center, HorizontalAlignment = System.Windows.HorizontalAlignment.Center, Padding = newPadding };
            var mainDataHeaderBorder = new Border { Child = mainDataHeader, BorderBrush = borderBrush, BorderThickness = borderThickness };
            Grid.SetRow(mainDataHeaderBorder, 4);
            Grid.SetColumn(mainDataHeaderBorder, 0);
            UnifiedHeaderGrid.Children.Add(mainDataHeaderBorder);

            if (lekarzeAktywni.Any())
            {
                var mainDeklaracjeHeader = new TextBlock { Text = "Deklaracje dostępności dyżurnych", FontWeight = FontWeights.Bold, Foreground = Brushes.White, VerticalAlignment = System.Windows.VerticalAlignment.Center, HorizontalAlignment = System.Windows.HorizontalAlignment.Center, Padding = newPadding };
                var mainDeklaracjeHeaderBorder = new Border { Child = mainDeklaracjeHeader, BorderBrush = borderBrush, BorderThickness = borderThickness };
                Grid.SetRow(mainDeklaracjeHeaderBorder, 4);
                Grid.SetColumn(mainDeklaracjeHeaderBorder, 1);
                Grid.SetColumnSpan(mainDeklaracjeHeaderBorder, lekarzeAktywni.Count);
                UnifiedHeaderGrid.Children.Add(mainDeklaracjeHeaderBorder);
            }

            int secondDateColIndex = 1 + MAKS_KOLUMN_LEKARZY;
            var secondDataHeader = new TextBlock { Text = "Data", FontWeight = FontWeights.Bold, Foreground = Brushes.White, VerticalAlignment = System.Windows.VerticalAlignment.Center, HorizontalAlignment = System.Windows.HorizontalAlignment.Center, Padding = newPadding };
            var secondDataHeaderBorder = new Border { Child = secondDataHeader, BorderBrush = borderBrush, BorderThickness = borderThickness };
            Grid.SetRow(secondDataHeaderBorder, 4);
            Grid.SetColumn(secondDataHeaderBorder, secondDateColIndex);
            UnifiedHeaderGrid.Children.Add(secondDataHeaderBorder);

            var mainWynikHeader = new TextBlock { Text = "Wynik Grafiku", FontWeight = FontWeights.Bold, Foreground = Brushes.White, VerticalAlignment = System.Windows.VerticalAlignment.Center, HorizontalAlignment = System.Windows.HorizontalAlignment.Center, Padding = newPadding };
            var mainWynikHeaderBorder = new Border { Child = mainWynikHeader, BorderBrush = borderBrush, BorderThickness = borderThickness };
            Grid.SetRow(mainWynikHeaderBorder, 4);
            Grid.SetColumn(mainWynikHeaderBorder, resultColIndex);
            UnifiedHeaderGrid.Children.Add(mainWynikHeaderBorder);
        }

        private void LimitTextBox_LostFocus(object sender, RoutedEventArgs e)
        {
            if (sender is TextBox textBox && textBox.Tag is Lekarz lekarz)
            {
                if (int.TryParse(textBox.Text, out int nowyLimit))
                {
                    if (YearComboBox.SelectedItem is int rok && MonthComboBox.SelectedIndex != -1)
                    {
                        int miesiac = MonthComboBox.SelectedIndex + 1;
                        int dniWMiesiacu = DateTime.DaysInMonth(rok, miesiac);
                        if (nowyLimit > dniWMiesiacu)
                        {
                            MessageBox.Show("Limit dyżurów nie może przekraczać liczby dni w miesiącu.", "Nierealny limit", MessageBoxButton.OK, MessageBoxImage.Information);
                            textBox.Text = _limityDyzurow.GetValueOrDefault(lekarz.Symbol, 0).ToString();
                        }
                        else
                        {
                            _limityDyzurow[lekarz.Symbol] = nowyLimit;
                        }
                    }
                }
                else
                {
                    MessageBox.Show("Proszę wpisać poprawną liczbę.", "Błąd");
                    textBox.Text = _limityDyzurow.GetValueOrDefault(lekarz.Symbol, 0).ToString();
                }
            }
        }

        private void DataGridCell_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (sender is DataGridCell cell && !cell.IsEditing && !cell.IsReadOnly)
            {
                if (!cell.IsFocused) cell.Focus();
                if (FindVisualParent<DataGrid>(cell) is DataGrid dataGrid) dataGrid.BeginEdit(e);
            }
        }

        private async void GenerateButton_Click(object? sender, RoutedEventArgs e)
        {
            var stopwatch = new Stopwatch();
            _isManualCancellation = false;

            // === LOGOWANIE: start po kliknięciu „Generuj Grafik” ===
            try
            {
                SolverDiagnostics.Enabled = true; // włączamy logowanie na czas generowania
                if (!SolverDiagnostics.IsActive) SolverDiagnostics.Start(); // solver wykryje, że log już działa
                SolverDiagnostics.Log("== [UI] Start generowania grafiku ==");
                SolverDiagnostics.LogKeyValue("WybranyAlgorytm", DataManager.AppData.WybranyAlgorytm.ToString());
                var prioDesc = DataManager.AppData.KolejnoscPriorytetowSolvera
                    .Select(p => PrioritiesWindow.GetEnumDescription(p));
                SolverDiagnostics.LogKeyValue("Priorytety", string.Join(" > ", prioDesc));
            }
            catch { /* log jest pomocniczy – nie zatrzymujemy generowania */ }

            await ZapiszBiezacyMiesiac();
            if (string.IsNullOrEmpty(_aktualnyKluczMiesiaca) || !DataManager.AppData.DaneGrafikow.ContainsKey(_aktualnyKluczMiesiaca))
            {
                MessageBox.Show("Brak danych wejściowych dla bieżącego miesiąca. Nie można wygenerować grafiku.", "Brak Danych", MessageBoxButton.OK, MessageBoxImage.Warning);
                try { SolverDiagnostics.Log("== [UI] Przerwano: brak danych wejściowych dla bieżącego miesiąca =="); } catch { }
                try { if (SolverDiagnostics.IsActive) SolverDiagnostics.Stop(); } catch { }
                return;
            }
            if (!_limityDyzurow.Values.Any(limit => limit > 0))
            {
                MessageBox.Show("Żaden z aktywnych lekarzy nie ma określonego limitu dyżurów (wszystkie limity wynoszą 0). Aby wygenerować grafik, przynajmniej jeden lekarz musi mieć limit większy od zera.", "Brak limitów", MessageBoxButton.OK, MessageBoxImage.Warning);
                try { SolverDiagnostics.Log("== [UI] Przerwano: wszystkie limity równe 0 =="); } catch { }
                try { if (SolverDiagnostics.IsActive) SolverDiagnostics.Stop(); } catch { }
                return;
            }

            BusyMessage = "Generowanie grafiku...";
            GenerationProgress = 0;
            IsProgressIndeterminate = false;

            var selectedSolver = DataManager.AppData.WybranyAlgorytm;
            IsDeterministicSolverRunning = selectedSolver == SolverType.Backtracking || selectedSolver == SolverType.AStar;
            DeterministicSolverName = selectedSolver.ToString() + "Solver";

            bool isDeterministic = selectedSolver == SolverType.Backtracking || selectedSolver == SolverType.AStar;
            ShowCountdown = isDeterministic;
            ShowEta = !isDeterministic;

            IsGenerating = true;
            IsBusy = true;

            _cts = new CancellationTokenSource(TimeSpan.FromSeconds(GLOBAL_TIMEOUT_SECONDS));
            int countdown = GLOBAL_TIMEOUT_SECONDS;
            EventHandler? tickHandler = null;
            tickHandler = (s, args) =>
            {
                countdown--;
                if (countdown >= 0)
                {
                    TimeSpan time = TimeSpan.FromSeconds(countdown);
                    CountdownMessage = $"Automatyczne przerwanie za: {time:mm\\:ss}";
                }
            };

            _countdownTimer.Tick += tickHandler;
            TimeSpan initialTime = TimeSpan.FromSeconds(countdown);
            CountdownMessage = $"Automatyczne przerwanie za: {initialTime:mm\\:ss}";
            _countdownTimer.Start();

            RozwiazanyGrafik? wynik = null;
            try
            {
                wynik = await Task.Run(() =>
                {
                    stopwatch.Start();
                    var lekarzeAktywni = DataManager.AppData.WszyscyLekarze.Where(l => l.IsAktywny).ToList();
                    var dostepnosc = DataManager.AppData.DaneGrafikow[_aktualnyKluczMiesiaca].Dostepnosc;
                    var daneDoSilnika = new GrafikWejsciowy { Lekarze = lekarzeAktywni, Dostepnosc = dostepnosc, LimityDyzurow = _limityDyzurow };
                    var progress = new Progress<double>(p =>
                    {
                        GenerationProgress = p * 100;
                        if (ShowEta && p > 0.01)
                        {
                            var elapsed = stopwatch.Elapsed;
                            if (elapsed.TotalMilliseconds > 0)
                            {
                                var totalEstimated = TimeSpan.FromMilliseconds(elapsed.TotalMilliseconds / p);
                                var remaining = totalEstimated - elapsed;
                                if (remaining.TotalSeconds > 0)
                                {
                                    EtaMessage = $"Szacowany czas do końca: {remaining:mm\\:ss}";
                                }
                            }
                        }
                    });

                    SolverDiagnostics.Log("[UI] Uruchamiam ReservationSolverWrapper...");
                    var solver = new ReservationSolverWrapper(selectedSolver, daneDoSilnika, DataManager.AppData.KolejnoscPriorytetowSolvera, progress, _cts.Token);

                    return solver.ZnajdzOptymalneRozwiazanie();
                }, _cts.Token);

                if (wynik != null)
                {
                    DataManager.AppData.DaneGrafikow[_aktualnyKluczMiesiaca].ZapisanyGrafik = wynik;
                    WyswietlWynikWGrid(wynik);
                    try { SolverDiagnostics.Log("[UI] Wynik zapisany do AppData i wyświetlony w gridzie."); } catch { }
                }
            }
            catch (OperationCanceledException)
            {
                if (!_isManualCancellation)
                {
                    HandleTimeout();
                    try { SolverDiagnostics.Log("[UI] Przerwanie: przekroczono globalny limit czasu."); } catch { }
                }
                else
                {
                    ClearResultColumns();
                    try { SolverDiagnostics.Log("[UI] Przerwanie: ręczne anulowanie przez użytkownika."); } catch { }
                }
            }
            catch (AggregateException ae)
            {
                if (ae.Flatten().InnerExceptions.OfType<OperationCanceledException>().Any())
                {
                    if (!_isManualCancellation) { HandleTimeout(); try { SolverDiagnostics.Log("[UI] Przerwanie: przekroczono globalny limit czasu (AggregateException)."); } catch { } }
                    else { ClearResultColumns(); try { SolverDiagnostics.Log("[UI] Przerwanie: ręczne anulowanie (AggregateException)."); } catch { } }
                }
                else
                {
                    var innerEx = ae.Flatten().InnerException;
                    MessageBox.Show($"Wystąpił błąd krytyczny: {innerEx?.Message}", "Błąd krytyczny", MessageBoxButton.OK, MessageBoxImage.Error);
                    try { SolverDiagnostics.LogException(innerEx ?? ae, "[UI] Błąd krytyczny w GenerateButton_Click (AggregateException)"); } catch { }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Wystąpił błąd: {ex.Message}", "Błąd krytyczny", MessageBoxButton.OK, MessageBoxImage.Error);
                try { SolverDiagnostics.LogException(ex, "[UI] Błąd krytyczny w GenerateButton_Click"); } catch { }
            }
            finally
            {
                stopwatch.Stop();
                _countdownTimer.Stop();
                if (tickHandler != null) _countdownTimer.Tick -= tickHandler;
                CountdownMessage = "";
                EtaMessage = "";
                ShowCountdown = false;
                ShowEta = false;
                _isManualCancellation = false;
                IsGenerating = false;
                IsBusy = false;
                IsDeterministicSolverRunning = false;
                _cts?.Dispose();
                _cts = null;

                // === LOGOWANIE: zamknięcie po zakończeniu generowania ===
                try { SolverDiagnostics.Log("== [UI] Koniec generowania (UI) =="); } catch { }
                try { if (SolverDiagnostics.IsActive) SolverDiagnostics.Stop(); } catch { }
            }
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            _isManualCancellation = true;
            _cts?.Cancel();
        }

        private void HandleTimeout() { ClearResultColumns(); var dialog = new TimeoutWindow { Owner = this }; dialog.ShowDialog(); if (dialog.Result == TimeoutWindow.TimeoutResult.ChangeAlgorithm) AlgorithmSettings_Click(this, new RoutedEventArgs()); }
        private void ClearResultColumns() { if (_grafikDataTable == null || _grafikDataTable.Rows.Count == 0) return; foreach (DataRow row in _grafikDataTable.Rows) { row["WynikLekarz"] = DBNull.Value; row["Wynik"] = ""; } _grafikZostalWygenerowany = false; UpdateResultColumnDisplay(); }
        private void WyswietlWynikWGrid(RozwiazanyGrafik wynik) { _grafikZostalWygenerowany = true; foreach (DataRow row in _grafikDataTable.Rows) { DateTime dataWiersza = (DateTime)row["FullDate"]; row["WynikLekarz"] = wynik.Przypisania.TryGetValue(dataWiersza, out Lekarz? l) ? l ?? (object)DBNull.Value : (object)DBNull.Value; } UpdateResultColumnDisplay(); }
        private void DataGrid_LoadingRow_Styling(object? sender, DataGridRowEventArgs e) { if (e.Row.Item is DataRowView rowView && rowView.Row.Table.Columns.Contains("FullDate")) { DateTime date = (DateTime)rowView["FullDate"]; if (date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday || CzyToSwieto(date)) e.Row.Background = new SolidColorBrush(System.Windows.Media.Color.FromRgb(160, 160, 160)); else e.Row.ClearValue(Control.BackgroundProperty); } }
        private bool CzyToSwieto(DateTime data) { int rok = data.Year; DateTime wielkanoc = ObliczWielkanoc(rok); var swieta = new HashSet<DateTime> { new DateTime(rok, 1, 1), new DateTime(rok, 1, 6), wielkanoc, wielkanoc.AddDays(1), new DateTime(rok, 5, 1), new DateTime(rok, 5, 3), wielkanoc.AddDays(49), wielkanoc.AddDays(60), new DateTime(rok, 8, 15), new DateTime(rok, 11, 1), new DateTime(rok, 11, 11), new DateTime(rok, 12, 25), new DateTime(rok, 12, 26) }; return swieta.Contains(data.Date); }
        private DateTime ObliczWielkanoc(int rok) { int a = rok % 19, b = rok / 100, c = rok % 100, d = b / 4, e = b % 4, f = (b + 8) / 25, g = (b - f + 1) / 3, h = (19 * a + b - d - g + 15) % 30, i = c / 4, k = c % 4, l = (32 + 2 * e + 2 * i - h - k) % 7, m = (a + 11 * h + 22 * l) / 451; int miesiac = (h + l - 7 * m + 114) / 31, dzien = ((h + l - 7 * m + 114) % 31) + 1; return new DateTime(rok, miesiac, dzien); }
        public static T? FindVisualParent<T>(DependencyObject child) where T : DependencyObject { DependencyObject parentObject = VisualTreeHelper.GetParent(child); if (parentObject == null) return null; T? parent = parentObject as T; return parent ?? FindVisualParent<T>(parentObject); }
        private void LimitTextBox_PreviewTextInput(object sender, TextCompositionEventArgs e) { if (!char.IsDigit(e.Text, e.Text.Length - 1)) e.Handled = true; }
        private async void KopiujDoSchowka_Click(object sender, RoutedEventArgs e) { if (_grafikDataTable.Rows.Cast<DataRow>().All(r => r["WynikLekarz"] is DBNull)) { MessageBox.Show("Najpierw wygeneruj grafik.", "Brak Danych", MessageBoxButton.OK, MessageBoxImage.Information); return; } var sb = new StringBuilder(); foreach (DataRow row in _grafikDataTable.Rows) { if (row["WynikLekarz"] is Lekarz lekarz) { string initial = !string.IsNullOrEmpty(lekarz.Imie) ? $"{lekarz.Imie[0]}." : ""; sb.AppendLine($"{lekarz.Nazwisko} {initial}".Trim()); } else { sb.AppendLine("--- BRAK OBSADY ---"); } } bool success = await SetClipboardTextWithRetryAsync(sb.ToString()); if (success) { MessageBox.Show("Lista dyżurnych skopiowana.", "Kopiowanie Zakończone", MessageBoxButton.OK, MessageBoxImage.Information); } else { MessageBox.Show("Nie można uzyskać dostępu do schowka.", "Błąd Schowka", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private async Task<bool> SetClipboardTextWithRetryAsync(string text) { const int retries = 10; const int delay = 100; for (int i = 0; i < retries; i++) { try { Clipboard.Clear(); Clipboard.SetText(text); return true; } catch (COMException) { await Task.Delay(delay); } catch (Exception) { return false; } } return false; }
        private void ExportButton_Click(object sender, RoutedEventArgs e) { if (sender is Button button && button.ContextMenu != null) { button.ContextMenu.PlacementTarget = button; button.ContextMenu.IsOpen = true; } }
        private void ZapiszJakoPdf_Click(object sender, RoutedEventArgs e) { if (_grafikDataTable.Rows.Cast<DataRow>().All(r => r["WynikLekarz"] is DBNull)) { MessageBox.Show("Najpierw wygeneruj grafik.", "Brak Danych", MessageBoxButton.OK, MessageBoxImage.Information); return; } var dialog = new SaveFileDialog { Filter = "Plik PDF (*.pdf)|*.pdf", FileName = $"Grafik_{YearComboBox.SelectedItem}_{MonthComboBox.SelectedItem}.pdf" }; if (dialog.ShowDialog() != true) return; try { Document.Create(container => { container.Page(page => { page.Size(PageSizes.A4.Portrait()); page.Margin(20); page.Header().AlignCenter().Column(column => { column.Item().Text("Grafikomat dyżurowy").SemiBold().FontSize(12); column.Item().Text(NazwaOddzialuInfo).Bold().FontSize(16); column.Item().Text(NazwaSzpitalaInfo).FontSize(10); column.Item().PaddingTop(10).Text($"Grafik dyżurów na {MonthComboBox.SelectedItem} {YearComboBox.SelectedItem}").Bold().FontSize(14); }); page.Content().Table(table => { table.ColumnsDefinition(columns => { columns.RelativeColumn(2); columns.RelativeColumn(3); }); table.Header(header => { header.Cell().Background("#2F4F4F").Padding(3).Text("Data").FontColor(QuestPDF.Helpers.Colors.White); header.Cell().Background("#2F4F4F").Padding(3).Text("Dyżurny").FontColor(QuestPDF.Helpers.Colors.White); }); foreach (DataRow dataRow in _grafikDataTable.Rows) { string dyzurny = dataRow["WynikLekarz"] is Lekarz lekarz ? lekarz.PelneImie : "--- BRAK OBSADY ---"; table.Cell().Border(1).Padding(3).Text(dataRow["Data"].ToString()); table.Cell().Border(1).Padding(3).Text(dyzurny); } }); page.Footer().AlignCenter().Text(text => text.Span($"Wygenerowano: {DateTime.Now:yyyy-MM-dd HH:mm}")); }); }).GeneratePdf(dialog.FileName); if (MessageBox.Show($"Pomyślnie zapisano grafik w:\n{dialog.FileName}\n\nCzy chcesz otworzyć plik?", "Eksport Zakończony", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes) OpenFile(dialog.FileName); } catch (Exception ex) { MessageBox.Show($"Błąd tworzenia PDF: {ex.Message}", "Błąd Eksportu", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void ZapiszJakoXlsx_Click(object sender, RoutedEventArgs e) { if (_grafikDataTable.Rows.Cast<DataRow>().All(r => r["WynikLekarz"] is DBNull)) { MessageBox.Show("Najpierw wygeneruj grafik.", "Brak Danych", MessageBoxButton.OK, MessageBoxImage.Information); return; } var dialog = new SaveFileDialog { Filter = "Plik Excel (*.xlsx)|*.xlsx", FileName = $"Grafik_{YearComboBox.SelectedItem}_{MonthComboBox.SelectedItem}.xlsx" }; if (dialog.ShowDialog() != true) return; try { using var workbook = new XLWorkbook(); var worksheet = workbook.Worksheets.Add("Grafik"); worksheet.Cell("A1").Value = "Grafikomat dyżurowy"; worksheet.Cell("A2").Value = NazwaOddzialuInfo; worksheet.Cell("A3").Value = NazwaSzpitalaInfo; worksheet.Cell("A4").Value = $"Grafik dyżurów na {MonthComboBox.SelectedItem} {YearComboBox.SelectedItem}"; worksheet.Range("A1:B1").Merge().Style.Font.Bold = true; worksheet.Range("A2:B2").Merge().Style.Font.Bold = true; worksheet.Range("A3:B3").Merge(); worksheet.Range("A4:B4").Merge().Style.Font.Bold = true; worksheet.Range("A1:A4").Style.Alignment.Horizontal = XLAlignmentHorizontalValues.Center; int tableHeaderRow = 6; worksheet.Cell(tableHeaderRow, 1).Value = "Data"; worksheet.Cell(tableHeaderRow, 2).Value = "Dyżurny"; var headerRow = worksheet.Row(tableHeaderRow); headerRow.Style.Font.Bold = true; headerRow.Style.Fill.BackgroundColor = XLColor.FromHtml("#4F4F4F"); headerRow.Style.Font.FontColor = XLColor.White; int rowIdx = tableHeaderRow + 1; foreach (DataRow dataRow in _grafikDataTable.Rows) { worksheet.Cell(rowIdx, 1).Value = dataRow["Data"].ToString(); string dyzurny = dataRow["WynikLekarz"] is Lekarz lekarz ? lekarz.PelneImie : "--- BRAK OBSADY ---"; worksheet.Cell(rowIdx, 2).Value = dyzurny; rowIdx++; } worksheet.Columns().AdjustToContents(); workbook.SaveAs(dialog.FileName); if (MessageBox.Show($"Pomyślnie zapisano grafik w:\n{dialog.FileName}\n\nCzy chcesz otworzyć plik?", "Eksport Zakończony", MessageBoxButton.YesNo, MessageBoxImage.Question) == MessageBoxResult.Yes) OpenFile(dialog.FileName); } catch (Exception ex) { MessageBox.Show($"Błąd tworzenia Excel: {ex.Message}", "Błąd Eksportu", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenFile(string filePath) { try { new Process { StartInfo = new ProcessStartInfo(filePath) { UseShellExecute = true } }.Start(); } catch (Exception ex) { MessageBox.Show($"Nie można otworzyć pliku: {ex.Message}", "Błąd otwierania", MessageBoxButton.OK, MessageBoxImage.Error); } }
        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? name = null) { PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name)); }
        private void PrevYear_Click(object sender, RoutedEventArgs e) { if (YearComboBox.SelectedIndex > 0) YearComboBox.SelectedIndex--; }
        private void NextYear_Click(object sender, RoutedEventArgs e) { if (YearComboBox.SelectedIndex < YearComboBox.Items.Count - 1) YearComboBox.SelectedIndex++; }
        private void PrevMonth_Click(object sender, RoutedEventArgs e) { if (MonthComboBox.SelectedIndex > 0) MonthComboBox.SelectedIndex--; else if (YearComboBox.SelectedIndex > 0) { YearComboBox.SelectedIndex--; MonthComboBox.SelectedIndex = 11; } }
        private void NextMonth_Click(object sender, RoutedEventArgs e) { if (MonthComboBox.SelectedIndex < MonthComboBox.Items.Count - 1) MonthComboBox.SelectedIndex++; else if (YearComboBox.SelectedIndex < YearComboBox.Items.Count - 1) { YearComboBox.SelectedIndex++; MonthComboBox.SelectedIndex = 0; } }
        private async void MainWindow_StateChanged(object sender, EventArgs e) { if (this.WindowState == WindowState.Minimized || _isBusy) return; await RefreshUILayoutAsync(); }
        private async Task RefreshUILayoutAsync() { if (!_isBusy) { BusyMessage = "Odświeżanie widoku..."; IsGenerating = false; IsBusy = true; await Dispatcher.BeginInvoke(new Action(() => { UpdateLayoutAndText(); IsBusy = false; }), DispatcherPriority.ContextIdle); } }
        private void SetReadOnlyState() { bool isTemporarilyUnlocked = UnlockEditCheckBox.IsChecked == true; bool isEffectivelyLocked = _isCurrentViewLockedByDefault && !isTemporarilyUnlocked; GrafikGrid.IsReadOnly = isEffectivelyLocked; if (_generateButton != null) _generateButton.IsEnabled = !isEffectivelyLocked; foreach (var child in UnifiedHeaderGrid.Children) if (child is TextBox tb && tb.Tag is Lekarz) tb.IsEnabled = !isEffectivelyLocked; }
        private void UnlockEditCheckBox_Changed(object sender, RoutedEventArgs e) { if ((sender as CheckBox)?.IsChecked == true && MessageBox.Show("Uwaga! Edytujesz dane historyczne, które mogą mieć wpływ na przyszłe grafiki. Czy na pewno chcesz kontynuować?", "Potwierdzenie", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) { UnlockEditCheckBox.IsChecked = false; return; } SetReadOnlyState(); }
    }
}

----- END FILE: GrafikWPF\MainWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\PrioritiesWindow.xaml -----
<Window x:Class="GrafikWPF.PrioritiesWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GrafikWPF"
        mc:Ignorable="d"
        Title="Priorytety"
        SizeToContent="Height" Width="650"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="LightGray">
    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Zarządzanie Priorytetami" FontSize="18" FontWeight="Bold" HorizontalAlignment="Center"/>
        <StackPanel Grid.Row="1" Margin="0,10,0,10">
            <TextBlock Text="Przesuwaj elementy na liście, aby ustalić ich ważność. Element na górze listy jest najważniejszy." TextWrapping="Wrap" TextAlignment="Center"/>
            <Separator Margin="0,10,0,5"/>
            <TextBlock Text="Jak to działa?" FontWeight="Bold" TextAlignment="Center"/>
            <TextBlock Margin="0,5,0,0" TextAlignment="Center" TextWrapping="Wrap">
        <Run>Wyobraź sobie, że silnik obliczeniowy programu to menedżer, który musi wybrać lepszy z dwóch grafików. Najpierw zadaje najważniejsze pytanie: 'Który grafik jest lepszy pod kątem Priorytetu 1?'. Jeśli uzyska wyraźną odpowiedź, wybór jest dokonany. Jeśli oba grafiki są tak samo dobre, zadaje kolejne pytanie: 'A który jest lepszy pod kątem Priorytetu 2?'. Ten proces jest kontynuowany w dół listy, aż do znalezienia pierwszej różnicy, która rozstrzyga 'remis'.</Run>
            </TextBlock>
        </StackPanel>
        <Grid Grid.Row="2" Margin="0,10,0,10">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <Border BorderBrush="DarkGray" BorderThickness="1">
                <ListBox x:Name="PrioritiesListBox" ItemsSource="{Binding PriorityList}" SelectedItem="{Binding SelectedPriority}" ScrollViewer.HorizontalScrollBarVisibility="Disabled">
                    <ListBox.ItemTemplate>
                        <DataTemplate>
                            <StackPanel Margin="5">
                                <TextBlock Text="{Binding Name}" FontWeight="Bold" TextWrapping="Wrap"/>
                                <TextBlock Text="{Binding Description}" FontSize="11" Foreground="DarkSlateGray" TextWrapping="Wrap"/>
                            </StackPanel>
                        </DataTemplate>
                    </ListBox.ItemTemplate>
                </ListBox>
            </Border>

            <StackPanel Grid.Column="1" VerticalAlignment="Center" Margin="10,0,0,0">
                <Button x:Name="MoveUpButton" Content="▲ W górę" Margin="0,0,0,5" Padding="10,5" Click="MoveUp_Click"/>
                <Button x:Name="MoveDownButton" Content="▼ W dół" Padding="10,5" Click="MoveDown_Click"/>
            </StackPanel>
        </Grid>

        <Grid Grid.Row="3" Margin="0,15,0,0">
            <Button Content="Przywróć domyślne" HorizontalAlignment="Left" Padding="10,5" Click="RestoreDefaults_Click"/>
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Right">
                <Button Content="Zapisz i Zamknij" IsDefault="True" Click="Save_Click" Margin="0,0,10,0" Padding="10,5"/>
                <Button Content="Anuluj" IsCancel="True" Padding="10,5"/>
            </StackPanel>
        </Grid>
    </Grid>
</Window>
----- END FILE: GrafikWPF\PrioritiesWindow.xaml -----

----- BEGIN FILE: GrafikWPF\PrioritiesWindow.xaml.cs -----
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Windows;

namespace GrafikWPF
{
    public partial class PrioritiesWindow : Window, INotifyPropertyChanged
    {
        public class PriorityItem
        {
            public SolverPriority Priority { get; set; }
            public string Name { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
        }

        public ObservableCollection<PriorityItem> PriorityList { get; set; }
        public List<SolverPriority> NewOrder { get; private set; }

        private PriorityItem? _selectedPriority;
        public PriorityItem? SelectedPriority
        {
            get => _selectedPriority;
            set { _selectedPriority = value; OnPropertyChanged(); UpdateButtonState(); }
        }

        public PrioritiesWindow(List<SolverPriority> currentOrder)
        {
            InitializeComponent();
            this.DataContext = this;

            PriorityList = new ObservableCollection<PriorityItem>();
            NewOrder = new List<SolverPriority>(currentOrder);

            LoadPriorities(currentOrder);
            UpdateItemNames();
        }

        private void LoadPriorities(List<SolverPriority> order)
        {
            PriorityList.Clear();
            var allPriorities = Enum.GetValues(typeof(SolverPriority)).Cast<SolverPriority>();

            foreach (var priority in order)
            {
                if (allPriorities.Contains(priority))
                {
                    PriorityList.Add(CreatePriorityItem(priority));
                }
            }
            foreach (var priority in allPriorities)
            {
                if (!PriorityList.Any(p => p.Priority == priority))
                {
                    PriorityList.Add(CreatePriorityItem(priority));
                }
            }
        }

        private PriorityItem CreatePriorityItem(SolverPriority priority)
        {
            return new PriorityItem
            {
                Priority = priority,
                Name = GetEnumDescription(priority),
                Description = GetEnumLongDescription(priority)
            };
        }

        private void UpdateButtonState()
        {
            if (SelectedPriority != null)
            {
                int index = PriorityList.IndexOf(SelectedPriority);
                MoveUpButton.IsEnabled = index > 0;
                MoveDownButton.IsEnabled = index < PriorityList.Count - 1;
            }
            else
            {
                MoveUpButton.IsEnabled = false;
                MoveDownButton.IsEnabled = false;
            }
        }

        private void UpdateItemNames()
        {
            for (int i = 0; i < PriorityList.Count; i++)
            {
                PriorityList[i].Name = $"Priorytet {i + 1}: {GetEnumDescription(PriorityList[i].Priority)}";
            }
            PrioritiesListBox.Items.Refresh();
        }

        private void MoveUp_Click(object sender, RoutedEventArgs e)
        {
            if (SelectedPriority == null) return;
            int index = PriorityList.IndexOf(SelectedPriority);
            if (index > 0)
            {
                PriorityList.Move(index, index - 1);
                UpdateItemNames();
            }
        }

        private void MoveDown_Click(object sender, RoutedEventArgs e)
        {
            if (SelectedPriority == null) return;
            int index = PriorityList.IndexOf(SelectedPriority);
            if (index < PriorityList.Count - 1)
            {
                PriorityList.Move(index, index + 1);
                UpdateItemNames();
            }
        }

        private void Save_Click(object sender, RoutedEventArgs e)
        {
            NewOrder = PriorityList.Select(p => p.Priority).ToList();
            this.DialogResult = true;
            this.Close();
        }

        private void RestoreDefaults_Click(object sender, RoutedEventArgs e)
        {
            var defaultOrder = new List<SolverPriority>
            {
                SolverPriority.CiagloscPoczatkowa,
                SolverPriority.LacznaLiczbaObsadzonychDni,
                SolverPriority.SprawiedliwoscObciazenia,
                SolverPriority.RownomiernoscRozlozenia
            };
            LoadPriorities(defaultOrder);
            UpdateItemNames();
        }

        public static string GetEnumDescription(Enum value)
        {
            FieldInfo? fi = value.GetType().GetField(value.ToString());
            if (fi == null) return value.ToString();

            DescriptionAttribute[]? attributes = fi.GetCustomAttributes(typeof(DescriptionAttribute), false) as DescriptionAttribute[];
            if (attributes != null && attributes.Any())
            {
                return attributes.First().Description;
            }
            return value.ToString();
        }

        public static string GetEnumLongDescription(SolverPriority priority)
        {
            switch (priority)
            {
                case SolverPriority.CiagloscPoczatkowa:
                    return "Cel: zapewnienie jak najdłuższej nieprzerwanej obsady dyżurów od początku miesiąca.";
                case SolverPriority.LacznaLiczbaObsadzonychDni:
                    return "Cel: zapewnienie jak największej liczby obsadzonych dyżurów w całym miesiącu.";
                case SolverPriority.SprawiedliwoscObciazenia:
                    return "Cel: jak najbardziej sprawiedliwy podział dyżurów, proporcjonalny do zadeklarowanych przez lekarzy limitów.";
                case SolverPriority.RownomiernoscRozlozenia:
                    return "Cel: jak najbardziej regularne rozłożenie dyżurów danego lekarza w czasie (unikanie grupowania dyżurów jednej osoby w krótkim okresie czasu).";
                default:
                    return "";
            }
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? name = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
            UpdateButtonState();
        }
    }
}
----- END FILE: GrafikWPF\PrioritiesWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\RelayCommand.cs -----
using System.Windows.Input;

namespace GrafikWPF
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object?> _execute;
        private readonly Predicate<object?>? _canExecute;

        public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object? parameter) => _canExecute == null || _canExecute(parameter);

        public void Execute(object? parameter) => _execute(parameter);

        public event EventHandler? CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }
}
----- END FILE: GrafikWPF\RelayCommand.cs -----

----- BEGIN FILE: GrafikWPF\ReservationSolverWrapper.cs -----
namespace GrafikWPF
{
    public class ReservationSolverWrapper : IGrafikSolver
    {
        private readonly GrafikWejsciowy _oryginalneDane;
        private readonly IGrafikSolver _wewnetrznySolver;
        private readonly Dictionary<DateTime, Lekarz> _rezerwacje = new();

        public ReservationSolverWrapper(SolverType typSolvera, GrafikWejsciowy daneWejsciowe, List<SolverPriority> kolejnoscPriorytetow, IProgress<double>? progress, CancellationToken token)
        {
            _oryginalneDane = daneWejsciowe;

            // Krok 1: Pre-procesing - znajdź i zweryfikuj rezerwacje
            var (zweryfikowaneRezerwacje, zredukowaneDane) = PrzygotujProblemDlaSolvera(daneWejsciowe);
            _rezerwacje = zweryfikowaneRezerwacje;

            // Krok 2: Stwórz właściwy solver, który zajmie się resztą problemu
            _wewnetrznySolver = SolverFactory.CreateSolver(typSolvera, zredukowaneDane, kolejnoscPriorytetow, progress, token);
        }

        private (Dictionary<DateTime, Lekarz> rezerwacje, GrafikWejsciowy zredukowaneDane) PrzygotujProblemDlaSolvera(GrafikWejsciowy dane)
        {
            var rezerwacje = new Dictionary<DateTime, Lekarz>();
            var zredukowaneDni = new Dictionary<DateTime, Dictionary<string, TypDostepnosci>>();
            var zredukowaneLimity = new Dictionary<string, int>(dane.LimityDyzurow);

            // Znajdź wszystkie rezerwacje
            foreach (var dzien in dane.DniWMiesiacu)
            {
                foreach (var lekarz in dane.Lekarze)
                {
                    if (dane.Dostepnosc[dzien].GetValueOrDefault(lekarz.Symbol) == TypDostepnosci.Rezerwacja)
                    {
                        rezerwacje.Add(dzien, lekarz);
                        break;
                    }
                }
            }

            // Zweryfikuj spójność rezerwacji i zredukuj limity
            var rezerwacjeLekarza = rezerwacje.GroupBy(r => r.Value.Symbol)
                                              .ToDictionary(g => g.Key, g => g.OrderBy(kv => kv.Key).ToList());

            foreach (var para in rezerwacjeLekarza)
            {
                var symbolLekarza = para.Key;
                var jegoRezerwacje = para.Value;

                // Sprawdź, czy liczba rezerwacji nie przekracza limitu
                if (jegoRezerwacje.Count > zredukowaneLimity.GetValueOrDefault(symbolLekarza, 0))
                {
                    throw new InvalidOperationException($"Błąd w danych wejściowych: Lekarz {symbolLekarza} ma {jegoRezerwacje.Count} rezerwacji, a jego limit dyżurów to {zredukowaneLimity.GetValueOrDefault(symbolLekarza, 0)}.");
                }
                zredukowaneLimity[symbolLekarza] -= jegoRezerwacje.Count;

                // Sprawdź konflikty między samymi rezerwacjami (np. dzień po dniu)
                for (int i = 0; i < jegoRezerwacje.Count - 1; i++)
                {
                    var obecnyDzien = jegoRezerwacje[i].Key;
                    var nastepnyDzien = jegoRezerwacje[i + 1].Key;
                    if ((nastepnyDzien - obecnyDzien).TotalDays == 1)
                    {
                        // Wyjątek tylko dla "Bardzo Chcę" - Rezerwacja nie jest wyjątkiem
                        throw new InvalidOperationException($"Błąd w danych wejściowych: Lekarz {symbolLekarza} ma dwie rezerwacje dzień po dniu ({obecnyDzien:dd.MM} i {nastepnyDzien:dd.MM}), co łamie zasadę odpoczynku.");
                    }
                }
            }

            // Stwórz zredukowany problem (tylko dni bez rezerwacji)
            foreach (var dzien in dane.DniWMiesiacu)
            {
                if (!rezerwacje.ContainsKey(dzien))
                {
                    zredukowaneDni.Add(dzien, dane.Dostepnosc[dzien]);
                }
            }

            return (rezerwacje, new GrafikWejsciowy
            {
                Lekarze = dane.Lekarze,
                Dostepnosc = zredukowaneDni,
                LimityDyzurow = zredukowaneLimity
            });
        }


        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            // Krok 3: Uruchom właściwy solver na zredukowanym problemie
            var wynikCzesciowy = _wewnetrznySolver.ZnajdzOptymalneRozwiazanie();

            // Krok 4: Scal wyniki - połącz przydzielone rezerwacje z grafikiem wygenerowanym przez solver
            var finalnePrzypisania = new Dictionary<DateTime, Lekarz?>(_rezerwacje.ToDictionary(kvp => kvp.Key, kvp => (Lekarz?)kvp.Value));
            foreach (var przypisanie in wynikCzesciowy.Przypisania)
            {
                finalnePrzypisania[przypisanie.Key] = przypisanie.Value;
            }

            // Przelicz metryki na nowo dla pełnego, scalonego grafiku
            var finalneOblozenie = _oryginalneDane.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            foreach (var przypisanie in finalnePrzypisania.Values)
            {
                if (przypisanie != null) finalneOblozenie[przypisanie.Symbol]++;
            }

            return EvaluationAndScoringService.CalculateMetrics(finalnePrzypisania, finalneOblozenie, _oryginalneDane);
        }
    }
}
----- END FILE: GrafikWPF\ReservationSolverWrapper.cs -----

----- BEGIN FILE: GrafikWPF\RozwiazanyGrafik.cs -----
namespace GrafikWPF
{
    public class RozwiazanyGrafik
    {
        public Dictionary<DateTime, Lekarz?> Przypisania { get; set; } = new();
        public int DlugoscCiaguPoczatkowego { get; set; }
        public int LiczbaDniObsadzonych => Przypisania.Values.Count(l => l != null);

        public int ZrealizowaneRezerwacje { get; set; }
        public int ZrealizowaneBardzoChce { get; set; }
        public int ZrealizowaneChce { get; set; }
        public int ZrealizowaneMoge { get; set; }

        public double WskaznikRownomiernosci { get; set; }
        public double WskaznikRozlozeniaDyzurow { get; set; }

        public Dictionary<string, int> FinalneOblozenieLekarzy { get; set; } = new();
    }
}
----- END FILE: GrafikWPF\RozwiazanyGrafik.cs -----

----- BEGIN FILE: GrafikWPF\SchedulingRules.cs -----
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;

namespace GrafikWPF
{
    /// <summary>
    /// Wspólne zasady dla wszystkich solverów (Backtracking, A*, metaheurystyki).
    /// - BC (BardzoChce) może łamać: (a) zakaz dzień-po-dniu, (b) zakaz sąsiedztwa z „Dyżur (inny)”.
    /// - MW (Mogę warunkowo): co najwyżej 1/miesiąc na lekarza (nie jest obowiązkowy).
    /// - „Rezerwowanie” przyszłych CH/BC: tylko, gdy są „unikalne” (dzień ma ≤1 realnego kandydata CH/BC).
    /// - Priorytety użytkownika sterują kolejnością sortowania kandydatów i polityką rezerw (OFF/SOFT/HARD).
    /// - Ocena rozwiązania: (1) maks. obsada, (2) ciągłość prefiksu, (3) sprawiedliwość ∝ limitom,
    ///   (4) równomierność (karzemy skupiska).
    /// </summary>
    public static class SchedulingRules
    {
        public const int UNASSIGNED = int.MinValue;

        public enum ReservePolicy { Off, Soft, Hard }

        // „Jak bardzo wyjątkowe” muszą być przyszłe CH/BC, by je chronić (1 = unikalne)
        private const int UNIQUE_CHBC_THRESHOLD = 1;

        public sealed class Context
        {
            public IReadOnlyList<DateTime> Days { get; }
            public IReadOnlyList<Lekarz> Doctors { get; }
            public IReadOnlyDictionary<DateTime, Dictionary<string, TypDostepnosci>> Avail { get; }
            public IReadOnlyDictionary<string, int> LimitsBySymbol { get; }
            public IReadOnlyList<SolverPriority> Priorities { get; }

            // Stan (uzupełnia solver):
            public int[] Assign;  // dzień -> idx lekarza; UNASSIGNED=nieobsadzone, -1=PUSTO
            public int[] Work;    // ile dyżurów ma lekarz
            public int[] MwUsed;  // zużycia MW
            public bool IsPrefixActive;

            // Wygody:
            public readonly int Dn, Pn;
            public readonly Dictionary<string, int> DocIndexBySymbol;

            public Context(
                IReadOnlyList<DateTime> days,
                IReadOnlyList<Lekarz> doctors,
                IReadOnlyDictionary<DateTime, Dictionary<string, TypDostepnosci>> avail,
                IReadOnlyDictionary<string, int> limits,
                IReadOnlyList<SolverPriority> priorities,
                int[] assign,
                int[] work,
                int[] mwUsed,
                bool isPrefixActive)
            {
                Days = days;
                Doctors = doctors;
                Avail = avail;
                LimitsBySymbol = limits;
                Priorities = priorities;

                Assign = assign;
                Work = work;
                MwUsed = mwUsed;
                IsPrefixActive = isPrefixActive;

                Dn = days.Count;
                Pn = doctors.Count;
                DocIndexBySymbol = new Dictionary<string, int>(Pn);
                for (int i = 0; i < Pn; i++) DocIndexBySymbol[doctors[i].Symbol] = i;
            }

            public int LimitOf(int doc) =>
                LimitsBySymbol.TryGetValue(Doctors[doc].Symbol, out var lim) ? lim : Dn;

            public TypDostepnosci Av(int day, int doc)
            {
                if (!Avail.TryGetValue(Days[day], out var map)) return TypDostepnosci.Niedostepny;
                return map.TryGetValue(Doctors[doc].Symbol, out var t) ? t : TypDostepnosci.Niedostepny;
            }

            public int EarliestUnassigned()
            {
                for (int d = 0; d < Dn; d++) if (Assign[d] == UNASSIGNED) return d;
                return -1;
            }
        }

        // ================== Twarde reguły ==================
        public static bool IsHardFeasible(int day, int doc, Context ctx)
        {
            if (doc < 0 || doc >= ctx.Pn) return false;
            if (day < 0 || day >= ctx.Dn) return false;

            if (ctx.Work[doc] >= ctx.LimitOf(doc)) return false;

            var av = ctx.Av(day, doc);

            // Wykluczenia bezwzględne
            if (av is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny)
                return false;

            bool isBC = av == TypDostepnosci.BardzoChce;

            // Zakaz dzień-po-dniu (BC może łamać)
            if (!isBC)
            {
                if (day > 0 && ctx.Assign[day - 1] == doc) return false;
                if (day + 1 < ctx.Dn && ctx.Assign[day + 1] == doc) return false;
            }

            // Zakaz sąsiedztwa z „Inny dyżur” (BC może łamać)
            if (!isBC && IsNextToOtherDuty(day, doc, ctx)) return false;

            // MW – maks. 1 na lekarza (nie wymuszamy użycia)
            if (av == TypDostepnosci.MogeWarunkowo && ctx.MwUsed[doc] >= 1) return false;

            return true;
        }

        private static bool IsNextToOtherDuty(int day, int doc, Context ctx)
        {
            var sym = ctx.Doctors[doc].Symbol;
            if (day > 0)
            {
                var m = ctx.Avail[ctx.Days[day - 1]];
                if (m.TryGetValue(sym, out var t) && t == TypDostepnosci.DyzurInny) return true;
            }
            if (day + 1 < ctx.Dn)
            {
                var m = ctx.Avail[ctx.Days[day + 1]];
                if (m.TryGetValue(sym, out var t) && t == TypDostepnosci.DyzurInny) return true;
            }
            return false;
        }

        // ================== Polityka rezerw CH/BC ==================
        public static ReservePolicy GetReservePolicy(int day, Context ctx)
        {
            var p1 = ctx.Priorities.Count > 0 ? ctx.Priorities[0] : SolverPriority.LacznaLiczbaObsadzonychDni;

            bool nextLooksBad = !NextDayHasAnyCandidateLoose(day, ctx);

            return p1 switch
            {
                SolverPriority.CiagloscPoczatkowa => (ctx.IsPrefixActive && day == ctx.EarliestUnassigned())
                                                      ? (nextLooksBad ? ReservePolicy.Hard : ReservePolicy.Off)
                                                      : ReservePolicy.Hard,
                SolverPriority.LacznaLiczbaObsadzonychDni => nextLooksBad ? ReservePolicy.Off : ReservePolicy.Soft,
                SolverPriority.SprawiedliwoscObciazenia => ReservePolicy.Soft,
                SolverPriority.RownomiernoscRozlozenia => ReservePolicy.Soft,
                _ => ReservePolicy.Soft,
            };
        }

        // HARD filtruje MG/MW tylko, gdy zjadają „unikalne” przyszłe CH/BC
        public static bool WouldStealFromFutureUniqueChBc(int day, int doc, Context ctx)
        {
            var avToday = ctx.Av(day, doc);
            if (avToday != TypDostepnosci.Moge && avToday != TypDostepnosci.MogeWarunkowo)
                return false;

            int uniqueNeed = CountFutureUniqueChBc(day, doc, ctx);
            int remainingAfter = ctx.LimitOf(doc) - ctx.Work[doc] - 1;
            return remainingAfter < uniqueNeed;
        }

        private static int CountFutureUniqueChBc(int fromDay, int doc, Context ctx)
        {
            int count = 0;
            for (int d = fromDay + 1; d < ctx.Dn; d++)
            {
                if (ctx.Assign[d] != UNASSIGNED) continue;
                var avDoc = ctx.Av(d, doc);
                bool isChBcHere = avDoc is TypDostepnosci.Chce or TypDostepnosci.BardzoChce;
                if (!isChBcHere) continue;

                // policz ilu realnych kandydatów CH/BC ma ten dzień
                int feasibleChBc = 0;
                for (int q = 0; q < ctx.Pn; q++)
                {
                    var av = ctx.Av(d, q);
                    if (av is not (TypDostepnosci.Chce or TypDostepnosci.BardzoChce)) continue;

                    bool isBC = av == TypDostepnosci.BardzoChce;
                    // lokalna wykonalność: dzień-po-dniu i Inny dyżur (BC może łamać)
                    if (!isBC)
                    {
                        if (d > 0 && ctx.Assign[d - 1] == q) continue;
                        if (d + 1 < ctx.Dn && ctx.Assign[d + 1] == q) continue;
                    }
                    if (!isBC && IsNextToOtherDuty(d, q, ctx)) continue;

                    feasibleChBc++;
                    if (feasibleChBc > UNIQUE_CHBC_THRESHOLD) break;
                }

                if (feasibleChBc <= UNIQUE_CHBC_THRESHOLD)
                    count++;
            }
            return count;
        }

        private static bool NextDayHasAnyCandidateLoose(int day, Context ctx)
        {
            int dn = day + 1;
            if (dn >= ctx.Dn) return true;
            if (ctx.Assign[dn] != UNASSIGNED) return true;
            for (int q = 0; q < ctx.Pn; q++)
                if (IsHardFeasible(dn, q, ctx)) return true;
            return false;
        }

        // ================== Prefiks: patrzymy kilka dni do przodu ==================
        /// <summary>
        /// Przybliżona długość ciągłego prefiksu, jeśli dziś wybierzemy „doc”.
        /// Szybkie okno look-ahead (domyślnie 4 dni).
        /// </summary>
        public static int ContinuityLookaheadSpan(int day, int doc, Context ctx, int window = 4)
        {
            int end = Math.Min(ctx.Dn - 1, day + window);
            // dziś: sprawdzamy, czy doc jest w ogóle legalny (tu heavy check robi solver)
            int span = 1;

            for (int d = day + 1; d <= end; d++)
            {
                if (ctx.Assign[d] != UNASSIGNED) { span++; continue; }

                bool feasibleThere = false;
                for (int q = 0; q < ctx.Pn; q++)
                {
                    // wpływ dzisiejszego wyboru: sąsiedztwo tylko dla q==doc i d==day+1
                    if (q == doc && d == day + 1)
                    {
                        var av0 = ctx.Av(day, doc);
                        if (!IsHardFeasibleWithHypo(d, q, day, doc, av0, ctx)) continue;
                        feasibleThere = true; break;
                    }
                    else
                    {
                        if (IsHardFeasible(d, q, ctx)) { feasibleThere = true; break; }
                    }
                }

                if (!feasibleThere) break;
                span++;
            }
            return span;
        }

        private static bool IsHardFeasibleWithHypo(int dayToCheck, int cand, int hypoDay, int hypoDoc, TypDostepnosci hypoAv, Context ctx)
        {
            if (ctx.Work[cand] >= ctx.LimitOf(cand)) return false;

            var av = ctx.Av(dayToCheck, cand);
            if (av is TypDostepnosci.Niedostepny or TypDostepnosci.Urlop or TypDostepnosci.DyzurInny)
                return false;

            bool isBC = av == TypDostepnosci.BardzoChce;

            // hipotetyczne dzień-po-dniu z wyborem w hypoDay (BC może łamać)
            if (!isBC && cand == hypoDoc && Math.Abs(dayToCheck - hypoDay) == 1)
                return false;

            if (!isBC && IsNextToOtherDuty(dayToCheck, cand, ctx))
                return false;

            int mw = ctx.MwUsed[cand];
            if (cand == hypoDoc && hypoAv == TypDostepnosci.MogeWarunkowo) mw++;
            if (av == TypDostepnosci.MogeWarunkowo && mw >= 1) return false;

            return true;
        }

        // ================== Porządkowanie i ocena ==================
        public static List<int> OrderCandidates(int day, Context ctx)
        {
            var policy = GetReservePolicy(day, ctx);
            var legal = new List<int>(ctx.Pn);
            for (int p = 0; p < ctx.Pn; p++)
                if (IsHardFeasible(day, p, ctx)) legal.Add(p);

            if (legal.Count == 0) return legal;

            if (policy == ReservePolicy.Hard)
            {
                legal = legal.Where(p =>
                {
                    var av = ctx.Av(day, p);
                    if (av == TypDostepnosci.Moge || av == TypDostepnosci.MogeWarunkowo)
                        return !WouldStealFromFutureUniqueChBc(day, p, ctx);
                    return true;
                }).ToList();
            }

            legal.Sort((a, b) => CompareCandidates(day, a, b, policy, ctx));
            return legal;
        }

        private static int CompareCandidates(int day, int a, int b, ReservePolicy policy, Context ctx)
        {
            var avA = ctx.Av(day, a);
            var avB = ctx.Av(day, b);

            // Rezerwacja zawsze pierwsza
            int rzA = avA == TypDostepnosci.Rezerwacja ? 1 : 0;
            int rzB = avB == TypDostepnosci.Rezerwacja ? 1 : 0;
            if (rzA != rzB) return rzB.CompareTo(rzA);

            foreach (var pr in ctx.Priorities)
            {
                int cmp = 0;
                switch (pr)
                {
                    case SolverPriority.CiagloscPoczatkowa:
                        int spanA = ContinuityLookaheadSpan(day, a, ctx, window: 4);
                        int spanB = ContinuityLookaheadSpan(day, b, ctx, window: 4);
                        cmp = spanB.CompareTo(spanA); // większy span lepiej
                        if (cmp != 0) return cmp;
                        break;

                    case SolverPriority.SprawiedliwoscObciazenia:
                        double ra = RatioAfter(a, ctx);
                        double rb = RatioAfter(b, ctx);
                        cmp = ra.CompareTo(rb); // mniejszy lepszy
                        if (cmp != 0) return cmp;
                        break;

                    case SolverPriority.RownomiernoscRozlozenia:
                        int da = NearestAssignedDistance(day, a, ctx);
                        int db = NearestAssignedDistance(day, b, ctx);
                        cmp = db.CompareTo(da); // większy dystans lepiej
                        if (cmp != 0) return cmp;
                        break;

                    case SolverPriority.LacznaLiczbaObsadzonychDni:
                        // brak lokalnego rozróżnienia – przechodzimy dalej
                        break;
                }
            }

            if (policy == ReservePolicy.Soft)
            {
                int pa = PrefRank(avA), pb = PrefRank(avB);
                if (pa != pb) return pb.CompareTo(pa);
            }

            int wCmp = ctx.Work[a].CompareTo(ctx.Work[b]);
            if (wCmp != 0) return wCmp;

            int remA = ctx.LimitOf(a) - ctx.Work[a];
            int remB = ctx.LimitOf(b) - ctx.Work[b];
            int remCmp = remB.CompareTo(remA);
            if (remCmp != 0) return remCmp;

            int prefCmp = PrefRank(avB).CompareTo(PrefRank(avA));
            if (prefCmp != 0) return prefCmp;

            return a.CompareTo(b);
        }

        public static long[] EvaluateSolution(RozwiazanyGrafik sol, IReadOnlyList<SolverPriority> priorities, Context ctx)
        {
            var perDoc = new int[ctx.Pn];
            int assigned = 0;
            for (int d = 0; d < ctx.Dn; d++)
            {
                var date = ctx.Days[d];
                if (!sol.Przypisania.TryGetValue(date, out var l) || l is null) continue;
                assigned++;
                if (ctx.DocIndexBySymbol.TryGetValue(l.Symbol, out var idx)) perDoc[idx]++;
            }

            long sObs = assigned;

            long sCont = 0;
            for (int d = 0; d < ctx.Dn; d++)
            {
                var date = ctx.Days[d];
                if (!sol.Przypisania.TryGetValue(date, out var l) || l is null) break;
                sCont++;
            }

            long sFair = ComputeProportionalFairness(perDoc, assigned, ctx);
            long sEven = ComputeEvenness(sol, ctx);

            var map = new Dictionary<SolverPriority, long>
            {
                { SolverPriority.LacznaLiczbaObsadzonychDni, sObs },
                { SolverPriority.CiagloscPoczatkowa, sCont },
                { SolverPriority.SprawiedliwoscObciazenia, sFair },
                { SolverPriority.RownomiernoscRozlozenia, sEven }
            };

            var vec = new long[priorities.Count];
            for (int i = 0; i < priorities.Count; i++)
                vec[i] = map.TryGetValue(priorities[i], out var v) ? v : 0;
            return vec;
        }

        // ======= drobne narzędzia =======
        private static int PrefRank(TypDostepnosci a) => a switch
        {
            TypDostepnosci.Rezerwacja => 5,
            TypDostepnosci.BardzoChce => 4,
            TypDostepnosci.Chce => 3,
            TypDostepnosci.Moge => 2,
            TypDostepnosci.MogeWarunkowo => 1,
            _ => 0
        };

        private static double RatioAfter(int doc, Context ctx)
        {
            double lim = Math.Max(1, ctx.LimitOf(doc));
            return (ctx.Work[doc] + 1) / lim;
        }

        private static int NearestAssignedDistance(int day, int doc, Context ctx)
        {
            int best = int.MaxValue;
            for (int d = day - 1; d >= 0; d--)
                if (ctx.Assign[d] == doc) { best = Math.Min(best, day - d); break; }
            for (int d = day + 1; d < ctx.Dn; d++)
                if (ctx.Assign[d] == doc) { best = Math.Min(best, d - day); break; }
            return best == int.MaxValue ? 9999 : best;
        }

        private static long ComputeProportionalFairness(int[] perDoc, int total, Context ctx)
        {
            if (total <= 0) return 0;
            long sumLim = 0;
            var L = new long[ctx.Pn];
            for (int i = 0; i < ctx.Pn; i++) { L[i] = Math.Max(0, ctx.LimitOf(i)); sumLim += L[i]; }
            if (sumLim <= 0) return 0;

            double sumAbs = 0.0;
            for (int i = 0; i < ctx.Pn; i++)
            {
                double expected = total * (L[i] / (double)sumLim);
                sumAbs += Math.Abs(perDoc[i] - expected);
            }
            return -(long)Math.Round(sumAbs * 1000.0); // większe = lepsze
        }

        private static long ComputeEvenness(RozwiazanyGrafik sol, Context ctx)
        {
            var perDayDoc = new int[ctx.Dn];
            Array.Fill(perDayDoc, -1);
            for (int d = 0; d < ctx.Dn; d++)
            {
                var date = ctx.Days[d];
                if (!sol.Przypisania.TryGetValue(date, out var l) || l is null) continue;
                if (ctx.DocIndexBySymbol.TryGetValue(l.Symbol, out var idx))
                    perDayDoc[d] = idx;
            }
            int penalty = 0;
            for (int d = 0; d < ctx.Dn; d++)
            {
                int p = perDayDoc[d];
                if (p < 0) continue;
                if (d > 0 && perDayDoc[d - 1] == p) penalty++;
                if (d + 1 < ctx.Dn && perDayDoc[d + 1] == p) penalty++;
            }
            return -penalty; // większe = lepsze
        }
    }
}

----- END FILE: GrafikWPF\SchedulingRules.cs -----

----- BEGIN FILE: GrafikWPF\SimulatedAnnealingSolver.cs -----
namespace GrafikWPF
{
    public class SimulatedAnnealingSolver : IGrafikSolver
    {
        private const double InitialTemperature = 1000.0;
        private const double CoolingRate = 0.995;
        private readonly int _iterationsPerTemperature;

        private readonly GrafikWejsciowy _daneWejsciowe;
        private readonly List<SolverPriority> _kolejnoscPriorytetow;
        private readonly IProgress<double>? _progressReporter;
        private readonly CancellationToken _cancellationToken;
        private readonly Random _random = new();
        private readonly SolverUtility _utility;

        public SimulatedAnnealingSolver(GrafikWejsciowy daneWejsciowe, List<SolverPriority> kolejnoscPriorytetow, IProgress<double>? progress = null, CancellationToken cancellationToken = default)
        {
            _daneWejsciowe = daneWejsciowe;
            _kolejnoscPriorytetow = kolejnoscPriorytetow;
            _progressReporter = progress;
            _cancellationToken = cancellationToken;
            _utility = new SolverUtility(daneWejsciowe);
            _iterationsPerTemperature = Math.Max(100, _daneWejsciowe.Lekarze.Count * 10);
        }

        private double CalculateAdaptiveScore(RozwiazanyGrafik grafik, double temperature)
        {
            double progress = 1.0 - (Math.Log(temperature) / Math.Log(InitialTemperature));
            int prioritiesToConsider = 1 + (int)(progress * (_kolejnoscPriorytetow.Count - 1));
            var adaptivePriorities = _kolejnoscPriorytetow.Take(prioritiesToConsider).ToList();
            return EvaluationAndScoringService.CalculateScore(grafik, adaptivePriorities, _daneWejsciowe);
        }

        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            // ZMIANA: Zaczynamy od rozwiązania "chciwego", a nie w pełni losowego.
            var currentSolution = _utility.StworzChciweRozwiazaniePoczatkowe();
            var bestSolution = new Dictionary<DateTime, Lekarz?>(currentSolution);

            var currentMetrics = EvaluationAndScoringService.CalculateMetrics(currentSolution, _utility.ObliczOblozenie(currentSolution), _daneWejsciowe);
            double bestFitness = EvaluationAndScoringService.CalculateScore(currentMetrics, _kolejnoscPriorytetow, _daneWejsciowe);
            double currentFitness = CalculateAdaptiveScore(currentMetrics, InitialTemperature);

            double temperature = InitialTemperature;
            int totalIterations = (int)Math.Log(0.1 / InitialTemperature, CoolingRate) * _iterationsPerTemperature;
            int currentIteration = 0;

            while (temperature > 0.1)
            {
                for (int i = 0; i < _iterationsPerTemperature; i++)
                {
                    _cancellationToken.ThrowIfCancellationRequested();

                    var newSolution = _utility.GenerujSasiada(currentSolution);
                    ConstraintValidationService.RepairSchedule(newSolution, _daneWejsciowe);

                    var newMetrics = EvaluationAndScoringService.CalculateMetrics(newSolution, _utility.ObliczOblozenie(newSolution), _daneWejsciowe);
                    double newFitness = CalculateAdaptiveScore(newMetrics, temperature);

                    if (newFitness > currentFitness || _random.NextDouble() < Math.Exp((newFitness - currentFitness) / temperature))
                    {
                        currentSolution = newSolution;
                        currentFitness = newFitness;

                        double fullNewFitness = EvaluationAndScoringService.CalculateScore(newMetrics, _kolejnoscPriorytetow, _daneWejsciowe);
                        if (fullNewFitness > bestFitness)
                        {
                            bestSolution = new Dictionary<DateTime, Lekarz?>(currentSolution);
                            bestFitness = fullNewFitness;
                        }
                    }
                    currentIteration++;
                }
                temperature *= CoolingRate;
                if (totalIterations > 0)
                {
                    _progressReporter?.Report((double)currentIteration / totalIterations);
                }
            }

            return EvaluationAndScoringService.CalculateMetrics(bestSolution, _utility.ObliczOblozenie(bestSolution), _daneWejsciowe);
        }
    }
}
----- END FILE: GrafikWPF\SimulatedAnnealingSolver.cs -----

----- BEGIN FILE: GrafikWPF\SolverDiagnostics.cs -----
#nullable enable
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text;
using System.Threading;

namespace GrafikWPF
{
    /// <summary>
    /// Bardzo prosty i bezpieczny logger do pliku na potrzeby diagnozy solverów.
    /// Domyślna lokalizacja: Dokumenty\Grafikomat_logs\log_YYYYMMDD_HHMMSS.txt
    /// Użycie (w kodzie solvera lub UI):
    ///     SolverDiagnostics.Enabled = true;
    ///     SolverDiagnostics.Start();            // lub Start("C:\\...\\plik.txt")
    ///     SolverDiagnostics.Log("Tekst...");
    ///     SolverDiagnostics.LogBlock("Tytuł", listaLinii);
    ///     SolverDiagnostics.Stop();
    /// </summary>
    public static class SolverDiagnostics
    {
        private static readonly object _gate = new();
        private static StreamWriter? _writer;
        private static bool _started;

        /// <summary>Czy logowanie jest włączone logicznie (globalny przełącznik).</summary>
        public static bool Enabled { get; set; } = false;

        /// <summary>Pełna ścieżka do bieżącego pliku z logiem (jeśli działa).</summary>
        public static string? CurrentLogPath { get; private set; }

        /// <summary>Czy logger faktycznie zapisuje (Enabled && Start wykonane bez błędu).</summary>
        public static bool IsActive
        {
            get { lock (_gate) return Enabled && _started && _writer != null; }
        }

        /// <summary>Rozpoczęcie sesji logowania. Gdy path==null, tworzy plik w Dokumenty\Grafikomat_logs\log_YYYYMMDD_HHMMSS.txt</summary>
        public static void Start(string? path = null)
        {
            if (!Enabled) return;

            lock (_gate)
            {
                try
                {
                    if (_writer != null) return; // już działa

                    if (string.IsNullOrWhiteSpace(path))
                    {
                        string dir = GetDefaultLogDirectory();
                        Directory.CreateDirectory(dir);
                        string stamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                        path = Path.Combine(dir, $"log_{stamp}.txt");
                    }
                    else
                    {
                        string? dir = Path.GetDirectoryName(path);
                        if (!string.IsNullOrEmpty(dir)) Directory.CreateDirectory(dir);
                    }

                    // Ustawienia pliku: dopisywanie = false (zawsze nowy plik), UTF-8, AutoFlush.
                    _writer = new StreamWriter(new FileStream(path!, FileMode.Create, FileAccess.Write, FileShare.Read))
                    {
                        AutoFlush = true,
                        NewLine = Environment.NewLine
                    };
                    _started = true;
                    CurrentLogPath = path;

                    // Nagłówek pliku
                    _writer.WriteLine($"==== SolverDiagnostics START {DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} ====");
                    _writer.WriteLine($"Machine: {Environment.MachineName}, User: {Environment.UserName}");
                    _writer.WriteLine($"Process: {Process.GetCurrentProcess().ProcessName} (PID {Environment.ProcessId})");
                    _writer.WriteLine(new string('=', 72));
                }
                catch
                {
                    // W razie problemu nie wywracamy programu – po prostu nie logujemy.
                    _writer = null;
                    _started = false;
                    CurrentLogPath = null;
                }
            }
        }

        /// <summary>Zakończenie sesji logowania i zamknięcie pliku.</summary>
        public static void Stop()
        {
            lock (_gate)
            {
                try
                {
                    if (_writer != null)
                    {
                        _writer.WriteLine(new string('=', 72));
                        _writer.WriteLine($"==== SolverDiagnostics STOP {DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} ====");
                        _writer.Flush();
                        _writer.Dispose();
                    }
                }
                catch { /* ignorujemy */ }
                finally
                {
                    _writer = null;
                    _started = false;
                }
            }
        }

        /// <summary>Prosta linia logu z bieżącym czasem. Ignoruje wywołanie, gdy logger nieaktywny.</summary>
        public static void Log(string message)
        {
            if (!Enabled) return;
            lock (_gate)
            {
                if (_writer == null) return;
                try
                {
                    string ts = DateTime.Now.ToString("HH:mm:ss.fff");
                    _writer.WriteLine($"[{ts}] {message}");
                }
                catch { /* ignorujemy – log nie może psuć działania aplikacji */ }
            }
        }

        /// <summary>Blok tekstu z nagłówkiem i listą linii (ładniejsze zrzuty zestawień).</summary>
        public static void LogBlock(string title, IEnumerable<string> lines)
        {
            if (!Enabled) return;
            lock (_gate)
            {
                if (_writer == null) return;
                try
                {
                    string ts = DateTime.Now.ToString("HH:mm:ss.fff");
                    _writer.WriteLine($"[{ts}] --- {title} ---");
                    foreach (var line in lines)
                        _writer.WriteLine(line);
                    _writer.WriteLine($"[{ts}] --- /{title} ---");
                }
                catch { }
            }
        }

        /// <summary>Para klucz-wartość (czytelne parametry, ustawienia, decyzje).</summary>
        public static void LogKeyValue(string key, string value)
        {
            Log($"{key}: {value}");
        }

        /// <summary>Logowanie wyjątku (z krótkim kontekstem).</summary>
        public static void LogException(Exception ex, string? context = null)
        {
            if (!Enabled) return;
            lock (_gate)
            {
                if (_writer == null) return;
                try
                {
                    string ts = DateTime.Now.ToString("HH:mm:ss.fff");
                    _writer.WriteLine($"[{ts}] !! EXCEPTION {(context ?? "")}".Trim());
                    _writer.WriteLine(ex.GetType().FullName);
                    _writer.WriteLine(ex.Message);
                    _writer.WriteLine(ex.StackTrace);
                    if (ex.InnerException != null)
                    {
                        _writer.WriteLine("-- InnerException --");
                        _writer.WriteLine(ex.InnerException.GetType().FullName);
                        _writer.WriteLine(ex.InnerException.Message);
                        _writer.WriteLine(ex.InnerException.StackTrace);
                    }
                    _writer.WriteLine(new string('-', 56));
                }
                catch { }
            }
        }

        /// <summary>Pomocnicza metoda: domyślny katalog logów w Dokumentach.</summary>
        public static string GetDefaultLogDirectory()
        {
            string docs = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            return Path.Combine(docs, "Grafikomat_logs");
        }

        /// <summary>
        /// Krótkie, wygodne formatowanie dla zestawień (np. „Dzień 2025-09-14: [Ala-Chcę, Ola-Mogę]”).
        /// </summary>
        public static string JoinInline(IEnumerable<string> items, string sep = ", ")
        {
            return string.Join(sep, items ?? Array.Empty<string>());
        }
    }
}

----- END FILE: GrafikWPF\SolverDiagnostics.cs -----

----- BEGIN FILE: GrafikWPF\SolverFactory.cs -----
namespace GrafikWPF
{
    public static class SolverFactory
    {
        public static IGrafikSolver CreateSolver(
            SolverType typ,
            GrafikWejsciowy daneWejsciowe,
            List<SolverPriority> kolejnoscPriorytetow,
            IProgress<double>? progress,
            CancellationToken token)
        {
            switch (typ)
            {
                case SolverType.Backtracking:
                    return new BacktrackingSolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
                case SolverType.AStar:
                    return new AStarSolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
                case SolverType.Genetic:
                    return new GeneticSolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
                case SolverType.SimulatedAnnealing:
                    return new SimulatedAnnealingSolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
                case SolverType.TabuSearch:
                    return new TabuSearchSolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
                case SolverType.AntColony:
                    return new AntColonySolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
                default:
                    return new BacktrackingSolver(daneWejsciowe, kolejnoscPriorytetow, progress, token);
            }
        }
    }
}
----- END FILE: GrafikWPF\SolverFactory.cs -----

----- BEGIN FILE: GrafikWPF\SolverOptions.cs -----
namespace GrafikWPF
{
    public sealed class SolverOptions
    {
        public bool UseFlowUB { get; init; } = true;
        public int FlowCheckEveryDepth { get; init; } = 8;
        public bool UseGreedySeed { get; init; } = true;
        public bool UseLocalSearch { get; init; } = true;
        public bool UseTT { get; init; } = false;
        public int ProgressReportModulo { get; init; } = 0x7FF; // Przywrócono pierwotną wartość

        // A*
        public bool UseARAStar { get; init; } = false;
        public double[] EpsilonSchedule { get; init; } = new[] { 3.0, 2.0, 1.5, 1.0 };
        public double WeightedAStarW { get; init; } = 1.0;
        public int TimeBudgetSeconds { get; init; } = 60;

        // Beam (opcjonalnie)
        public int? BeamWidth { get; init; } = null;
    }
}
----- END FILE: GrafikWPF\SolverOptions.cs -----

----- BEGIN FILE: GrafikWPF\SolverPolicyStatus.cs -----
#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;

namespace GrafikWPF
{
    /// <summary>
    /// ETAP 0 (diagnostyka): wspólny nagłówek statusu polityk solvera oraz miękkie asercje.
    /// Ten plik NIE zmienia logiki – tylko loguje i ostrzega, jeśli konfiguracja wygląda podejrzanie.
    /// </summary>
    internal static class SolverPolicyStatus
    {
        /// <summary>
        /// Wypisuje do loga jeden, czytelny nagłówek bieżących priorytetów i polityk.
        /// </summary>
        /// <param name="solverName">Nazwa silnika (np. "Backtracking").</param>
        /// <param name="priorities">Kolejność priorytetów z UI (dynamiczna!).</param>
        /// <param name="chProtectEnabled">Czy aktywne jest jakiekolwiek „rezerwowanie” CH/BC (powinno być OFF w tej fazie).</param>
        /// <param name="bcBreaksAdjacent">Czy BC może łamać zakazy sąsiedztwa (dzień-po-dniu i „Inny dyżur ±1”).</param>
        /// <param name="mwMax">Maksymalna liczba MW (Mogę warunkowo) na lekarza – oczekujemy 1.</param>
        /// <param name="rhK">Zakres rolling horizon K: (min,max) – np. (2,7).</param>
        /// <param name="lrBack">Zakres cofki LocalRepair: (min,max) – np. (5,14).</param>
        /// <param name="lrFwd">Zakres „w przód” LocalRepair: (min,max) – np. (4,6).</param>
        public static void LogStartupHeader(
            string solverName,
            IReadOnlyList<SolverPriority> priorities,
            bool chProtectEnabled,
            bool bcBreaksAdjacent,
            int mwMax,
            (int min, int max) rhK,
            (int min, int max) lrBack,
            (int min, int max) lrFwd)
        {
            // 1) Priorytety w kolejności z UI
            var priOrder = priorities is null || priorities.Count == 0
                ? "(brak)"
                : string.Join(" > ", priorities.Select(GetPriorityLabel));

            // 2) Zbiorczy nagłówek polityk (jedna linia, łatwa do odnalezienia w logu)
            SolverDiagnostics.Log($"[Policy] Solver={solverName}; Priorities=[{priOrder}]; " +
                                  $"CHProtect={(chProtectEnabled ? "ON" : "OFF")}; " +
                                  $"BC_breaks_adjacent={(bcBreaksAdjacent ? "TRUE" : "FALSE")}; " +
                                  $"MW_max={mwMax}; RH_K={rhK.min}..{rhK.max}; LocalRepair back={lrBack.min}..{lrBack.max} fwd={lrFwd.min}..{lrFwd.max}");

            // 3) Miękkie asercje – logują ostrzeżenia, nic nie wyłączają
            SoftAssert(priorities != null, "[ASSERT] priorities == null – brak kolejności priorytetów z UI.");
            SoftAssert(mwMax == 1, "[ASSERT] MW_max != 1 – oczekiwano limitu 1 na lekarza.");
            SoftAssert(!chProtectEnabled, "[ASSERT] CHProtect powinno być OFF (bez twardego rezerwowania CH/BC).");
            SoftAssert(bcBreaksAdjacent, "[ASSERT] BC_breaks_adjacent == FALSE – BC powinno móc łamać sąsiedztwo ±1.");
            SoftAssert(rhK.min >= 1 && rhK.max >= rhK.min,
                       "[ASSERT] Rolling Horizon K ma niepoprawny zakres.");
            SoftAssert(lrBack.min >= 0 && lrBack.max >= lrBack.min,
                       "[ASSERT] LocalRepair back ma niepoprawny zakres.");
            SoftAssert(lrFwd.min >= 0 && lrFwd.max >= lrFwd.min,
                       "[ASSERT] LocalRepair fwd ma niepoprawny zakres.");
        }

        /// <summary>
        /// Dodatkowa „miękka asercja” wykonywana po zakończeniu generowania:
        /// można tu zliczyć np. przekroczenia MW (jeśli solver to loguje/udostępnia dane).
        /// Na ETAP 0: opcjonalne (bezpieczne NO-OP, jeśli nie mamy danych).
        /// </summary>
        public static void LogPostRunSummary(
            string solverName,
            int totalDays,
            int filledDays,
            int prefixLen,
            int emptyDays)
        {
            SolverDiagnostics.Log($"[Policy] PostRun: Solver={solverName}; " +
                                  $"Filled={filledDays}/{totalDays}; Prefix={prefixLen}; Empty={emptyDays}");
        }

        private static void SoftAssert(bool condition, string messageIfFail)
        {
            if (!condition)
                SolverDiagnostics.Log($"WARN {messageIfFail}");
        }

        private static string GetPriorityLabel(SolverPriority p) => p switch
        {
            SolverPriority.CiagloscPoczatkowa => "Ciągłość od początku",
            SolverPriority.LacznaLiczbaObsadzonychDni => "Maks. obsada",
            SolverPriority.SprawiedliwoscObciazenia => "Sprawiedliwość (∝ limitom)",
            SolverPriority.RownomiernoscRozlozenia => "Równomierność",
            _ => p.ToString()
        };
    }
}

----- END FILE: GrafikWPF\SolverPolicyStatus.cs -----

----- BEGIN FILE: GrafikWPF\SolverPriority.cs -----
using System.ComponentModel;

namespace GrafikWPF
{
    public enum SolverPriority
    {
        [Description("Ciągłość obsady od początku miesiąca")]
        CiagloscPoczatkowa,

        [Description("Maksymalna liczba obsadzonych dni")]
        LacznaLiczbaObsadzonychDni,

        [Description("Sprawiedliwe obciążenie lekarzy")]
        SprawiedliwoscObciazenia,

        [Description("Równomierne rozłożenie dyżurów w czasie")]
        RownomiernoscRozlozenia
    }
}
----- END FILE: GrafikWPF\SolverPriority.cs -----

----- BEGIN FILE: GrafikWPF\SolverType.cs -----
namespace GrafikWPF
{
    public enum SolverType
    {
        Backtracking,
        AStar,
        Genetic,
        SimulatedAnnealing,
        TabuSearch,
        AntColony
    }
}
----- END FILE: GrafikWPF\SolverType.cs -----

----- BEGIN FILE: GrafikWPF\SolverUtility.cs -----
using System;
using System.Collections.Generic;
using System.Linq;

namespace GrafikWPF
{
    public class SolverUtility
    {
        private readonly GrafikWejsciowy _daneWejsciowe;
        private readonly Random _random = new();

        public SolverUtility(GrafikWejsciowy daneWejsciowe)
        {
            _daneWejsciowe = daneWejsciowe;
        }

        public Dictionary<DateTime, Lekarz?> StworzChciweRozwiazaniePoczatkowe()
        {
            var genes = new Dictionary<DateTime, Lekarz?>();
            var oblozenie = _daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            var wykorzystaneW = new HashSet<string>();

            foreach (var dzien in _daneWejsciowe.DniWMiesiacu)
            {
                var kandydaci = ConstraintValidationService.GetValidCandidatesForDay(dzien, _daneWejsciowe, genes, oblozenie, wykorzystaneW);
                if (kandydaci.Any())
                {
                    var najlepszyKandydat = kandydaci
                        .OrderByDescending(l => _daneWejsciowe.Dostepnosc[dzien][l.Symbol])
                        .ThenBy(l => oblozenie[l.Symbol])
                        .First();

                    genes[dzien] = najlepszyKandydat;
                    oblozenie[najlepszyKandydat.Symbol]++;
                    if (_daneWejsciowe.Dostepnosc[dzien][najlepszyKandydat.Symbol] == TypDostepnosci.MogeWarunkowo)
                    {
                        wykorzystaneW.Add(najlepszyKandydat.Symbol);
                    }
                }
                else
                {
                    genes[dzien] = null;
                }
            }
            return genes;
        }

        public Dictionary<DateTime, Lekarz?> StworzLosoweRozwiazanie()
        {
            var genes = new Dictionary<DateTime, Lekarz?>();
            var oblozenie = _daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            var wykorzystaneW = new HashSet<string>();

            foreach (var dzien in _daneWejsciowe.DniWMiesiacu)
            {
                var kandydaci = ConstraintValidationService.GetValidCandidatesForDay(dzien, _daneWejsciowe, genes, oblozenie, wykorzystaneW);
                if (kandydaci.Any())
                {
                    var wybrany = kandydaci[_random.Next(kandydaci.Count)];
                    genes[dzien] = wybrany;
                    oblozenie[wybrany.Symbol]++;
                    if (_daneWejsciowe.Dostepnosc[dzien][wybrany.Symbol] == TypDostepnosci.MogeWarunkowo)
                    {
                        wykorzystaneW.Add(wybrany.Symbol);
                    }
                }
                else
                {
                    genes[dzien] = null;
                }
            }
            return genes;
        }

        public Dictionary<DateTime, Lekarz?> GenerujSasiada(Dictionary<DateTime, Lekarz?> obecnyGrafik)
        {
            var nowyGrafik = new Dictionary<DateTime, Lekarz?>(obecnyGrafik);
            var dzienDoZmiany = _daneWejsciowe.DniWMiesiacu[_random.Next(_daneWejsciowe.DniWMiesiacu.Count)];

            var oblozenie = ObliczOblozenie(nowyGrafik);
            var wykorzystaneW = ObliczWykorzystaneW(nowyGrafik).Keys.ToHashSet();

            var kandydaci = ConstraintValidationService.GetValidCandidatesForDay(dzienDoZmiany, _daneWejsciowe, nowyGrafik, oblozenie, wykorzystaneW);

            if (kandydaci.Any())
            {
                nowyGrafik[dzienDoZmiany] = kandydaci[_random.Next(kandydaci.Count)];
            }
            else
            {
                nowyGrafik[dzienDoZmiany] = null;
            }

            return nowyGrafik;
        }

        public Dictionary<string, int> ObliczOblozenie(IReadOnlyDictionary<DateTime, Lekarz?> genes)
        {
            var oblozenie = _daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            foreach (var lekarz in genes.Values)
            {
                if (lekarz != null)
                {
                    oblozenie[lekarz.Symbol]++;
                }
            }
            return oblozenie;
        }

        private Dictionary<string, int> ObliczWykorzystaneW(IReadOnlyDictionary<DateTime, Lekarz?> genes)
        {
            var wykorzystane = _daneWejsciowe.Lekarze.ToDictionary(l => l.Symbol, l => 0);
            foreach (var para in genes)
            {
                if (para.Value != null && _daneWejsciowe.Dostepnosc.ContainsKey(para.Key) && _daneWejsciowe.Dostepnosc[para.Key][para.Value.Symbol] == TypDostepnosci.MogeWarunkowo)
                {
                    wykorzystane[para.Value.Symbol]++;
                }
            }
            return wykorzystane;
        }
    }
}
----- END FILE: GrafikWPF\SolverUtility.cs -----

----- BEGIN FILE: GrafikWPF\TabuSearchSolver.cs -----
namespace GrafikWPF
{
    public class TabuSearchSolver : IGrafikSolver
    {
        private readonly int _tabuListSize;
        private readonly int _maxIterations;
        private readonly GrafikWejsciowy _daneWejsciowe;
        private readonly List<SolverPriority> _kolejnoscPriorytetow;
        private readonly IProgress<double>? _progressReporter;
        private readonly CancellationToken _cancellationToken;
        private readonly SolverUtility _utility;

        public TabuSearchSolver(GrafikWejsciowy daneWejsciowe, List<SolverPriority> kolejnoscPriorytetow, IProgress<double>? progress = null, CancellationToken cancellationToken = default)
        {
            _daneWejsciowe = daneWejsciowe;
            _kolejnoscPriorytetow = kolejnoscPriorytetow;
            _progressReporter = progress;
            _cancellationToken = cancellationToken;
            _utility = new SolverUtility(daneWejsciowe);

            int problemSize = _daneWejsciowe.Lekarze.Count * _daneWejsciowe.DniWMiesiacu.Count;
            _tabuListSize = Math.Max(20, problemSize / 10);
            _maxIterations = Math.Max(300, problemSize * 2);
        }

        private double CalculateAdaptiveScore(RozwiazanyGrafik grafik, int iteration)
        {
            double progress = (double)iteration / _maxIterations;
            int prioritiesToConsider = 1 + (int)(progress * (_kolejnoscPriorytetow.Count - 1));
            var adaptivePriorities = _kolejnoscPriorytetow.Take(prioritiesToConsider).ToList();
            return EvaluationAndScoringService.CalculateScore(grafik, adaptivePriorities, _daneWejsciowe);
        }

        public RozwiazanyGrafik ZnajdzOptymalneRozwiazanie()
        {
            // ZMIANA: Zaczynamy od rozwiązania "chciwego", a nie w pełni losowego.
            var obecneRozwiazanie = _utility.StworzChciweRozwiazaniePoczatkowe();
            var najlepszeRozwiazanie = new Dictionary<DateTime, Lekarz?>(obecneRozwiazanie);

            var metrics = EvaluationAndScoringService.CalculateMetrics(najlepszeRozwiazanie, _utility.ObliczOblozenie(najlepszeRozwiazanie), _daneWejsciowe);
            double najlepszyFitness = EvaluationAndScoringService.CalculateScore(metrics, _kolejnoscPriorytetow, _daneWejsciowe);

            var tabuLista = new Queue<Dictionary<DateTime, Lekarz?>>();
            int iteracjeBezPoprawy = 0;
            int progDywersyfikacji = _maxIterations / 4;

            for (int i = 0; i < _maxIterations; i++)
            {
                _cancellationToken.ThrowIfCancellationRequested();

                var sasiedzi = GenerujSasiadow(obecneRozwiazanie);
                Dictionary<DateTime, Lekarz?>? najlepszySasiad = null;
                double najlepszyFitnessSasiada = double.MinValue;

                foreach (var sasiad in sasiedzi)
                {
                    if (!CzyJestWTabu(sasiad, tabuLista))
                    {
                        var sasiadMetrics = EvaluationAndScoringService.CalculateMetrics(sasiad, _utility.ObliczOblozenie(sasiad), _daneWejsciowe);
                        double sasiadFitness = CalculateAdaptiveScore(sasiadMetrics, i);

                        if (sasiadFitness > najlepszyFitnessSasiada)
                        {
                            najlepszyFitnessSasiada = sasiadFitness;
                            najlepszySasiad = sasiad;
                        }
                    }
                }

                if (najlepszySasiad != null)
                {
                    obecneRozwiazanie = najlepszySasiad;
                    if (tabuLista.Count >= _tabuListSize) tabuLista.Dequeue();
                    tabuLista.Enqueue(obecneRozwiazanie);

                    var sasiadMetricsFull = EvaluationAndScoringService.CalculateMetrics(obecneRozwiazanie, _utility.ObliczOblozenie(obecneRozwiazanie), _daneWejsciowe);
                    double sasiadFitnessFull = EvaluationAndScoringService.CalculateScore(sasiadMetricsFull, _kolejnoscPriorytetow, _daneWejsciowe);

                    if (sasiadFitnessFull > najlepszyFitness)
                    {
                        najlepszyFitness = sasiadFitnessFull;
                        najlepszeRozwiazanie = new Dictionary<DateTime, Lekarz?>(obecneRozwiazanie);
                        iteracjeBezPoprawy = 0;
                    }
                    else
                    {
                        iteracjeBezPoprawy++;
                    }
                }

                if (iteracjeBezPoprawy > progDywersyfikacji)
                {
                    obecneRozwiazanie = Dywersyfikuj(obecneRozwiazanie);
                    iteracjeBezPoprawy = 0;
                }

                _progressReporter?.Report((double)(i + 1) / _maxIterations);
            }

            return EvaluationAndScoringService.CalculateMetrics(najlepszeRozwiazanie, _utility.ObliczOblozenie(najlepszeRozwiazanie), _daneWejsciowe);
        }

        private List<Dictionary<DateTime, Lekarz?>> GenerujSasiadow(Dictionary<DateTime, Lekarz?> obecny)
        {
            var sasiedzi = new List<Dictionary<DateTime, Lekarz?>>();
            int liczbaSasiadow = Math.Max(10, _daneWejsciowe.Lekarze.Count / 2);
            for (int i = 0; i < liczbaSasiadow; i++) sasiedzi.Add(_utility.GenerujSasiada(obecny));
            return sasiedzi;
        }

        private bool CzyJestWTabu(Dictionary<DateTime, Lekarz?> rozwiazanie, Queue<Dictionary<DateTime, Lekarz?>> tabuLista)
        {
            foreach (var tabu in tabuLista)
            {
                if (rozwiazanie.Count == tabu.Count && !rozwiazanie.Except(tabu).Any()) return true;
            }
            return false;
        }

        private Dictionary<DateTime, Lekarz?> Dywersyfikuj(Dictionary<DateTime, Lekarz?> obecny)
        {
            var zdywersyfikowany = new Dictionary<DateTime, Lekarz?>(obecny);
            int liczbaZamian = _daneWejsciowe.DniWMiesiacu.Count / 5;
            for (int i = 0; i < liczbaZamian; i++) zdywersyfikowany = _utility.GenerujSasiada(zdywersyfikowany);
            return zdywersyfikowany;
        }
    }
}
----- END FILE: GrafikWPF\TabuSearchSolver.cs -----

----- BEGIN FILE: GrafikWPF\TimeoutWindow.xaml -----
<Window x:Class="GrafikWPF.TimeoutWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Przekroczono Limit Czasu" Height="220" Width="450"
        WindowStartupLocation="CenterOwner" ResizeMode="NoResize" ShowInTaskbar="False"
        Background="LightGray">
    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" FontSize="16" FontWeight="Bold" Text="Obliczenia Zostały Przerwane"/>
        <TextBlock Grid.Row="1" TextWrapping="Wrap" VerticalAlignment="Center" Margin="0,10">
            <Run>Operacja generowania grafiku została przerwana, ponieważ przekroczyła ustawiony limit 10 minut.</Run>
            <LineBreak/><LineBreak/>
            <Run>Problem może być zbyt złożony dla wybranego algorytmu. Zaleca się wybranie w ustawieniach innego, szybszego silnika (np. jednego z metaheurystycznych).</Run>
        </TextBlock>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right">
            <Button Content="Zmień silnik obliczeniowy..." Click="ChangeAlgorithm_Click" Padding="10,5" Margin="0,0,10,0"/>
            <Button Content="OK" IsDefault="True" IsCancel="True" Padding="10,5" MinWidth="80"/>
        </StackPanel>
    </Grid>
</Window>
----- END FILE: GrafikWPF\TimeoutWindow.xaml -----

----- BEGIN FILE: GrafikWPF\TimeoutWindow.xaml.cs -----
using System.Windows;

namespace GrafikWPF
{
    public partial class TimeoutWindow : Window
    {
        public enum TimeoutResult
        {
            OK,
            ChangeAlgorithm
        }

        public TimeoutResult Result { get; private set; }

        public TimeoutWindow()
        {
            InitializeComponent();
            Result = TimeoutResult.OK; // Domyślna akcja, jeśli okno zostanie zamknięte inaczej
        }

        private void ChangeAlgorithm_Click(object sender, RoutedEventArgs e)
        {
            Result = TimeoutResult.ChangeAlgorithm;
            this.DialogResult = true;
            this.Close();
        }
    }
}
----- END FILE: GrafikWPF\TimeoutWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\UI\ProgressReporter.cs -----
using System;
using System.Diagnostics;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Threading;

namespace GrafikWPF.UI
{
    /// <summary>
    /// Prosty, bezpieczny dla wątków „menedżer postępu” dla WPF.
    /// - Tryb nieokreślony (IsIndeterminate = true) – gdy nie umiemy policzyć procentów.
    /// - Tryb określony (0–100%) – gdy mamy licznik lub szacunkowy limit.
    /// - Throttling: maks. ~10 aktualizacji na sekundę, aby pasek nie „tańczył”.
    /// Użycie:
    ///   var pr = ProgressReporter.For(progressBar);
    ///   pr.StartIndeterminate(); // albo: pr.ReportCount(done, total);
    ///   ...
    ///   pr.StopIndeterminate();
    /// </summary>
    public sealed class ProgressReporter
    {
        private readonly Dispatcher _dispatcher;
        private readonly Action<double> _setValue;
        private readonly Action<bool> _setIndeterminate;

        private readonly Stopwatch _sw = Stopwatch.StartNew();
        private long _lastTicks;
        private double _lastShownValue;

        /// <summary>Minimalny odstęp czasu między kolejnymi aktualizacjami UI (sekundy). 0.1 = 10 Hz.</summary>
        public double MinUpdateIntervalSeconds { get; set; } = 0.1;

        /// <summary>Minimalna różnica (w punktach procentowych 0–100), by wymusić aktualizację mimo throttlingu.</summary>
        public double MinDeltaToForceUpdate { get; set; } = 0.5;

        private ProgressReporter(Dispatcher dispatcher, Action<double> setValue, Action<bool> setIndeterminate)
        {
            _dispatcher = dispatcher ?? throw new ArgumentNullException(nameof(dispatcher));
            _setValue = setValue ?? throw new ArgumentNullException(nameof(setValue));
            _setIndeterminate = setIndeterminate ?? throw new ArgumentNullException(nameof(setIndeterminate));
        }

        /// <summary>
        /// Fabryka dla paska WPF.
        /// </summary>
        public static ProgressReporter For(ProgressBar progressBar)
        {
            if (progressBar == null) throw new ArgumentNullException(nameof(progressBar));
            var dispatcher = progressBar.Dispatcher ?? Application.Current?.Dispatcher
                             ?? throw new InvalidOperationException("Brak Dispatcher dla UI.");

            return new ProgressReporter(
                dispatcher,
                setValue: v => progressBar.Value = Math.Max(progressBar.Minimum, Math.Min(progressBar.Maximum, v)),
                setIndeterminate: on =>
                {
                    progressBar.IsIndeterminate = on;
                    if (on)
                    {
                        // W trybie nieokreślonym nie pokazujemy wartości.
                        // Dla porządku ustaw 0 – pasek i tak animuje się „sam”.
                        progressBar.Value = progressBar.Minimum;
                    }
                });
        }

        /// <summary>Włącz tryb „nie wiem ile – liczę” (animacja płynącej belki).</summary>
        public void StartIndeterminate() => InvokeOnUi(() => _setIndeterminate(true));

        /// <summary>Wyłącz tryb nieokreślony.</summary>
        public void StopIndeterminate() => InvokeOnUi(() => _setIndeterminate(false));

        /// <summary>
        /// Zgłoś postęp jako ułamek 0..1. Wewnętrznie przeliczane na % (0..100).
        /// </summary>
        public void ReportRatio(double ratio01)
        {
            ratio01 = double.IsNaN(ratio01) || double.IsInfinity(ratio01) ? 0.0 : ratio01;
            var clamped = Math.Max(0.0, Math.Min(1.0, ratio01));
            ReportPercent(clamped * 100.0);
        }

        /// <summary>
        /// Zgłoś postęp jako „zrobione / razem”.
        /// </summary>
        public void ReportCount(long done, long total)
        {
            if (total <= 0) { ReportPercent(0); return; }
            var ratio = Math.Max(0.0, Math.Min(1.0, done / (double)total));
            ReportPercent(ratio * 100.0);
        }

        /// <summary>
        /// Zgłoś bezpośrednio procent 0..100. Gwarancja monotoniczności:
        /// wartość nie cofnie się poniżej ostatnio pokazanej.
        /// </summary>
        public void ReportPercent(double percent)
        {
            if (double.IsNaN(percent) || double.IsInfinity(percent)) return;

            // Monotoniczność: nie cofamy się.
            var v = Math.Max(_lastShownValue, Math.Max(0.0, Math.Min(100.0, percent)));

            // Throttling – nie częściej niż 1/MinUpdateIntervalSeconds.
            var nowTicks = _sw.ElapsedTicks;
            var ticksPerUpdate = (long)(Stopwatch.Frequency * MinUpdateIntervalSeconds);
            var enoughTime = nowTicks - _lastTicks >= ticksPerUpdate;
            var bigJump = Math.Abs(v - _lastShownValue) >= MinDeltaToForceUpdate;

            if (!enoughTime && !bigJump) return;

            _lastTicks = nowTicks;
            _lastShownValue = v;

            InvokeOnUi(() =>
            {
                _setIndeterminate(false);
                _setValue(v);
            });
        }

        private void InvokeOnUi(Action action)
        {
            if (action == null) return;
            var d = _dispatcher;
            if (d == null || d.CheckAccess()) { action(); return; }
            d.Invoke(action, DispatcherPriority.Background);
        }
    }
}

----- END FILE: GrafikWPF\UI\ProgressReporter.cs -----

----- BEGIN FILE: GrafikWPF\UstawieniaLekarzyWindow.xaml -----
<Window x:Class="GrafikWPF.UstawieniaLekarzyWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GrafikWPF"
        mc:Ignorable="d"
        Title="Edycja dyżurnych" Height="480" Width="585"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="LightGray"
        Loaded="UstawieniaLekarzyWindow_Loaded">

    <Window.Resources>
        <Style TargetType="TextBox" x:Key="DataTextBoxStyle">
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Background" Value="Transparent"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="Padding" Value="5,0,0,0"/>
            <Style.Triggers>
                <Trigger Property="IsKeyboardFocused" Value="True">
                    <Setter Property="Background" Value="White"/>
                </Trigger>
            </Style.Triggers>
        </Style>
    </Window.Resources>

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Zarządzanie listą dyżurnych" FontSize="18" FontWeight="Bold" HorizontalAlignment="Center"/>
        <Separator Grid.Row="1" Margin="0,10,0,10"/>

        <Grid x:Name="HeaderGrid" Grid.Row="2">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="25"/>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="150"/>
                <ColumnDefinition Width="75"/>
                <ColumnDefinition Width="125"/>
            </Grid.ColumnDefinitions>

            <Border Grid.Column="0" Background="#4F4F4F" BorderBrush="#4F4F4F" BorderThickness="0,0,1,1"/>
            <Border Grid.Column="1" Background="#4F4F4F" BorderBrush="#4F4F4F" BorderThickness="0,0,1,1">
                <TextBlock Text="Nazwisko" Foreground="White" FontWeight="Bold" Padding="5,5,0,5" VerticalAlignment="Center"/>
            </Border>
            <Border Grid.Column="2" Background="#4F4F4F" BorderBrush="#4F4F4F" BorderThickness="0,0,1,1">
                <TextBlock Text="Imię" Foreground="White" FontWeight="Bold" Padding="5,5,0,5" VerticalAlignment="Center"/>
            </Border>
            <Border Grid.Column="3" Background="#4F4F4F" BorderBrush="#4F4F4F" BorderThickness="0,0,1,1">
                <TextBlock Text="Symbol" Foreground="White" FontWeight="Bold" HorizontalAlignment="Center" VerticalAlignment="Center"/>
            </Border>
            <Border Grid.Column="4" Background="#4F4F4F" BorderBrush="#4F4F4F" BorderThickness="0,0,1,1">
                <TextBlock Text="Akcja" Foreground="White" FontWeight="Bold" HorizontalAlignment="Center" VerticalAlignment="Center"/>
            </Border>
        </Grid>

        <Border Grid.Row="3" BorderBrush="DarkGray" BorderThickness="1,0,1,1">
            <ScrollViewer x:Name="LekarzeScrollViewer" VerticalScrollBarVisibility="Auto">
                <ItemsControl x:Name="LekarzeItemsControl" AlternationCount="2" HorizontalContentAlignment="Stretch">
                    <ItemsControl.ItemContainerStyle>
                        <Style TargetType="ContentPresenter">
                            <EventSetter Event="Loaded" Handler="ContentPresenter_Loaded"/>
                        </Style>
                    </ItemsControl.ItemContainerStyle>

                    <ItemsControl.ItemTemplate>
                        <DataTemplate DataType="{x:Type local:Lekarz}">
                            <Grid>
                                <Grid.Style>
                                    <Style TargetType="Grid">
                                        <Setter Property="Opacity" Value="1.0" />
                                        <Style.Triggers>
                                            <DataTrigger Binding="{Binding RelativeSource={RelativeSource AncestorType=ContentPresenter}, Path=(ItemsControl.AlternationIndex)}" Value="1">
                                                <Setter Property="Background" Value="#E6E6E6" />
                                            </DataTrigger>
                                            <DataTrigger Binding="{Binding IsAktywny}" Value="False">
                                                <Setter Property="Opacity" Value="0.5" />
                                            </DataTrigger>
                                        </Style.Triggers>
                                    </Style>
                                </Grid.Style>

                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[0].ActualWidth}"/>
                                    <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[1].ActualWidth}"/>
                                    <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[2].ActualWidth}"/>
                                    <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[3].ActualWidth}"/>
                                    <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[4].ActualWidth}"/>
                                </Grid.ColumnDefinitions>

                                <Border Grid.Column="0" Background="#A9A9A9" BorderBrush="DarkGray" BorderThickness="0,0,1,1">
                                    <TextBlock x:Name="RowNumberTextBlock" HorizontalAlignment="Center" VerticalAlignment="Center"/>
                                </Border>
                                <Border Grid.Column="1" BorderBrush="DarkGray" BorderThickness="0,0,1,1">
                                    <TextBox x:Name="NazwiskoTextBox" Text="{Binding Nazwisko, UpdateSourceTrigger=PropertyChanged}" Style="{StaticResource DataTextBoxStyle}" LostFocus="PoleDanych_LostFocus"/>
                                </Border>
                                <Border Grid.Column="2" BorderBrush="DarkGray" BorderThickness="0,0,1,1">
                                    <TextBox x:Name="ImieTextBox" Text="{Binding Imie, UpdateSourceTrigger=PropertyChanged}" Style="{StaticResource DataTextBoxStyle}" LostFocus="PoleDanych_LostFocus"/>
                                </Border>
                                <Border Grid.Column="3" BorderBrush="DarkGray" BorderThickness="0,0,1,1">
                                    <TextBox Text="{Binding Symbol, UpdateSourceTrigger=PropertyChanged}" MaxLength="3" CharacterCasing="Upper" Style="{StaticResource DataTextBoxStyle}" HorizontalContentAlignment="Center" LostFocus="PoleDanych_LostFocus"/>
                                </Border>
                                <Border Grid.Column="4" BorderBrush="DarkGray" BorderThickness="0,0,1,1" VerticalAlignment="Center" Padding="0,2">
                                    <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Margin="0,0,17,0">
                                        <Button Content="Usuń" Click="ArchiwizujLekarza_Click" Width="60">
                                            <Button.Style>
                                                <Style TargetType="Button">
                                                    <Setter Property="Visibility" Value="Visible"/>
                                                    <Style.Triggers>
                                                        <DataTrigger Binding="{Binding IsAktywny}" Value="False">
                                                            <Setter Property="Visibility" Value="Collapsed"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </Button.Style>
                                        </Button>
                                        <Button Content="Przywróć" Click="PrzywrocLekarza_Click" Width="60">
                                            <Button.Style>
                                                <Style TargetType="Button">
                                                    <Setter Property="Visibility" Value="Collapsed"/>
                                                    <Style.Triggers>
                                                        <DataTrigger Binding="{Binding IsAktywny}" Value="False">
                                                            <Setter Property="Visibility" Value="Visible"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </Button.Style>
                                        </Button>
                                        <Button Content="X" ToolTip="Usuń trwale" Click="UsunTrwaleLekarza_Click" Width="25" Margin="5,0,0,0" FontWeight="Bold" Foreground="Red">
                                            <Button.Style>
                                                <Style TargetType="Button">
                                                    <Setter Property="Visibility" Value="Collapsed"/>
                                                    <Style.Triggers>
                                                        <DataTrigger Binding="{Binding IsAktywny}" Value="False">
                                                            <Setter Property="Visibility" Value="Visible"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </Button.Style>
                                        </Button>
                                    </StackPanel>
                                </Border>
                            </Grid>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
            </ScrollViewer>
        </Border>

        <Grid Grid.Row="4" Margin="0,15,0,0">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
            </Grid.ColumnDefinitions>

            <Button Grid.Column="0" Content="Dodaj nowego dyżurnego" Click="DodajLekarza_Click" Padding="10,5" HorizontalAlignment="Left"/>
            <CheckBox x:Name="PokazUsunietychCheckBox" Grid.Column="1" Content="Pokaż usuniętych" VerticalAlignment="Center" HorizontalAlignment="Left" Margin="20,0,0,0"
                      Checked="PokazUsunietychCheckBox_Changed" Unchecked="PokazUsunietychCheckBox_Changed"/>

            <StackPanel Grid.Column="2" Orientation="Horizontal" HorizontalAlignment="Right">
                <Button Content="Zapisz i Zamknij" IsDefault="True" Click="Zapisz_Click" Margin="0,0,10,0" Padding="10,5"/>
                <Button Content="Anuluj" IsCancel="True" Padding="10,5"/>
            </StackPanel>
        </Grid>
    </Grid>
</Window>
----- END FILE: GrafikWPF\UstawieniaLekarzyWindow.xaml -----

----- BEGIN FILE: GrafikWPF\UstawieniaLekarzyWindow.xaml.cs -----
using System.Collections.ObjectModel;
using System.Globalization;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace GrafikWPF
{
    public partial class UstawieniaLekarzyWindow : Window
    {
        private const int MAKS_AKTYWNYCH_LEKARZY = 20;
        private readonly List<Lekarz> _wszyscyLekarze;
        public ObservableCollection<Lekarz> WidoczniLekarze { get; set; }
        public List<Lekarz> ZaktualizowaniLekarze => _wszyscyLekarze;

        public UstawieniaLekarzyWindow(IEnumerable<Lekarz> aktualniLekarze)
        {
            InitializeComponent();
            _wszyscyLekarze = aktualniLekarze.Select(l => new Lekarz(l.Symbol, l.Imie, l.Nazwisko, l.IsAktywny)).ToList();
            WidoczniLekarze = new ObservableCollection<Lekarz>();
            this.DataContext = this;
        }

        private void UstawieniaLekarzyWindow_Loaded(object sender, RoutedEventArgs e)
        {
            LekarzeItemsControl.ItemsSource = WidoczniLekarze;
            OdswiezWidokLekarzy();
        }

        private void OdswiezWidokLekarzy()
        {
            WidoczniLekarze.Clear();
            var czyPokazacUsunietych = PokazUsunietychCheckBox.IsChecked == true;

            var lekarzeDoWyswietlenia = _wszyscyLekarze
                .Where(l => !l.IsUkryty && (l.IsAktywny || czyPokazacUsunietych))
                .OrderBy(l => !l.IsAktywny)
                .ThenBy(l => l.Nazwisko)
                .ThenBy(l => l.Imie);

            foreach (var lekarz in lekarzeDoWyswietlenia)
            {
                WidoczniLekarze.Add(lekarz);
            }
        }

        private void ValidateForDuplicates(Lekarz currentLekarz)
        {
            if (currentLekarz == null || string.IsNullOrWhiteSpace(currentLekarz.Imie) || string.IsNullOrWhiteSpace(currentLekarz.Nazwisko) || string.IsNullOrWhiteSpace(currentLekarz.Symbol))
            {
                return;
            }

            var duplicate = _wszyscyLekarze.FirstOrDefault(l =>
                l != currentLekarz &&
                l.Imie.Trim().Equals(currentLekarz.Imie.Trim(), StringComparison.InvariantCultureIgnoreCase) &&
                l.Nazwisko.Trim().Equals(currentLekarz.Nazwisko.Trim(), StringComparison.InvariantCultureIgnoreCase) &&
                l.Symbol.Trim().Equals(currentLekarz.Symbol.Trim(), StringComparison.InvariantCultureIgnoreCase));

            if (duplicate != null)
            {
                MessageBox.Show($"Wykryto duplikat. Dyżurny '{duplicate.PelneImie}' z symbolem '{duplicate.Symbol}' już istnieje na liście.", "Zduplikowane Dane", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        private void Zapisz_Click(object sender, RoutedEventArgs e)
        {
            var grupyDuplikatow = _wszyscyLekarze
                .Where(l => !l.IsUkryty && !string.IsNullOrWhiteSpace(l.Imie) && !string.IsNullOrWhiteSpace(l.Nazwisko) && !string.IsNullOrWhiteSpace(l.Symbol))
                .GroupBy(l => $"{l.Imie.Trim().ToLower()}|{l.Nazwisko.Trim().ToLower()}|{l.Symbol.Trim().ToUpper()}")
                .Where(g => g.Count() > 1)
                .ToList();

            if (grupyDuplikatow.Any())
            {
                string message = "Wykryto zduplikowane wpisy. Co chcesz zrobić?\n\n[Tak] = Automatycznie usuń duplikaty i zapisz.\n[Nie] = Wróć do edycji, aby ręcznie poprawić.\n[Anuluj] = Odrzuć wszystkie zmiany z tej sesji.";
                MessageBoxResult result = MessageBox.Show(this, message, "Wykryto Duplikaty", MessageBoxButton.YesNoCancel, MessageBoxImage.Warning);

                switch (result)
                {
                    case MessageBoxResult.Yes:
                        foreach (var grupa in grupyDuplikatow)
                        {
                            var duplikatyDoUsuniecia = grupa.Skip(1).ToList();
                            foreach (var duplikat in duplikatyDoUsuniecia)
                            {
                                _wszyscyLekarze.Remove(duplikat);
                            }
                        }
                        break;

                    case MessageBoxResult.No:
                        OdswiezWidokLekarzy();
                        return;

                    case MessageBoxResult.Cancel:
                        this.DialogResult = false;
                        this.Close();
                        return;
                }
            }

            var niekompletnyWpis = _wszyscyLekarze.FirstOrDefault(l => l.IsAktywny && !l.IsUkryty && (string.IsNullOrWhiteSpace(l.Imie) || string.IsNullOrWhiteSpace(l.Nazwisko) || string.IsNullOrWhiteSpace(l.Symbol)));
            if (niekompletnyWpis != null)
            {
                MessageBox.Show("Uzupełnij wszystkie dane (Imię, Nazwisko, Symbol) dla aktywnych dyżurnych lub usuń pusty wiersz.", "Niekompletne Dane", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            this.DialogResult = true;
            this.Close();
        }

        private void Anuluj_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = false;
            this.Close();
        }

        private void DodajLekarza_Click(object sender, RoutedEventArgs e)
        {
            var pustyLekarz = _wszyscyLekarze.FirstOrDefault(l =>
                string.IsNullOrWhiteSpace(l.Imie) &&
                string.IsNullOrWhiteSpace(l.Nazwisko) &&
                string.IsNullOrWhiteSpace(l.Symbol) &&
                !l.IsUkryty);

            if (pustyLekarz != null)
            {
                LekarzeScrollViewer.ScrollToBottom();
                if (LekarzeItemsControl.ItemContainerGenerator.ContainerFromItem(pustyLekarz) is FrameworkElement container)
                {
                    var textBox = FindVisualChild<TextBox>(container);
                    textBox?.Focus();
                }
                return;
            }

            if (_wszyscyLekarze.Count(l => l.IsAktywny && !l.IsUkryty) >= MAKS_AKTYWNYCH_LEKARZY)
            {
                MessageBox.Show($"Osiągnięto maksymalny limit {MAKS_AKTYWNYCH_LEKARZY} aktywnych dyżurnych. Aby dodać nowego, najpierw usuń (zarchiwizuj) kogoś z listy.", "Limit Osiągnięty", MessageBoxButton.OK, MessageBoxImage.Information);
                return;
            }

            var nowyLekarz = new Lekarz();
            _wszyscyLekarze.Add(nowyLekarz);
            OdswiezWidokLekarzy();

            Dispatcher.BeginInvoke(new Action(() =>
            {
                LekarzeScrollViewer.ScrollToEnd();
                if (LekarzeItemsControl.ItemContainerGenerator.ContainerFromItem(nowyLekarz) is FrameworkElement container)
                {
                    var textBox = FindVisualChild<TextBox>(container);
                    textBox?.Focus();
                }
            }), System.Windows.Threading.DispatcherPriority.Background);
        }

        private void ArchiwizujLekarza_Click(object sender, RoutedEventArgs e)
        {
            if ((sender as FrameworkElement)?.DataContext is Lekarz lekarz)
            {
                var wynik = MessageBox.Show($"Czy na pewno chcesz usunąć dyżurnego: {lekarz.PelneImie}? Dyżurny zostanie zarchiwizowany i nie będzie już brany pod uwagę w przyszłych grafikach. Dane archiwalne pozostaną nienaruszone. Będzie można go przywrócić w dowolnym momencie.", "Potwierdzenie usunięcia", MessageBoxButton.YesNo, MessageBoxImage.Warning);
                if (wynik == MessageBoxResult.Yes)
                {
                    lekarz.IsAktywny = false;
                    OdswiezWidokLekarzy();
                }
            }
        }

        private void PrzywrocLekarza_Click(object sender, RoutedEventArgs e)
        {
            if ((sender as FrameworkElement)?.DataContext is Lekarz lekarz)
            {
                if (_wszyscyLekarze.Count(l => l.IsAktywny && !l.IsUkryty) >= MAKS_AKTYWNYCH_LEKARZY)
                {
                    MessageBox.Show($"Osiągnięto maksymalny limit {MAKS_AKTYWNYCH_LEKARZY} aktywnych dyżurnych. Aby przywrócić tego dyżurnego, należy najpierw usunąć (zarchiwizować) innego.", "Limit Osiągnięty", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                lekarz.IsAktywny = true;
                OdswiezWidokLekarzy();
            }
        }

        private void UsunTrwaleLekarza_Click(object sender, RoutedEventArgs e)
        {
            if ((sender as FrameworkElement)?.DataContext is Lekarz lekarz)
            {
                var wynik = MessageBox.Show($"Czy na pewno chcesz TRWALE UKRYĆ dyżurnego '{lekarz.PelneImie}' z listy?\n\nTa operacja jest NIEODWRACALNA. Dyżurny zniknie z widoku, ale jego dane archiwalne zostaną nienaruszone. Aby go ponownie użyć, musisz dodać go ręcznie od nowa.", "Potwierdzenie trwałego ukrycia", MessageBoxButton.YesNo, MessageBoxImage.Exclamation);
                if (wynik == MessageBoxResult.Yes)
                {
                    lekarz.IsUkryty = true;
                    OdswiezWidokLekarzy();
                }
            }
        }

        private void PoleDanych_LostFocus(object sender, RoutedEventArgs e)
        {
            if (sender is TextBox textBox && textBox.DataContext is Lekarz lekarz)
            {
                // Formatowanie
                if (textBox.Name == "ImieTextBox") lekarz.Imie = FormatPersonName(lekarz.Imie);
                if (textBox.Name == "NazwiskoTextBox") lekarz.Nazwisko = FormatSurname(lekarz.Nazwisko);

                // Sugerowanie symbolu
                if (textBox.Name == "NazwiskoTextBox" && string.IsNullOrWhiteSpace(lekarz.Symbol) && !string.IsNullOrWhiteSpace(lekarz.Nazwisko) && lekarz.Nazwisko.Length >= 3)
                {
                    string potencjalnySymbol = lekarz.Nazwisko.Substring(0, 3).ToUpper();
                    bool duplikatSymbolu = _wszyscyLekarze.Any(l => l != lekarz && !l.IsUkryty && l.Symbol == potencjalnySymbol);
                    if (!duplikatSymbolu)
                    {
                        lekarz.Symbol = potencjalnySymbol;
                    }
                }

                ValidateForDuplicates(lekarz);
            }
        }

        private string FormatPersonName(string name)
        {
            if (string.IsNullOrWhiteSpace(name)) return string.Empty;
            string cleanedName = Regex.Replace(name.Trim(), @"\s+", " ");
            return new CultureInfo("pl-PL", false).TextInfo.ToTitleCase(cleanedName.ToLower());
        }

        private string FormatSurname(string surname)
        {
            if (string.IsNullOrWhiteSpace(surname)) return string.Empty;
            string cleanedSurname = Regex.Replace(surname.Trim(), @"\s*-\s*", "-");
            cleanedSurname = Regex.Replace(cleanedSurname, @"\s+", "-");
            TextInfo textInfo = new CultureInfo("pl-PL", false).TextInfo;
            var parts = cleanedSurname.Split('-').Select(p => textInfo.ToTitleCase(p.ToLower()));
            return string.Join("-", parts.Where(p => !string.IsNullOrEmpty(p)));
        }

        public static T? FindVisualChild<T>(DependencyObject parent) where T : DependencyObject
        {
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                if (child is T typedChild)
                {
                    return typedChild;
                }
                var result = FindVisualChild<T>(child);
                if (result != null) return result;
            }
            return null;
        }

        private void ContentPresenter_Loaded(object sender, RoutedEventArgs e)
        {
            if (sender is ContentPresenter presenter)
            {
                var item = presenter.Content;
                int index = LekarzeItemsControl.Items.IndexOf(item);
                var textBlock = presenter.ContentTemplate.FindName("RowNumberTextBlock", presenter) as TextBlock;
                if (textBlock != null)
                {
                    textBlock.Text = (index + 1).ToString();
                }
            }
        }

        private void PokazUsunietychCheckBox_Changed(object sender, RoutedEventArgs e)
        {
            if (this.IsLoaded)
            {
                OdswiezWidokLekarzy();
            }
        }
    }
}
----- END FILE: GrafikWPF\UstawieniaLekarzyWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\UstawieniaOgolneWindow.xaml -----
<Window x:Class="GrafikWPF.UstawieniaOgolneWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GrafikWPF"
        mc:Ignorable="d"
        Title="Ustawienia Ogólne" Height="260" Width="500"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        Background="LightGray">
    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Ustawienia Ogólne" FontSize="18" FontWeight="Bold" HorizontalAlignment="Center"/>
        <Separator Grid.Row="1" Margin="0,10,0,10"/>

        <Grid Grid.Row="2">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <TextBlock Grid.Row="0" Grid.Column="0" Text="Nazwa Oddziału/Zakładu:" VerticalAlignment="Center" Margin="0,0,10,0"/>
            <TextBox Grid.Row="0" Grid.Column="1" Text="{Binding NazwaOddzialu, UpdateSourceTrigger=PropertyChanged}" VerticalContentAlignment="Center" Padding="2"/>

            <TextBlock Grid.Row="1" Grid.Column="0" Text="Pełna Nazwa Szpitala:" VerticalAlignment="Center" Margin="0,10,10,0"/>
            <TextBox Grid.Row="1" Grid.Column="1" Text="{Binding NazwaSzpitala, UpdateSourceTrigger=PropertyChanged}" VerticalContentAlignment="Center" Padding="2" Margin="0,10,0,0"/>
        </Grid>

        <StackPanel Grid.Row="4" Orientation="Horizontal" HorizontalAlignment="Right">
            <Button Content="Zapisz i Zamknij" IsDefault="True" Click="Zapisz_Click" Margin="0,0,10,0" Padding="10,5"/>
            <Button Content="Anuluj" IsCancel="True" Padding="10,5"/>
        </StackPanel>
    </Grid>
</Window>
----- END FILE: GrafikWPF\UstawieniaOgolneWindow.xaml -----

----- BEGIN FILE: GrafikWPF\UstawieniaOgolneWindow.xaml.cs -----
using System.Windows;

namespace GrafikWPF
{
    public partial class UstawieniaOgolneWindow : Window
    {
        public string NazwaOddzialu { get; set; }
        public string NazwaSzpitala { get; set; }

        public UstawieniaOgolneWindow(DaneAplikacji dane)
        {
            InitializeComponent();
            NazwaOddzialu = dane.NazwaOddzialu;
            NazwaSzpitala = dane.NazwaSzpitala;
            this.DataContext = this;
        }

        private void Zapisz_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
            this.Close();
        }
    }
}
----- END FILE: GrafikWPF\UstawieniaOgolneWindow.xaml.cs -----

----- BEGIN FILE: GrafikWPF\WyborAlgorytmuWindow.xaml -----
<Window x:Class="GrafikWPF.WyborAlgorytmuWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:GrafikWPF"
        mc:Ignorable="d"
        Title="Wybór Silnika Obliczeniowego" 
        SizeToContent="Height" Width="1150"
        WindowStartupLocation="CenterOwner"
        ResizeMode="NoResize"
        WindowStyle="SingleBorderWindow"
        Background="LightGray">

    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Wybór Silnika Obliczeniowego" FontSize="18" FontWeight="Bold" HorizontalAlignment="Center"/>

        <TextBlock Grid.Row="1" Margin="0,15,0,0" TextWrapping="Wrap" TextAlignment="Justify" LineHeight="20" FontWeight="Bold" FontSize="13">
            <Run FontWeight="Bold">Problem optymalnego ułożenia grafiku dyżurów jest wysoce złożonym zagadnieniem z dziedziny optymalizacji kombinatorycznej.</Run>
            <Run>Ilość możliwych grafików do przeanalizowania rośnie wykładniczo i zależy od wielu czynników, takich jak liczba dostępnych dyżurnych, a także zgłoszonych przez nich: ograniczeń w maksymalnej ilości dyżurów, rodzaju i ilości deklaracji dostępności. Nawet dla średniej wielkości problemu, liczba kombinacji może łatwo osiągnąć wartości astronomiczne, uniemożliwiając ich pełne sprawdzenie w rozsądnym czasie. Z tego powodu program wykorzystuje zaawansowane algorytmy (silniki obliczeniowe), które za pomocą inteligentnych technik heurystycznych skracają czas poszukiwania rozwiązania o wiele rzędów wielkości.</Run>
            <LineBreak/><LineBreak/>
            <Run>Należy jednak pamiętać, że w zależności od wybranego poniżej silnika, istnieje kompromis pomiędzy gwarancją znalezienia rozwiązania idealnego a szybkością jego uzyskania. Dlatego też, w zależności od wybranego silnika, może różnić się nie tylko czas obliczeń, ale i ostateczny wygląd wygenerowanego grafiku.</Run>
        </TextBlock>

        <Grid Grid.Row="2" Margin="0,15,0,0">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="Auto" MinWidth="250"/>
                <ColumnDefinition Width="*"/>
            </Grid.ColumnDefinitions>

            <GroupBox Grid.Column="0" Header="Dostępne silniki" FontWeight="Bold" BorderBrush="DarkGray" VerticalAlignment="Top">
                <ItemsControl ItemsSource="{Binding AlgorithmOptions}" Margin="10">
                    <ItemsControl.ItemTemplate>
                        <DataTemplate>
                            <Label Target="{Binding ElementName=rb}" MouseLeftButtonDown="AlgorithmLabel_MouseLeftButtonDown" Cursor="Hand">
                                <StackPanel Margin="0,4">
                                    <Grid>
                                        <Grid.ColumnDefinitions>
                                            <ColumnDefinition Width="Auto"/>
                                            <ColumnDefinition Width="*"/>
                                        </Grid.ColumnDefinitions>
                                        <RadioButton x:Name="rb" Grid.Column="0" 
                                                     GroupName="SolverChoice"
                                                     IsChecked="{Binding IsSelected, Mode=TwoWay}"
                                                     VerticalAlignment="Center"/>
                                        <TextBlock Grid.Column="1" Text="{Binding Name}" FontWeight="SemiBold" Margin="10,0" VerticalAlignment="Center"/>
                                    </Grid>
                                </StackPanel>
                            </Label>
                        </DataTemplate>
                    </ItemsControl.ItemTemplate>
                </ItemsControl>
            </GroupBox>

            <GroupBox Grid.Column="1" Header="Opis techniczny wybranego silnika" FontWeight="Bold" BorderBrush="DarkGray" Margin="10,0,0,0">
                <ContentControl Content="{Binding ActiveDescription}" MinHeight="210" Margin="5">
                    <ContentControl.ContentTemplate>
                        <DataTemplate>
                            <StackPanel Margin="10">
                                <ContentControl Content="{Binding DescriptionHeader}" Margin="0,0,0,8"/>
                                <TextBlock Text="{Binding Description}" 
                                           TextWrapping="Wrap" 
                                           LineHeight="20"
                                           FontSize="12"
                                           FontWeight="Normal"
                                           Foreground="Black"/>
                            </StackPanel>
                        </DataTemplate>
                    </ContentControl.ContentTemplate>
                </ContentControl>
            </GroupBox>
        </Grid>

        <GroupBox Grid.Row="3" Header="Charakterystyka porównawcza" Margin="0,15,0,0" FontWeight="Bold" BorderBrush="DarkGray">
            <StackPanel Margin="10,5,10,10">
                <Border Background="#4F4F4F" BorderBrush="#4F4F4F" BorderThickness="1,1,1,0">
                    <Grid x:Name="HeaderGrid">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="1.8*"/>
                            <ColumnDefinition Width="1.5*"/>
                            <ColumnDefinition Width="1.6*"/>
                            <ColumnDefinition Width="1.2*"/>
                            <ColumnDefinition Width="2.2*"/>
                            <ColumnDefinition Width="1.1*"/>
                            <ColumnDefinition Width="*"/>
                        </Grid.ColumnDefinitions>
                        <Border Grid.Column="0" BorderBrush="DarkGray" BorderThickness="0,0,1,0">
                            <TextBlock Text="Silnik Obliczeniowy" Foreground="White" FontWeight="Bold" Padding="5" TextWrapping="Wrap" TextAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="1" BorderBrush="DarkGray" BorderThickness="0,0,1,0">
                            <TextBlock Text="Typ algorytmu" Foreground="White" FontWeight="Bold" Padding="5" TextWrapping="Wrap" TextAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="2" BorderBrush="DarkGray" BorderThickness="0,0,1,0">
                            <StackPanel Orientation="Horizontal" VerticalAlignment="Center" HorizontalAlignment="Center">
                                <TextBlock Text="Powtarzalność Wyniku" Foreground="White" FontWeight="Bold" Padding="5,5,2,5" VerticalAlignment="Center" TextWrapping="Wrap"/>
                                <TextBlock Text="(?)" Foreground="LightBlue" FontWeight="Bold" VerticalAlignment="Center" Margin="0,0,5,0">
                                    <TextBlock.ToolTip>
                                        <ToolTip>
                                            <TextBlock MaxWidth="300" TextWrapping="Wrap"><Run FontWeight="Bold">Deterministyczny:</Run> Zawsze zwróci ten sam, najlepszy możliwy wynik dla tych samych danych wejściowych.<LineBreak/><LineBreak/><Run FontWeight="Bold">Stochastyczny:</Run> Wynik może się różnić przy każdym uruchomieniu z powodu użycia elementów losowych, co pozwala na znajdowanie bardzo dobrych rozwiązań bez gwarancji powtarzalności.</TextBlock>
                                        </ToolTip>
                                    </TextBlock.ToolTip>
                                </TextBlock>
                            </StackPanel>
                        </Border>
                        <Border Grid.Column="3" BorderBrush="DarkGray" BorderThickness="0,0,1,0">
                            <TextBlock Foreground="White" FontWeight="Bold" Padding="5" TextWrapping="Wrap" TextAlignment="Center" VerticalAlignment="Center"><Run>Wielowątkowość</Run><LineBreak/><Run FontSize="9" FontWeight="Normal">(obsługa możliwości wielordzeniowych CPU)</Run></TextBlock>
                        </Border>
                        <Border Grid.Column="4" BorderBrush="DarkGray" BorderThickness="0,0,1,0">
                            <TextBlock Text="Jakość i Gwarancja Wyniku" Foreground="White" FontWeight="Bold" Padding="5" TextWrapping="Wrap" TextAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="5" BorderBrush="DarkGray" BorderThickness="0,0,1,0">
                            <TextBlock Text="Czas uzyskania wyniku" Foreground="White" FontWeight="Bold" Padding="5" TextWrapping="Wrap" TextAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <Border Grid.Column="6">
                            <TextBlock Text="Użycie pamięci" Foreground="White" FontWeight="Bold" Padding="5" TextWrapping="Wrap" TextAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                    </Grid>
                </Border>
                <Border BorderBrush="DarkGray" BorderThickness="1,0,1,1">
                    <ItemsControl ItemsSource="{Binding ComparisonData}" AlternationCount="2">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <Grid>
                                    <Grid.Style>
                                        <Style TargetType="Grid">
                                            <Setter Property="Background" Value="WhiteSmoke" />
                                            <Style.Triggers>
                                                <DataTrigger Binding="{Binding RelativeSource={RelativeSource AncestorType=ContentPresenter}, Path=(ItemsControl.AlternationIndex)}" Value="1">
                                                    <Setter Property="Background" Value="#E6E6E6" />
                                                </DataTrigger>
                                            </Style.Triggers>
                                        </Style>
                                    </Grid.Style>
                                    <Grid.ColumnDefinitions>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[0].Width}"/>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[1].Width}"/>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[2].Width}"/>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[3].Width}"/>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[4].Width}"/>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[5].Width}"/>
                                        <ColumnDefinition Width="{Binding ElementName=HeaderGrid, Path=ColumnDefinitions[6].Width}"/>
                                    </Grid.ColumnDefinitions>
                                    <Border Grid.Column="0" BorderBrush="LightGray" BorderThickness="0,0,1,1" Padding="8,6">
                                        <TextBlock Text="{Binding Nazwa}" FontWeight="Bold" TextWrapping="Wrap" VerticalAlignment="Center"/>
                                    </Border>
                                    <Border Grid.Column="1" BorderBrush="LightGray" BorderThickness="0,0,1,1" Padding="8,6">
                                        <TextBlock Text="{Binding TypAlgorytmu}" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Center" TextAlignment="Center"/>
                                    </Border>
                                    <Border Grid.Column="2" BorderBrush="LightGray" BorderThickness="0,0,1,1" Padding="8,6">
                                        <TextBlock Text="{Binding Powtarzalnosc}" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Center" TextAlignment="Center"/>
                                    </Border>
                                    <Border Grid.Column="3" BorderBrush="LightGray" BorderThickness="0,0,1,1" Padding="8,6">
                                        <TextBlock Text="{Binding Wielowatkowosc}" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Center" TextAlignment="Center"/>
                                    </Border>
                                    <Border Grid.Column="4" BorderBrush="LightGray" BorderThickness="0,0,1,1" Padding="8,6">
                                        <TextBlock Text="{Binding JakoscGwarancja}" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Center" TextAlignment="Center"/>
                                    </Border>
                                    <Border Grid.Column="5" BorderBrush="LightGray" BorderThickness="0,0,1,1" Padding="8,6">
                                        <TextBlock Text="{Binding CzasUzyskaniaWyniku}" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Center" TextAlignment="Center"/>
                                    </Border>
                                    <Border Grid.Column="6" BorderBrush="LightGray" BorderThickness="0,0,0,1" Padding="8,6">
                                        <TextBlock Text="{Binding UzyciePamieci}" TextWrapping="Wrap" VerticalAlignment="Center" HorizontalAlignment="Center" TextAlignment="Center"/>
                                    </Border>
                                </Grid>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </Border>
            </StackPanel>
        </GroupBox>

        <StackPanel Grid.Row="4" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,20,0,0">
            <Button Content="Benchmark silników..." HorizontalAlignment="Left" Padding="10,5" Click="BenchmarkButton_Click" Margin="0,0,30,0"/>
            <Button Content="Zapisz i Zamknij" IsDefault="True" Click="Save_Click" Margin="0,0,10,0" Padding="10,5"/>
            <Button Content="Anuluj" IsCancel="True" Padding="10,5"/>
        </StackPanel>
    </Grid>
</Window>
----- END FILE: GrafikWPF\WyborAlgorytmuWindow.xaml -----

----- BEGIN FILE: GrafikWPF\WyborAlgorytmuWindow.xaml.cs -----
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;

namespace GrafikWPF
{
    public partial class WyborAlgorytmuWindow : Window, INotifyPropertyChanged
    {
        public class AlgorithmChoice : INotifyPropertyChanged
        {
            public SolverType Type { get; set; }
            public string Name { get; set; } = string.Empty;
            public string Description { get; set; } = string.Empty;
            public object DescriptionHeader { get; set; } = new TextBlock();

            private bool _isSelected;
            public bool IsSelected
            {
                get => _isSelected;
                set { _isSelected = value; OnPropertyChanged(); }
            }

            public event PropertyChangedEventHandler? PropertyChanged;
            protected void OnPropertyChanged([CallerMemberName] string? name = null)
            {
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
            }
        }

        public List<AlgorithmChoice> AlgorithmOptions { get; set; }
        public List<AlgorithmInfo> ComparisonData { get; set; }
        public SolverType SelectedAlgorithm => AlgorithmOptions.First(o => o.IsSelected).Type;

        private AlgorithmChoice? _activeDescription;
        public AlgorithmChoice? ActiveDescription
        {
            get => _activeDescription;
            set { _activeDescription = value; OnPropertyChanged(nameof(ActiveDescription)); }
        }

        public WyborAlgorytmuWindow(SolverType currentSolver)
        {
            InitializeComponent();
            this.DataContext = this;

            AlgorithmOptions = new List<AlgorithmChoice>
            {
                new AlgorithmChoice
                {
                    Type = SolverType.Backtracking,
                    Name = "BacktrackingSolver",
                    DescriptionHeader = CreateHeader("BacktrackingSolver", "algorytm z nawrotami"),
                    Description = "Działa jak skrupulatny detektyw w labiryncie. Systematycznie, krok po kroku, podąża jedną ścieżką, przypisując dyżury dzień po dniu. Gdy trafia w ślepy zaułek (sytuację, w której nie da się obsadzić dyżuru zgodnie z regułami), powraca (backtrack) do ostatniego skrzyżowania i próbuje innej drogi. Dzięki wbudowanym mechanizmom 'przycinania' (pruning), potrafi z góry odrzucać całe korytarze, które na pewno nie doprowadzą do lepszego rozwiązania niż już znalezione. Gwarantuje znalezienie idealnego rozwiązania, ale musi 'fizycznie' przejść każdą obiecującą ścieżkę."
                },
                new AlgorithmChoice
                {
                    Type = SolverType.AStar,
                    Name = "AStarSolver",
                    DescriptionHeader = CreateHeader("AStarSolver", "wielokryterialny algorytm A*"),
                    Description = "Można go porównać do doświadczonego nawigatora z mapą i kompasem, który szuka najkrótszej drogi do celu. W każdym momencie analizuje nie tylko już przebytą drogę, ale również inteligentnie szacuje odległość, jaka jeszcze pozostała do końca. Zamiast ślepo badać wszystkie ścieżki jak Backtracking, A* koncentruje swoje wysiłki na tych, które wydają się najbardziej obiecujące. Dzięki temu potrafi znaleźć optymalną trasę znacznie szybciej, omijając wiele niepotrzebnych dróg."
                },
                new AlgorithmChoice
                {
                    Type = SolverType.Genetic,
                    Name = "GeneticSolver",
                    DescriptionHeader = CreateHeader("GeneticSolver", "algorytm genetyczny"),
                    Description = "Inspirowany teorią ewolucji Karola Darwina. Algorytm tworzy początkową 'populację' losowych grafików, a następnie poddaje ją procesowi naturalnej selekcji przez wiele pokoleń. Najlepsze grafiki ('osobniki') są ze sobą 'krzyżowane', wymieniając swoje fragmenty i tworząc nowe 'potomstwo'. Dodatkowo, wprowadzane są losowe 'mutacje', które zapewniają różnorodność. Z pokolenia na pokolenie słabsze rozwiązania są eliminowane, a populacja jako całość staje się coraz 'silniejsza', dążąc do wyłonienia niemal idealnego grafiku."
                },
                new AlgorithmChoice
                {
                    Type = SolverType.SimulatedAnnealing,
                    Name = "SimulatedAnnealingSolver",
                    DescriptionHeader = CreateHeader("SimulatedAnnealingSolver", "algorytm symulowanego wyżarzania"),
                    Description = "Naśladuje proces powolnego studzenia (wyżarzania) metalu, aby uzyskać jego idealną, krystaliczną strukturę. Algorytm zaczyna od wysokiej 'temperatury', na której chętnie akceptuje nawet gorsze modyfikacje grafiku, co pozwala mu na swobodne 'przeskakiwanie' między różnymi typami rozwiązań i unikanie utknięcia w pierwszym znalezionym optimum. W miarę jak 'temperatura' powoli opada, algorytm staje się coraz bardziej 'wybredny' i akceptuje już tylko zmiany, które faktycznie poprawiają wynik. Ten kontrolowany 'chaos' na początku i 'precyzja' na końcu pozwala skutecznie znaleźć bardzo dobre rozwiązania."
                },
                new AlgorithmChoice
                {
                    Type = SolverType.TabuSearch,
                    Name = "TabuSearchSolver",
                    DescriptionHeader = CreateHeader("TabuSearchSolver", "algorytm przeszukiwania z zakazami"),
                    Description = "Wyobraź sobie eksploratora, który notuje w dzienniku ostatnio odwiedzone miejsca, by do nich od razu nie wracać. Ten algorytm w każdym kroku rozgląda się za najlepszą możliwą modyfikacją grafiku w swoim 'sąsiedztwie'. Co ważne, dokona tej zmiany nawet, jeśli chwilowo pogorszy to ogólny wynik. Aby uniknąć zapętlenia się i ciągłego wracania do tych samych rozwiązań, prowadzi 'listę tabu' – krótkoterminową pamięć ruchów, które są tymczasowo 'zakazane'. Pozwala to na wydostanie się z lokalnych optimów i zbadanie szerszego obszaru potencjalnych grafików."
                },
                new AlgorithmChoice
                {
                    Type = SolverType.AntColony,
                    Name = "AntColonySolver",
                    DescriptionHeader = CreateHeader("AntColonySolver", "algorytam kolonii mrówek"),
                    Description = "Działa w oparciu o obserwację kolonii mrówek poszukującej najkrótszej drogi do pożywienia. Wiele wirtualnych 'mrówek' jednocześnie i niezależnie od siebie buduje kompletne grafiki. Każda mrówka, która stworzy dobrej jakości grafik, zostawia za sobą cyfrowy 'ślad feromonowy' na fragmentach, z których korzystała (np. 'przypisanie lekarza X do dnia Y jest dobrym pomysłem'). Kolejne 'pokolenia' mrówek są przyciągane do silniejszych śladów feromonowych, co naturalnie wzmacnia najlepsze elementy i prowadzi całą 'kolonię' do bardzo szybkiego znalezienia optymalnego rozwiązania."
                }
            };

            foreach (var option in AlgorithmOptions)
            {
                option.PropertyChanged += (s, e) =>
                {
                    if (e.PropertyName == nameof(AlgorithmChoice.IsSelected) && option.IsSelected)
                    {
                        ActiveDescription = option;
                    }
                };
            }

            var selectedOption = AlgorithmOptions.FirstOrDefault(o => o.Type == currentSolver) ?? AlgorithmOptions.First();
            selectedOption.IsSelected = true;

            ComparisonData = new List<AlgorithmInfo>
            {
                new AlgorithmInfo("BacktrackingSolver", "Przeszukiwanie zupełne", "Deterministyczny", "Nie", "Gwarancja znalezienia wyniku najlepszego z możliwych.", "Od b. krótkiego do astronomicznie długiego", "Niskie"),
                new AlgorithmInfo("AStarSolver", "Przeszukiwanie heurystyczne", "Deterministyczny", "Nie", "Wynik bardzo wysokiej jakości (bez gwarancji optimum).", "Krótki / Średni", "Wysokie"),
                new AlgorithmInfo("GeneticSolver", "Metaheurystyka ewolucyjna", "Stochastyczny", "Tak", "Wynik bardzo wysokiej jakości, bliski najlepszemu.", "Krótki", "Średnie / Wysokie"),
                new AlgorithmInfo("SimulatedAnnealingSolver", "Metaheurystyka", "Stochastyczny", "Nie", "Wynik zazwyczaj bardzo dobry, lecz bez gwarancji bliskości do wyniku najlepszego z możliwych.", "Średni", "Niskie"),
                new AlgorithmInfo("TabuSearchSolver", "Metaheurystyka", "Stochastyczny", "Nie", "Wynik bardzo wysokiej jakości, bliski najlepszemu.", "Krótki", "Średnie"),
                new AlgorithmInfo("AntColonySolver", "Metaheurystyka (inteligencja rozproszona)", "Stochastyczny", "Tak", "Wynik bardzo wysokiej jakości, bliski najlepszemu.", "Krótki", "Wysokie")
            };
        }

        private TextBlock CreateHeader(string name, string description)
        {
            var tb = new TextBlock();
            tb.Inlines.Add(new Bold(new Run(name)));
            tb.Inlines.Add(new Run($" ({description})"));
            return tb;
        }

        private void Save_Click(object sender, RoutedEventArgs e)
        {
            this.DialogResult = true;
            this.Close();
        }

        private void AlgorithmLabel_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if ((sender as FrameworkElement)?.DataContext is AlgorithmChoice choice)
            {
                choice.IsSelected = true;
            }
        }

        private void BenchmarkButton_Click(object sender, RoutedEventArgs e)
        {
            var benchmarkWindow = new BenchmarkWindow
            {
                Owner = this
            };
            benchmarkWindow.ShowDialog();
        }

        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? name = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}
----- END FILE: GrafikWPF\WyborAlgorytmuWindow.xaml.cs -----

